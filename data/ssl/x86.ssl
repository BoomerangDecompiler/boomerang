#
# This file is part of the Boomerang Decompiler.
#
# See the file "LICENSE.TERMS" for information on usage and
# redistribution of this file, and for a DISCLAIMER OF ALL
# WARRANTIES.
#

# Description for instruction semantics of the x86 instruction set.

ENDIANNESS LITTLE;

# Constants defined in hexadecimal (modelling manual)
MAX8BITS  := 0xFF;
MAX16BITS := 0xFFFF;
MAX32BITS := 0xFFFFFFFF;
MAX64BITS := 0xFFFFFFFFFFFFFFFF;
MAX8POS   := 0x7F;
MAX8NEG   := 0x80;
MAX16POS  := 0x7FFF;
MAX16NEG  := 0x8000;
MAX32POS  := 0x7FFFFFFF;
MAX32NEG  := 0x80000000;

INTEGER %eax[32] -> 24;
INTEGER %ecx[32] -> 25;
INTEGER %edx[32] -> 26;
INTEGER %ebx[32] -> 27;
INTEGER %esp[32] -> 28;
INTEGER %ebp[32] -> 29;
INTEGER %esi[32] -> 30;
INTEGER %edi[32] -> 31;

INTEGER %ax[16] -> 0 SHARES %eax@[0..15];
INTEGER %cx[16] -> 1 SHARES %ecx@[0..15];
INTEGER %dx[16] -> 2 SHARES %edx@[0..15];
INTEGER %bx[16] -> 3 SHARES %ebx@[0..15];
INTEGER %sp[16] -> 4 SHARES %esp@[0..15];
INTEGER %bp[16] -> 5 SHARES %ebp@[0..15];
INTEGER %si[16] -> 6 SHARES %esi@[0..15];
INTEGER %di[16] -> 7 SHARES %edi@[0..15];

INTEGER %al[8]  -> 8  SHARES %ax@[0..7];
INTEGER %cl[8]  -> 9  SHARES %cx@[0..7];
INTEGER %dl[8]  -> 10 SHARES %dx@[0..7];
INTEGER %bl[8]  -> 11 SHARES %bx@[0..7];
INTEGER %ah[8]  -> 12 SHARES %ax@[8..15];
INTEGER %ch[8]  -> 13 SHARES %cx@[8..15];
INTEGER %dh[8]  -> 14 SHARES %dx@[8..15];
INTEGER %bh[8]  -> 15 SHARES %bx@[8..15];

INTEGER %es[8]  -> 16;
INTEGER %cs[8]  -> 17;
INTEGER %ss[8]  -> 18;
INTEGER %ds[8]  -> 19;
INTEGER %pc[32] -> -1;

# flags
INTEGER %eflags[32] -> 100;
INTEGER %flags[16]  -> 101 SHARES %eflags@[0..15];

INTEGER
[ %NF, %ZF, %AF, %PF, %SF,
  %CF, %OF, %DF, %IF,
  %FP, %SKIP, %RPT,
  %C0, %C1, %C2, %C3 ][1] -> -1;

FLOAT
[ %st, %st1,        # stack head, stack neck
  %st2, %st3, %st4, %st5, %st6, %st7 ][80] -> 32..39;

INTEGER
# Note: for boomerang, we use the abstract floating point flags %fflags now
%fsw[16] -> 40, #Float status word(16 Bit register Containing information about
                #The state of the FPU.  stores the top of stack pointer
                #information aswell as the exception flags and stack fault
                #information)

%fstp[8] -> 41, #Floating point stack pointer.  Holds the top of stack pointer.
                #NB is bits 11->13 inclusive of the fsw(defined above).

%fcw[16] -> 42; #Floating point Control Word (16 bit register holding
                #information such as the infinity control, rounding control,
                #precision control and exception masks.




#
# Flag adjust functions
#
ADDFLAGS8(op1, op2, result)  {
    *1* %OF := (op1@[7:7] & op2@[7:7] & ~result@[7:7])
                | (~op1@[7:7] & ~op2@[7:7] & result@[7:7])
    *1* %SF := result@[7:7]
    *1* %ZF := (result = 0)
    *1* %CF := (op1@[7:7] & op2@[7:7]) | (~result@[7:7] & (op1@[7:7] | op2@[7:7]))
    *1* %PF := ((result@[7:7] ^ result@[6:6]) ^ (result@[5:5] ^ result@[4:4])) ^ ((result@[3:3] ^ result@[2:2]) ^ (result@[1:1] ^ result@[0:0]))
#   *1* %AF := ?? TODO
};

ADDFLAGS16(op1, op2, result)  {
    *1* %OF := (op1@[15:15] & op2@[15:15] & ~result@[15:15])
                | (~op1@[15:15] & ~op2@[15:15] & result@[15:15])
    *1* %SF := result@[15:15]
    *1* %ZF := (result = 0)
    *1* %CF := (op1@[15:15] & op2@[15:15]) | (~result@[15:15] & (op1@[15:15] | op2@[15:15]))
    *1* %PF := ((result@[7:7] ^ result@[6:6]) ^ (result@[5:5] ^ result@[4:4])) ^ ((result@[3:3] ^ result@[2:2]) ^ (result@[1:1] ^ result@[0:0]))
#   *1* %AF := ?? TODO
};

ADDFLAGS32(op1, op2, result)  {
    *1* %OF := (op1@[31:31] & op2@[31:31] & ~result@[31:31])
                | (~op1@[31:31] & ~op2@[31:31] & result@[31:31])
    *1* %SF := result@[31:31]
    *1* %ZF := (result = 0)
    *1* %CF := (op1@[31:31] & op2@[31:31]) | (~result@[31:31] & (op1@[31:31] | op2@[31:31]))
    *1* %PF := ((result@[7:7] ^ result@[6:6]) ^ (result@[5:5] ^ result@[4:4])) ^ ((result@[3:3] ^ result@[2:2]) ^ (result@[1:1] ^ result@[0:0]))
#   *1* %AF := ??
};

ADDFLAGS64(op1, op2, result)  {
    *1* %OF := (op1@[63:63] & op2@[63:63] & ~result@[63:63])
                | (~op1@[63:63] & ~op2@[63:63] & result@[63:63])
    *1* %SF := result@[63:63]
    *1* %ZF := (result = 0)
    *1* %CF := (op1@[63:63] & op2@[63:63]) | (~result@[63:63] & (op1@[63:63] | op2@[63:63]))
    *1* %PF := ((result@[7:7] ^ result@[6:6]) ^ (result@[5:5] ^ result@[4:4])) ^ ((result@[3:3] ^ result@[2:2]) ^ (result@[1:1] ^ result@[0:0]))
#   *1* %AF := ??
};


SUBFLAGS8(op1, op2, result)  {
    *1* %OF := (op1@[7:7] & ~op2@[7:7] & ~result@[7:7])
                | (~op1@[7:7] & op2@[7:7] & result@[7:7])
    *1* %SF := result@[7:7]
    *1* %ZF := (result = 0)
    *1* %CF := (~op1@[7:7] & op2@[7:7])
                | (result@[7:7] & ~(op1@[7:7] | op2@[7:7]))
    *1* %PF := ((result@[7:7] ^ result@[6:6]) ^ (result@[5:5] ^ result@[4:4])) ^ ((result@[3:3] ^ result@[2:2]) ^ (result@[1:1] ^ result@[0:0]))
#   *1* %AF := ??
};

SUBFLAGS16(op1, op2, result)  {
    *1* %OF := (op1@[15:15] & ~op2@[15:15] & ~result@[15:15])
                | (~op1@[15:15] &(op2@[15:15] & result@[15:15]))
    *1* %SF := result@[15:15]
    *1* %ZF := (result = 0)
    *1* %CF := (~op1@[15:15] & op2@[15:15])
                | (result@[15:15] & (~op1@[15:15] | op2@[15:15]))
    *1* %PF := ((result@[7:7] ^ result@[6:6]) ^ (result@[5:5] ^ result@[4:4])) ^ ((result@[3:3] ^ result@[2:2]) ^ (result@[1:1] ^ result@[0:0]))
#   *1* %AF := ??
};

SUBFLAGS32(op1, op2, result)  {
    *1* %OF := (op1@[31:31] & ~op2@[31:31] & ~result@[31:31])
                | (~op1@[31:31] & op2@[31:31] & result@[31:31])
    *1* %SF := result@[31:31]
    *1* %ZF := (result = 0)
    *1* %CF := (~op1@[31:31] & op2@[31:31])
                | (result@[31:31] & (~op1@[31:31] | op2@[31:31]))
    *1* %PF := ((result@[7:7] ^ result@[6:6]) ^ (result@[5:5] ^ result@[4:4])) ^ ((result@[3:3] ^ result@[2:2]) ^ (result@[1:1] ^ result@[0:0]))
#   *1* %AF := ??
};

SUBFLAGS64(op1, op2, result)  {
    *1* %OF := (op1@[63:63] & ~op2@[63:63] & ~result@[63:63])
                | (~op1@[63:63] & op2@[63:63] & result@[63:63])
    *1* %SF := result@[63:63]
    *1* %ZF := (result = 0)
    *1* %CF := (~op1@[63:63] & op2@[63:63])
                | (result@[63:63] & (~op1@[63:63] | op2@[63:63]))
    *1* %PF := ((result@[7:7] ^ result@[6:6]) ^ (result@[5:5] ^ result@[4:4])) ^ ((result@[3:3] ^ result@[2:2]) ^ (result@[1:1] ^ result@[0:0]))
#   *1* %AF := ??
};

SUBFLAGSFL(op1, op2) {
    *1* %CF := op1 < op2
    *1* %ZF := op1 = op2
};

LOGICALFLAGS8(result)  {
    *1* %CF := 0
    *1* %OF := 0
    *1* %ZF := (result = 0)
    *1* %SF := result@[7:7]
    *1* %PF := ((result@[7:7] ^ result@[6:6]) ^ (result@[5:5] ^ result@[4:4])) ^ ((result@[3:3] ^ result@[2:2]) ^ (result@[1:1] ^ result@[0:0]))
#   *1* %AF := ??
};

LOGICALFLAGS16(result)  {
    *1* %CF := 0
    *1* %OF := 0
    *1* %ZF := (result = 0)
    *1* %SF := result@[15:15]
    *1* %PF := ((result@[7:7] ^ result@[6:6]) ^ (result@[5:5] ^ result@[4:4])) ^ ((result@[3:3] ^ result@[2:2]) ^ (result@[1:1] ^ result@[0:0]))
#   *1* %AF := ??
};

LOGICALFLAGS32(result)  {
    *1* %CF := 0
    *1* %OF := 0
    *1* %ZF := (result = 0)
    *1* %SF := result@[31:31]
    *1* %PF := ((result@[7:7] ^ result@[6:6]) ^ (result@[5:5] ^ result@[4:4])) ^ ((result@[3:3] ^ result@[2:2]) ^ (result@[1:1] ^ result@[0:0]))
#   *1* %AF := ??
};

LOGICALFLAGS64(result)  {
    *1* %CF := 0
    *1* %OF := 0
    *1* %ZF := (result = 0)
    *1* %SF := result@[63:63]
    *1* %PF := ((result@[7:7] ^ result@[6:6]) ^ (result@[5:5] ^ result@[4:4])) ^ ((result@[3:3] ^ result@[2:2]) ^ (result@[1:1] ^ result@[0:0]))
#   *1* %AF := ??
};


IMULTFLAGS8(result)  {
    *1* %CF := (result@[7:15] = 0 or result@[7:15] = 1)
    *1* %OF := (result@[7:15] = 0 or result@[7:15] = 1)
};

IMULTFLAGS16(result)  {
    *1* %CF := (result@[15:31] = 0 or result@[15:31] = 1)
    *1* %OF := (result@[15:31] = 0 or result@[15:31] = 1)
};

IMULTFLAGS32(result)  {
    *1* %CF := (result@[31:63] = 0 or result@[31:63] = 1)
    *1* %OF := (result@[31:63] = 0 or result@[31:63] = 1)
};


MULTFLAGS8(result)  {
    *1* %CF := (result@[8:15] ~= 0)
    *1* %OF := (result@[8:15] ~= 0)
};

MULTFLAGS16(result)  {
    *1* %CF := (result@[16:31] ~= 0)
    *1* %OF := (result@[16:31] ~= 0)
};

MULTFLAGS32(result)  {
    *1* %CF := (result@[32:63] ~= 0)
    *1* %OF := (result@[32:63] ~= 0)
};

ROLFLAGS8(result, op1, count)  {
    *1* %OF := [count = 1?(op1@[7:7])! = %CF:-1]
    *1* %CF := result@[7:7]
};

ROLFLAGS16(result, op1, count)  {
    *1* %OF := [count = 1?(op1@[15:15])! = %CF:-1]
    *1* %CF := result@[15:15]
};

ROLFLAGS32(result, op1, count)  {
    *1* %OF := [count = 1?(op1@[31:31])! = %CF:-1]
    *1* %CF := result@[31:31]
};

RORFLAGS8(result, op1, count)  {
    *1* %CF := result@[7:7]
    *1* %OF := [count = 1?(op1@[7:7])! = (op1@[6:6]):-1]
};

RORFLAGS16(result, op1, count)  {
    *1* %CF := result@[15:15]
    *1* %OF := [count = 1?(op1@[15:15])! = (op1@[14:14]):-1]
};

RORFLAGS32(result, op1, count)  {
    *1* %CF := result@[31:31]
    *1* %OF := [count = 1?(op1@[31:31])! = (op1@[30:30]):-1]
};

SALFLAGS8(result, op1, count)  {
    *1* %CF := op1@[(8 - count):(9 - count)]
    *1* %OF := [count = 1?(result@[7:7])! = %CF:-1]
};

SALFLAGS16(result, op1, count)  {
    *1* %CF := op1@[(16 - count):(17 - count)]
    *1* %OF := [count = 1?(result@[15:15])! = %CF:-1]
};

SALFLAGS32(result, op1, count)  {
    *1* %CF := op1@[(32 - count):(33 - count)]
    *1* %OF := [count = 1?(result@[31:31])! = %CF:-1]
};

SARFLAGS(result, op1, count)  {
    *1* %CF := op1@[(count - 1):count]
    *1* %OF := [count = 1?0:-1]
};

SHRFLAGS8(result, op1, count)  {
    *1* %CF := op1@[(count - 1):count]
    *1* %OF := [count = 1?(result@[7:7])! = %CF:-1]
};

SHRFLAGS16(result, op1, count)  {
    *1* %CF := op1@[(count - 1):count]
    *1* %OF := [count = 1?(result@[15:15])! = %CF:-1]
};

SHRFLAGS32(result, op1, count)  {
    *1* %CF := op1@[(count - 1):count]
    *1* %OF := [count = 1?(result@[31:31])! = %CF:-1]
};

SHLDFLAGS32(result, combine, count)  {
    *1* %CF := combine@[(32 - count):(33 - count)]
    *1* %OF := [count = 1?(result@[31:31])! = %CF:-1]
};

SHLDFLAGS64(result, combine, count)  {
    *1* %CF := combine@[(64 - count):(65 - count)]
    *1* %OF := [count = 1?(result@[63:64])! = %CF:-1]
};

SHRDFLAGS32(result, combine, count)  {
    *1* %CF := combine@[(count - 1):count]
    *1* %OF := [count = 1?(result@[31:31])! = %CF:-1]
};

SHRDFLAGS64(result, combine, count)  {
    *1* %CF := combine@[(count - 1):count]
    *1* %OF := [count = 1?(result@[63:64])! = %CF:-1]
};

SETFFLAGS(op1, op2)  {
    *1* %C3  := [(op1 = op2) ? 1 : 0]
    *1* %C0  := [(op1 < op2) ? 1 : 0]
    *1* %C2  := 0 # If comparison result is unordered, (C3 C2 C0) == 111
};


#
# String instructions
#

# The string instructions
REPS := {"REP", "REPNE"};                       # Repeat prefixes
OREPS := { REPS, ""};                           # Optional repeat prefixes
ALLSZ := {"Brm8rm8", "Wrm16rm16", "Drm32rm32"}; # All size suffixes

# String instructions, not repeated
STRS := { "CMPS", "LODS", "MOVS", "SCAS", "STOS" };

# String instructions, repeated
STRS_R := REPS STRS;

# String instructions, optionally repeated
STRS_OR := OREPS STRS;

STRFL :=       { "CMPS", "SCAS"};                   # Update flags
STRNF :=       { "LODS", "MOVS", "STOS"};           # No update flags
STRSI := OREPS { "CMPS", "LODS", "MOVS" };          # Update esi
STRDI := OREPS { "CMPS", "MOVS", "SCAS", "STOS" };  # Update edi
STRFL_OR := OREPS STRFL;                            # Optionally repeated; flags

CMPS_OR := OREPS CMPS;      # Compare with optional repeat
LODS_OR := OREPS LODS;      # Load with optional repeat
MOVS_OR := OREPS MOVS;      # Move with optional repeat
SCAS_OR := OREPS SCAS;      # Scan with optional repeat
STOS_OR := OREPS STOS;      # Store with optional repeat

# All repeated string instructions
STRS_R[X]ALLSZ[Y] dest, src
            *1* %SKIP := (%ecx = 0);

CMPS_OR[X].B.rm8.rm8 dest, src              *8*  tmpb := dest{8}  - src{8};
CMPS_OR[X].W.rm16.rm16 dest, src            *16* tmph := dest{16} - src{16};
CMPS_OR[X].D.rm32.rm32 dest, src            *32* tmp1 := dest{32} - src{32};

LODS_OR[X].B.rm8.rm8 dest, src              *8*  dest := src{8};
LODS_OR[X].W.rm16.rm16 dest, src            *16* dest := src{16};
LODS_OR[X].D.rm32.rm32 dest, src            *32* dest := src{32};

MOVS_OR[X].B.rm8.rm8 dest, src              *8*  dest := src{8};
MOVS_OR[X].W.rm16.rm16 dest, src            *16* dest := src{16};
MOVS_OR[X].D.rm32.rm32 dest, src            *32* dest := src{32};

SCAS_OR[X].B.rm8.rm8 dest, src              *8*  tmpb := dest{8}  - src{8};
SCAS_OR[X].W.rm16.rm16 dest, src            *16* tmph := dest{16} - src{16};
SCAS_OR[X].D.rm32.rm32 dest, src            *32* tmp1 := dest{32} - src{32};

STOS_OR[X].B.rm8.rm8 dest, src              *8*  dest := src;
STOS_OR[X].W.rm16.rm16 dest, src            *16* dest := src;
STOS_OR[X].D.rm32.rm32 dest, src            *32* dest := src;

# update flags
STRFL_OR[X].B.rm8.rm8 dest, src             SUBFLAGS8(dest{8},   src{8},  tmpb);
STRFL_OR[X].W.rm16.rm16 dest, src           SUBFLAGS16(dest{16}, src{16}, tmph);
STRFL_OR[X].D.rm32.rm32 dest, src           SUBFLAGS32(dest{32}, src{32}, tmp1);

# update (e)si
STRSI[IDX].B.rm8.rm8 dest, src              *32* %esi := %esi + [%DF = 0?1:-1];
STRSI[IDX].W.rm16.rm16 dest, src            *16* %esi := %esi + [%DF = 0?2:-2];
STRSI[IDX].D.rm32.rm32 dest, src            *32* %esi := %esi + [%DF = 0?4:-4];

# update (e)di
STRDI[IDX].B.rm8.rm8 dest, src              *32* %edi := %edi + [%DF = 0?1:-1];
STRDI[IDX].W.rm16.rm16 dest, src            *32* %edi := %edi + [%DF = 0?2:-2];
STRDI[IDX].D.rm32.rm32 dest, src            *32* %edi := %edi + [%DF = 0?4:-4];

# All repeated instructions decrement %ecx
STRS_R[X]ALLSZ[Y] dest, src                 *32* %ecx := %ecx - 1;

# Do the repeat logic
REPIFZ := REP STRFL;
REPIFNZ := REPNE STRFL;
REPALL := REPS STRNF;

REPIFZ[X]ALLSZ[Y]  dest, src                *1* %RPT := %ZF;
REPIFNZ[X]ALLSZ[Y] dest, src                *1* %RPT := ~%ZF;
REPALL[X]ALLSZ[Y]  dest, src                *1* %RPT := 1;

#
REP.STOSD.rm32.reg32 dest, src
    *1* %SKIP := (%ecx = 0)
    *32* dest := src
    *32* %edi := %edi + [%DF = 0?4:-4]
    *32* %ecx := %ecx - 1
    *1* %RPT  := 1
;


#
# Remaining instructions (sorted alphabetically)
#

# AAA
AAA
    *1* tmpadjust := %AF = 1 and ((%al & 0x0F) > 9)
    *8* %al := %al + 6 * tmpadjust
    *8* %ah := %ah + tmpadjust
    *1* %AF := tmpadjust
    *1* %CF := tmpadjust
    *8* %al := %al & 0x0F
;


# AAD
AAD
    *8* %al := %al + ((%ah * 0x0A) & 0xFF)
    *8* %ah := 0
;

AAD.imm8 imm8
    *8* %al := %al + ((%ah * imm8) & 0xFF)
    *8* %ah := 0
;


# AAS
AAS
    *1* tmpadjust := %AF = 1 and ((%al & 0x0F) > 9)
    *8* %al := %al - 6 * tmpadjust
    *8* %ah := %ah - tmpadjust
    *1* %AF := tmpadjust
    *1* %CF := tmpadjust
    *8* %al := %al & 0x0F
;


# ADC
ADC.reg8.imm8 dest, src
    *8* tmpdest := dest
    *8* dest := dest + src + %CF
    ADDFLAGS8(tmpdest, src, dest)
;

ADC.reg8.reg8 dest, src
    *8* tmpdest := dest
    *8* dest := dest + src + %CF
    ADDFLAGS8(tmpdest, src, dest)
;

ADC.reg8.rm8 dest, src
    *8* tmpdest := dest
    *8* dest := dest + src + %CF
    ADDFLAGS8(tmpdest, src, dest)
;

ADC.reg16.imm16 dest, src
    *16* tmpdest := dest
    *16* dest := dest + src + %CF
    ADDFLAGS16(tmpdest, src, dest)
;

ADC.reg16.reg16 dest, src
    *16* tmpdest := dest
    *16* dest := dest + src + %CF
    ADDFLAGS16(tmpdest, src, dest)
;

ADC.reg16.rm16 dest, src
    *16* tmpdest := dest
    *16* dest := dest + src + %CF
    ADDFLAGS16(tmpdest, src, dest)
;

ADC.reg32.imm32 dest, src
    *32* tmpdest := dest
    *32* dest := dest + src + %CF
    ADDFLAGS32(tmpdest, src, dest)
;

ADC.reg32.reg32 dest, src
    *32* tmpdest := dest
    *32* dest := dest + src + %CF
    ADDFLAGS32(tmpdest, src, dest)
;

ADC.reg32.rm32 dest, src
    *32* tmpdest := dest
    *32* dest := dest + src + %CF
    ADDFLAGS32(tmpdest, src, dest)
;

ADC.reg64.rm64 dest, src
    *64* tmpdest := dest
    *64* dest := dest + src + %CF
    ADDFLAGS64(tmpdest, src, dest)
;

ADC.rm8.imm8 dest, src
    *8* tmpdest := dest
    *8* dest := dest + src + %CF
    ADDFLAGS8(tmpdest, src, dest)
;

ADC.rm8.reg8 dest, src
    *8* tmpdest := dest
    *8* dest := dest + src + %CF
    ADDFLAGS8(tmpdest, src, dest)
;

ADC.rm16.imm8 dest, src
    *16* tmpdest := dest
    *16* tmpsrc := sgnex(8, 16, src)
    *16* dest := dest + tmpsrc + %CF
    ADDFLAGS16(tmpdest, tmpsrc, dest)
;

ADC.rm16.imm16 dest, src
    *16* tmpdest := dest
    *16* dest := dest + src + %CF
    ADDFLAGS16(tmpdest, src, dest)
;

ADC.rm16.reg16 dest, src
    *16* tmpdest := dest
    *16* dest := dest + src + %CF
    ADDFLAGS16(tmpdest, src, dest)
;

ADC.rm32.imm8 dest, src
    *32* tmpdest := dest
    *32* tmpsrc := sgnex(8, 32, src)
    *32* dest := dest + tmpsrc + %CF
    ADDFLAGS32(tmpdest, tmpsrc, dest)
;

ADC.rm32.imm32 dest, src
    *32* tmpdest := dest
    *32* dest := dest + src + %CF
    ADDFLAGS32(tmpdest, src, dest)
;

ADC.rm32.reg32 dest, src
    *32* tmpdest := dest
    *32* dest := dest + src + %CF
    ADDFLAGS32(tmpdest, src, dest)
;

ADC.rm64.imm8 dest, src
    *64* tmpdest := dest
    *64* tmpsrc := sgnex(8, 64, src)
    *64* dest := dest + tmpsrc + %CF
    ADDFLAGS64(tmpdest, tmpsrc, dest)
;

ADC.rm64.imm32 dest, src
    *64* tmpdest := dest
    *64* tmpsrc := sgnex(32, 64, src)
    *64* dest := dest + tmpsrc + %CF
    ADDFLAGS64(tmpdest, tmpsrc, dest)
;

ADC.rm64.imm64 dest, src
    *64* tmpdest := dest
    *64* dest := dest + src + %CF
    ADDFLAGS64(tmpdest, src, dest)
;


# ADD
ADD.reg8.imm8 dest, src
    *8* tmp1 := dest
    *8* dest := dest + src
    ADDFLAGS8(tmp1, src, dest)
;

ADD.reg8.reg8 dest, src
    *8* tmp1 := dest
    *8* dest := dest + src
    ADDFLAGS8(tmp1, src, dest)
;

ADD.reg8.rm8 dest, src
    *8* tmp1 := dest
    *8* dest := dest + src
    ADDFLAGS8(tmp1, src, dest)
;

ADD.reg16.imm16 dest, src
    *16* tmp1 := dest
    *16* dest := dest + src
    ADDFLAGS16(tmp1, src, dest)
;

ADD.reg16.reg16 dest, src
    *16* tmp1 := dest
    *16* dest := dest + src
    ADDFLAGS16(tmp1, src, dest)
;

ADD.reg16.rm16 dest, src
    *16* tmp1 := dest
    *16* dest := dest + src
    ADDFLAGS16(tmp1, src, dest)
;

ADD.reg32.imm32 dest, src
    *32* tmp1 := dest
    *32* dest := dest + src
    ADDFLAGS32(tmp1, src, dest)
;

ADD.reg32.reg32 dest, src
    *32* tmp1 := dest
    *32* dest := dest + src
    ADDFLAGS32(tmp1, src, dest)
;

ADD.reg32.rm32 dest, src
    *32* tmp1 := dest
    *32* dest := dest + src
    ADDFLAGS32(tmp1, src, dest)
;

ADD.reg64.rm64 dest, src
    *64* tmp1 := dest
    *64* dest := dest + src
    ADDFLAGS64(tmp1, src, dest)
;

ADD.rm8.imm8 dest, src
    *8* tmp1 := dest
    *8* dest := dest + src
    ADDFLAGS8(tmp1, src, dest)
;

ADD.rm8.reg8 dest, src
    *8* tmp1 := dest
    *8* dest := dest + src
    ADDFLAGS8(tmp1, src, dest)
;

ADD.rm16.imm8 dest, src
    *16* tmp1 := dest
    *16* tmpsrc := sgnex(8, 16, src)
    *16* dest := dest + tmpsrc
    ADDFLAGS16(tmp1, tmpsrc, dest)
;

ADD.rm16.imm16 dest, src
    *16* tmp1 := dest
    *16* dest := dest + src
    ADDFLAGS16(tmp1, src, dest)
;

ADD.rm16.reg16 dest, src
    *16* tmp1 := dest
    *16* dest := dest + src
    ADDFLAGS16(tmp1, src, dest)
;

ADD.rm32.imm8 dest, src
    *32* tmp1 := dest
    *32* tmpsrc := sgnex(8, 32, src)
    *32* dest := dest + tmpsrc
    ADDFLAGS32(tmp1, tmpsrc, dest)
;

ADD.rm32.imm32 dest, src
    *32* tmp1 := dest
    *32* dest := dest + src
    ADDFLAGS32(tmp1, src, dest)
;

ADD.rm32.reg32 dest, src
    *32* tmp1 := dest
    *32* dest := dest + src
    ADDFLAGS32(tmp1, src, dest)
;

ADD.rm64.imm8 dest, src
    *64* tmp1 := dest
    *64* tmpsrc := sgnex(8, 64, src)
    *64* dest := dest + tmpsrc
    ADDFLAGS64(tmp1, tmpsrc, dest)
;

ADD.rm64.imm32 dest, src
    *64* tmp1 := dest
    *64* tmpsrc := sgnex(32, 64, src)
    *64* dest := dest + tmpsrc
    ADDFLAGS64(tmp1, tmpsrc, dest)
;

ADD.rm64.imm64 dest, src
    *64* tmp1 := dest
    *64* dest := dest + src
    ADDFLAGS64(tmp1, src, dest)
;


# AND
AND.reg8.imm8 dest, src
    *8* dest := dest & src
    LOGICALFLAGS8(dest)
;

AND.reg8.reg8 dest, src
    *8* dest := dest & src
    LOGICALFLAGS8(dest)
;

AND.reg8.rm8 dest, src
    *8* dest := dest & src
    LOGICALFLAGS8(dest)
;

AND.reg16.imm16 dest, src
    *16* dest := dest & src
    LOGICALFLAGS16(dest)
;

AND.reg16.reg16 dest, src
    *16* dest := dest & src
    LOGICALFLAGS16(dest)
;

AND.reg16.rm16 dest, src
    *16* dest := dest & src
    LOGICALFLAGS16(dest)
;

AND.reg32.imm32 dest, src
    *32* dest := dest & src
    LOGICALFLAGS32(dest)
;

AND.reg32.reg32 dest, src
    *32* dest := dest & src
    LOGICALFLAGS32(dest)
;

AND.reg32.rm32 dest, src
    *32* dest := dest & src
    LOGICALFLAGS32(dest)
;

AND.reg64.rm64 dest, src
    *64* dest := dest & src
    LOGICALFLAGS64(dest)
;

AND.rm8.imm8 dest, src
    *8* dest := dest & src
    LOGICALFLAGS8(dest)
;

AND.rm8.reg8 dest, src
    *8* dest := dest & src
    LOGICALFLAGS8(dest)
;

AND.rm16.imm8 dest, src
    *16* dest := dest & sgnex(8, 16, src)
    LOGICALFLAGS16(dest)
;

AND.rm16.imm16 dest, src
    *16* dest := dest & src
    LOGICALFLAGS16(dest)
;

AND.rm16.reg16 dest, src
    *16* dest := dest & src
    LOGICALFLAGS16(dest)
;

AND.rm32.imm8 dest, src
    *32* dest := dest & sgnex(8, 32, src)
    LOGICALFLAGS32(dest)
;

AND.rm32.imm32 dest, src
    *32* dest := dest & src
    LOGICALFLAGS32(dest)
;

AND.rm32.reg32 dest, src
    *32* dest := dest & src
    LOGICALFLAGS32(dest)
;

AND.rm64.imm8 dest, src
    *64* dest := dest & sgnex(8, 64, src)
    LOGICALFLAGS64(dest)
;

AND.rm64.imm32 dest, src
    *64* dest := dest & sgnex(32, 64, src)
    LOGICALFLAGS64(dest)
;

AND.rm64.reg64 dest, src
    *64* dest := dest & src
    LOGICALFLAGS64(dest)
;


# BSWAP
BSWAP.reg16 dest
    *16* dest := ((dest & 0x00FF) << 8) |
                 ((dest & 0xFF00) > 8)
;


BSWAP.reg32 dest
    *32* dest := ((dest & 0x000000FF) << 24) |
                 ((dest & 0x0000FF00) <<  8) |
                 ((dest & 0x00FF0000) >>  8) |
                 ((dest & 0xFF000000) >> 24)
;


# BT
BT.reg16.imm16 src, bit
    *1* %CF := src@[bit:bit]
;

BT.reg16.reg16 src, bit
    *1* %CF := src@[bit:bit]
;

BT.reg32.imm32 src, bit
    *1* %CF := src@[bit:bit]
;

BT.reg32.reg32 src, bit
    *1* %CF := src@[bit:bit]
;

BT.rm16.imm16 src, bit
    *1* %CF := src@[bit:bit]
;

BT.rm16.reg16 src, bit
    *1* %CF := src@[bit:bit]
;

BT.rm32.imm32 src, bit
    *1* %CF := src@[bit:bit]
;

BT.rm32.reg32 src, bit
    *1* %CF := src@[bit:bit]
;

BT.rm64.reg64 src, bit
    *1* %CF := src@[bit:bit]
;


# BTC
BTC.reg16.reg16 dest, bit
    *1* %CF := dest@[bit:bit]
    *16* dest := dest ^ (1 << bit)
;

BTC.rm16.imm16 dest, bit
    *1* %CF := dest@[bit:bit]
    *16* dest := dest ^ (1 << bit)
;

BTC.rm16.reg16 dest, bit
    *1* %CF := dest@[bit:bit]
    *16* dest := dest ^ (1 << bit)
;

BTC.reg32.imm32 dest, bit
    *1* %CF := dest@[bit:bit]
    *32* dest := dest ^ (1 << bit)
;

BTC.reg32.reg32 dest, bit
    *1* %CF := dest@[bit:bit]
    *32* dest := dest ^ (1 << bit)
;


# BTR
BTR.reg16.imm16 dest, bit
    *1* %CF := dest@[bit:bit]
    *16* dest := dest & ~(1 << bit)
;

BTR.reg16.reg16 dest, bit
    *1* %CF := dest@[bit:bit]
    *16* dest := dest & ~(1 << bit)
;

BTR.reg32.imm32 dest, bit
    *1* %CF := dest@[bit:bit]
    *32* dest := dest & ~(1 << bit)
;

BTR.reg32.reg32 dest, bit
    *1* %CF := dest@[bit:bit]
    *32* dest := dest & ~(1 << bit)
;

BTR.rm16.imm16 dest, bit
    *1* %CF := dest@[bit:bit]
    *16* dest := dest & ~(1 << bit)
;

BTR.rm16.reg16 dest, bit
    *1* %CF := dest@[bit:bit]
    *16* dest := dest & ~(1 << bit)
;

BTR.rm32.imm32 dest, bit
    *1* %CF := dest@[bit:bit]
    *32* dest := dest & ~(1 << bit)
;

BTR.rm32.reg32 dest, bit
    *1* %CF := dest@[bit:bit]
    *32* dest := dest & ~(1 << bit)
;


# BTS
BTS.reg16.reg16 dest, bit
    *1* %CF := dest@[bit:bit]
    *16* dest := dest | (1 << bit)
;

BTS.reg32.imm32 dest, bit
    *1* %CF := dest@[bit:bit]
    *32* dest := dest | (1 << bit)
;

BTS.reg32.reg32 dest, bit
    *1* %CF := dest@[bit:bit]
    *32* dest := dest | (1 << bit)
;

BTS.rm16.imm16 dest, bit
    *1* %CF := dest@[bit:bit]
    *16* dest := dest | (1 << bit)
;

BTS.rm16.reg16 dest, bit
    *1* %CF := dest@[bit:bit]
    *16* dest := dest | (1 << bit)
;

BTS.rm32.imm32 dest, bit
    *1* %CF := dest@[bit:bit]
    *32* dest := dest | (1 << bit)
;

BTS.rm32.reg32 dest, bit
    *1* %CF := dest@[bit:bit]
    *32* dest := dest | (1 << bit)
;


# CALL
CALL.imm32 dest
    *32* %esp := %esp - 4
    *32* m[%esp] := %pc
    *32* %pc := dest
;

CALL.reg32 dest
    *32* %esp := %esp - 4
    *32* m[%esp] := %pc
    *32* %pc := dest
;

CALL.rm32 dest
    *32* %esp := %esp - 4
    *32* m[%esp] := %pc
    *32* %pc := dest
;


# CDQ
CDQ
    *32* %edx := [%edx@[31:31] = 0 ? 0:0xFFFFFFFF]
;


# CLC
CLC
    *1* %CF := 0
;


# CLD
CLD
    *1* %DF := 0
;


# CLI
CLI
    *1* %IF := 0
;


# CMC
CMC
    *1*%CF := ~%CF
;


# CMOVcc
CMOVA.reg32.reg32    dest, src      *32* ~%CF & ~%ZF         => dest := src;
CMOVA.reg32.rm32     dest, src      *32* ~%CF & ~%ZF         => dest := src;

CMOVAE.reg32.reg32   dest, src      *32* %CF = 0             => dest := src;
CMOVAE.reg32.rm32    dest, src      *32* %CF = 0             => dest := src;

CMOVB.reg32.reg32    dest, src      *32* %CF = 1             => dest := src;
CMOVB.reg32.rm32     dest, src      *32* %CF = 1             => dest := src;

CMOVBE.reg32.reg32   dest, src      *32* %CF | %ZF           => dest := src;
CMOVBE.reg32.rm32    dest, src      *32* %CF | %ZF           => dest := src;

CMOVC.reg32.reg32    dest, src      *32* %CF = 1             => dest := src;
CMOVC.reg32.rm32     dest, src      *32* %CF = 1             => dest := src;

CMOVE.reg32.reg32    dest, src      *32* %ZF = 1             => dest := src;
CMOVE.reg32.rm32     dest, src      *32* %ZF = 1             => dest := src;

CMOVG.reg32.reg32    dest, src      *32* ~%ZF & ~(%SF ^ %OF) => dest := src;
CMOVG.reg32.rm32     dest, src      *32* ~%ZF & ~(%SF ^ %OF) => dest := src;

CMOVGE.reg32.reg32   dest, src      *32* ~(%SF ^ %OF)        => dest := src;
CMOVGE.reg32.rm32    dest, src      *32* ~(%SF ^ %OF)        => dest := src;

CMOVL.reg32.reg32    dest, src      *32* %SF ^ %OF           => dest := src;
CMOVL.reg32.rm32     dest, src      *32* %SF ^ %OF           => dest := src;

CMOVLE.reg32.reg32   dest, src      *32* %ZF | (%SF ^ %OF)   => dest := src;
CMOVLE.reg32.rm32    dest, src      *32* %ZF | (%SF ^ %OF)   => dest := src;

CMOVNA.reg32.reg32   dest, src      *32* %CF | %ZF           => dest := src;
CMOVNA.reg32.rm32    dest, src      *32* %CF | %ZF           => dest := src;

CMOVNAE.reg32.reg32  dest, src      *32* %CF = 1             => dest := src;
CMOVNAE.reg32.rm32   dest, src      *32* %CF = 1             => dest := src;

CMOVNB.reg32.reg32   dest, src      *32* %CF = 0             => dest := src;
CMOVNB.reg32.rm32    dest, src      *32* %CF = 0             => dest := src;

CMOVNBE.reg32.reg32  dest, src      *32* (~%CF & ~%ZF)       => dest := src;
CMOVNBE.reg32.rm32   dest, src      *32* (~%CF & ~%ZF)       => dest := src;

CMOVNC.reg32.reg32   dest, src      *32* %CF = 0             => dest := src;
CMOVNC.reg32.rm32    dest, src      *32* %CF = 0             => dest := src;

CMOVNE.reg32.reg32   dest, src      *32* %ZF = 0             => dest := src;
CMOVNE.reg32.rm32    dest, src      *32* %ZF = 0             => dest := src;

CMOVNG.reg32.reg32   dest, src      *32* %ZF | (%SF ^ %OF)   => dest := src;
CMOVNG.reg32.rm32    dest, src      *32* %ZF | (%SF ^ %OF)   => dest := src;

CMOVNGE.reg32.reg32  dest, src      *32* ~%ZF & ~(%SF ^ %OF) => dest := src;
CMOVNGE.reg32.rm32   dest, src      *32* ~%ZF & ~(%SF ^ %OF) => dest := src;

CMOVNL.reg32.reg32   dest, src      *32* ~(%SF ^ %OF)        => dest := src;
CMOVNL.reg32.rm32    dest, src      *32* ~(%SF ^ %OF)        => dest := src;

CMOVNLE.reg32.reg32  dest, src      *32* ~%ZF & ~(%SF ^ %OF) => dest := src;
CMOVNLE.reg32.rm32   dest, src      *32* ~%ZF & ~(%SF ^ %OF) => dest := src;

CMOVNO.reg32.reg32   dest, src      *32* ~%OF                => dest := src;
CMOVNO.reg32.rm32    dest, src      *32* ~%OF                => dest := src;

CMOVNP.reg32.reg32   dest, src      *32* ~%PF                => dest := src;
CMOVNP.reg32.rm32    dest, src      *32* ~%PF                => dest := src;

CMOVNS.reg32.reg32   dest, src      *32* ~%SF                => dest := src;
CMOVNS.reg32.rm32    dest, src      *32* ~%SF                => dest := src;

CMOVNE.reg32.reg32   dest, src      *32* ~%ZF                => dest := src;
CMOVNE.reg32.rm32    dest, src      *32* ~%ZF                => dest := src;

CMOVO.reg32.reg32    dest, src      *32* %OF                 => dest := src;
CMOVO.reg32.rm32     dest, src      *32* %OF                 => dest := src;

CMOVP.reg32.reg32    dest, src      *32* %PF                 => dest := src;
CMOVP.reg32.rm32     dest, src      *32* %PF                 => dest := src;

CMOVS.reg32.reg32    dest, src      *32* %SF                 => dest := src;
CMOVS.reg32.rm32     dest, src      *32* %SF                 => dest := src;

CMOVZ.reg32.reg32    dest, src      *32* %ZF                 => dest := src;
CMOVZ.reg32.rm32     dest, src      *32* %ZF                 => dest := src;


# CMP
CMP.reg8.imm8 lhs, rhs
    *8* tmpb := lhs - rhs
    SUBFLAGS8(lhs, rhs, tmpb)
;

CMP.reg8.reg8 lhs, rhs
    *8* tmpb := lhs - rhs
    SUBFLAGS8(lhs, rhs, tmpb)
;

CMP.reg8.rm8 lhs, rhs
    *8* tmp1 := lhs - rhs
    SUBFLAGS8(lhs, rhs, tmp1)
;

CMP.reg16.imm16 lhs, rhs
    *16* tmph := lhs - rhs
    SUBFLAGS16(lhs, rhs, tmph)
;

CMP.reg16.reg16 lhs, rhs
    *16* tmph := lhs - rhs
    SUBFLAGS16(lhs, rhs, tmph)
;

CMP.reg16.rm16 lhs, rhs
    *16* tmph := lhs - rhs
    SUBFLAGS16(lhs, rhs, tmph)
;

CMP.reg32.imm8 lhs, rhs
    *32* tmprhs  := sgnex(8, 32, rhs)
    *32* tmp1 := lhs - tmprhs
    SUBFLAGS32(lhs, tmprhs, tmp1)
;

CMP.reg32.imm32 lhs, rhs
    *32* tmp1 := lhs - rhs
    SUBFLAGS32(lhs, rhs, tmp1)
;

CMP.reg32.reg32 lhs, rhs
    *32* tmp1 := lhs - rhs
    SUBFLAGS32(lhs, rhs, tmp1)
;

CMP.reg32.rm32 lhs, rhs
    *32* tmp1 := lhs - rhs
    SUBFLAGS32(lhs, rhs, tmp1)
;

CMP.reg64.rm64 lhs, rhs
    *64* tmp1 := lhs - rhs
    SUBFLAGS64(lhs, rhs, tmp1)
;

CMP.rm8.imm8 lhs, rhs
    *8* tmpb := lhs - rhs
    SUBFLAGS8(lhs, rhs, tmpb)
;

CMP.rm8.reg8 lhs, rhs
    *8* tmpb := lhs - rhs
    SUBFLAGS8(lhs, rhs, tmpb)
;

CMP.rm16.imm8 lhs, rhs
    *16* tmprhs := sgnex(8, 16, rhs)
    *16* tmph := lhs - tmprhs
    SUBFLAGS16(lhs, tmprhs, tmph)
;

CMP.rm16.imm16 lhs, rhs
    *16* tmph := lhs - rhs
    SUBFLAGS16(lhs, rhs, tmph)
;

CMP.rm16.reg16 lhs, rhs
    *16* tmp1 := lhs - rhs
    SUBFLAGS16(lhs, rhs, tmp1)
;

CMP.rm32.imm8 lhs, rhs
    *32* tmprhs := sgnex(8, 32, rhs)
    *32* tmp1 := lhs - tmprhs
    SUBFLAGS32(lhs, tmprhs, tmp1)
;

CMP.rm32.imm32 lhs, rhs
    *32* tmp1 := lhs - rhs
    SUBFLAGS32(lhs, rhs, tmp1)
;

CMP.rm32.reg32 lhs, rhs
    *32* tmp1 := lhs - rhs
    SUBFLAGS32(lhs, rhs, tmp1)
;

CMP.rm64.imm8 lhs, rhs
    *64* tmprhs := sgnex(8, 64, rhs)
    *64* tmp1 := lhs - tmprhs
    SUBFLAGS64(lhs, tmprhs, tmp1)
;

CMP.rm64.imm32 lhs, rhs
    *64* tmprhs := sgnex(32, 64, rhs)
    *64* tmp1 := lhs - tmprhs
    SUBFLAGS64(lhs, tmprhs, tmp1)
;

CMP.rm64.reg64 lhs, rhs
    *64* tmp1 := lhs - rhs
    SUBFLAGS64(lhs, rhs, tmp1)
;


# CMPXCHG
CMPXCHG.rm32.reg32 dest, src
    *1* %ZF := %eax = dest
    *32* %ZF = 1 => dest := src
    *32* %ZF = 0 => %eax := dest
;


# CWDE
CWDE
    *32* %eax := sgnex(16, 32, %ax)
;


# DEC
DEC.reg8 val
    *8* tmpb := val
    *8* val := val - 1
    LOGICALFLAGS8(val)
;

DEC.reg16 val
    *16* tmph := val
    *16* val := val - 1
    LOGICALFLAGS16(val)
;

DEC.reg32 val
    *32* tmp1 := val
    *32* val := val - 1
    LOGICALFLAGS32(val)
;

DEC.rm8 val
    *8* tmpb := val
    *8* val := val - 1
    LOGICALFLAGS8(val)
;

DEC.rm16 val
    *16* tmph := val
    *16* val := val - 1
    LOGICALFLAGS16(val)
;

DEC.rm32 val
    *32* tmp1 := val
    *32* val := val - 1
    LOGICALFLAGS32(val)
;

DEC.rm64 val
    *64* tmp1 := val
    *64* val := val - 1
    LOGICALFLAGS64(val)
;


# DIV (unsigned divide)
DIV.reg32 divisor
    *64* tmp1 := (zfill(32, 64, %edx) << 32) | zfill(32, 64, %eax)
    *32* %eax := tmp1 / divisor
    *32* %edx := tmp1 % divisor
    undefineflags()
;

DIV.rm8 divisor
    *16* tmpdividend := %ax
    *8*  %al := tmpdividend / divisor
    *8*  %ah := tmpdividend % divisor
    undefineflags()
;

DIV.rm16 divisor
    *32* tmpdividend := (zfill(16, 32, %dx) << 16) | zfill(16, 32, %ax)
    *8*  %al := tmpdividend / divisor
    *8*  %ah := tmpdividend % divisor
    undefineflags()
;

DIV.rm32 divisor
    *64* tmp1 := (zfill(32, 64, %edx) << 32) | zfill(32, 64, %eax)
    *32* %eax := tmp1 / divisor
    *32* %edx := tmp1 % divisor
    undefineflags()
;


# FABS
FABS
    *f80* %st := fabs(%st)
;


# FADD
FADD.reg80 val
    *f80* %st := %st +f val
;

FADD.rm32 val
    *f80* %st := %st +f fsize(32, 80, val)
;

FADD.rm64 val
    *f80* %st := %st +f fsize(64, 80, val)
;


# FADDP
FADDP
    *f80* %st1 := %st1 +f %st
    FPOP
;

FADDP.reg80 val
    *f80* val := val +f %st
    FPOP
;


# FCHS
FCHS
    *f80* %st := 0 -f %st
;


# FCOMP
FCOMP.rm64 val
    *f80* tmpD1 := %st
    *f80* tmpD2 := fsize(64, 80, val)
    *f80* tmpD  := %st -f fsize(64, 80, val)
    FPOP
    SETFFLAGS(tmpD1, tmpD2)
;


# FCOMPP
FCOMPP
    *f80* tmpD1 := %st
    *f80* tmpD2 := %st1
    *f80* tmpD := %st -f %st1
    FPOP
    FPOP
    SETFFLAGS(tmpD1, tmpD2)
;


# FDECSTP
FDECSTP
    FPOP
;


# FDIV
FDIV.reg80 val
    *f80* %st := %st /f val
;

FDIV.reg80.reg80 dest, src
    *f80* dest := dest /f src
;

FDIV.rm32 val
    *f80* %st := %st /f fsize(32, 80, val)
;

FDIV.rm64 val
    *f80* %st := %st /f fsize(64, 80, val)
;


# FDIVP
FDIVP.reg80 val
    *f80* val := %st /f val
    FPOP
;

FDIVP.reg80.reg80 dest, src
    *f80* dest := dest /f src
    FPOP
;


# FDIVR
FDIVR.reg80 val
    *f80* %st := val /f %st
;

FDIVR.reg80.reg80 dest, src
    *f80* dest := src /f dest
;

FDIVR.rm32 val
    *f80* %st := fsize(32, 80, val) /f %st
;

FDIVR.rm64 val
    *f80* %st := fsize(64, 80, val) /f %st
;


# FDIVRP
FDIVRP.reg80 val
    *f80* val := %st /f val
    FPOP
;


# FILD
FILD.rm16 val
    FPUSH
    *f80* %st := itof(16, 80, val)
;

FILD.rm32 val
    FPUSH
    *f80* %st := itof(32, 80, val)
;

FILD.rm64 val
    FPUSH
    *f80* %st := itof(64, 80, val)
;


# FISTP
FISTP.rm32 dest
    *32* dest := ftoi(80, 32, %st)
    FPOP
;

FISTP.rm64 dest
    *64* dest := ftoi(80, 64, %st)
    FPOP
;


# FISUB
FISUB.rm16 val
    *f80* %st := %st - itof(16, 80, val)
;


# FISUBR
FISUBR.rm16 val
    *f80* %st := itof(16, 80, val) - %st
;


# FLD
FLD.reg80 val
    *f80* tmpD1 := val
    FPUSH
    *f80* %st := tmpD1
;

FLD.rm32 val
    FPUSH
    *f80* %st := fsize(32, 80, val)
;

FLD.rm64 val
    FPUSH
    *f80* %st := fsize(64, 80, val)
;

FLD.rm80 val
    FPUSH
    *f80* %st := val
;


# FLD1
FLD1
    FPUSH
    *f80* %st := 1.0
;


# FLDCW
FLDCW.rm16 val
    *16* %fcw := val
;


# FLDPI
FLDPI
    FPUSH
    *f80* %st := 3.141592653589793
;


# FLDZ
FLDZ
    FPUSH
    *f80* %st := 0.0
;


# FMUL
FMUL.reg80 val
    *f80* %st := %st *f val
;

FMUL.rm32 val
    *f80* %st := %st *f fsize(32, 80, val)
;

FMUL.rm64 val
    *f80* %st := %st *f fsize(64, 80, val)
;


# FMULP
FMULP.reg80 val
    *f80* val := val *f %st
    FPOP
;


# FNCLEX
FNCLEX
    *8* %fsw@[0:7] := 0
    *1* %fsw@[15:15] := 0
;


# FNSTCW
FNSTCW.rm16 dest
    *16* dest := %fcw
;


# FNSTSW
FNSTSW.reg16 dest # fnstsw.ax
    *8* %ah := %fflags
    *8* %al := 0     # Just so we know it's changed
;


FNSTSW.rm16 dest
    *16* dest := 0
    *1* dest@[14:14] := %C3
    *1* dest@[10:10] := %C2
    *1* dest@[ 9: 9] := %C1
    *1* dest@[ 8: 8] := %C0
;


# FRNDINT
FRNDINT
    *f80* %st := fround(80, 80, %st)
;


# FST
FST.rm32 dest
    *32* dest := fsize(80, 32, %st)
;

FST.rm64 dest
    *64* dest := fsize(80, 64, %st)
;


# FSTP
FSTP.reg80 dest
    *f80* dest := %st
    FPOP
;

FSTP.rm32 dest
    *32* dest := fsize(80,32,%st)
    FPOP
;

FSTP.rm64 dest
    *64* dest := fsize(80,64,%st)
    FPOP
;

FSTP.reg80 dest
    *f80* dest := %st
    FPOP
;


# FSTSW
FSTSW.reg16 dest
    *16* dest := 0
    *1* dest@[14:14] := %C3
    *1* dest@[10:10] := %C2
    *1* dest@[ 9: 9] := %C1
    *1* dest@[ 8: 8] := %C0
;

FSTSW.rm16 dest
    *16* dest := 0
    *1* dest@[14:14] := %C3
    *1* dest@[10:10] := %C2
    *1* dest@[ 9: 9] := %C1
    *1* dest@[ 8: 8] := %C0
;


# FSUB
FSUB.reg80 val
    *f80* %st := %st -f val
;


FSUB.reg80.reg80 dest, src
    *f80* dest := dest -f src
;


# FSUBP
FSUBP.reg80 val
    *f80* val := %st -f val
    FPOP
;


# FSUBR
FSUBR.reg80 val
    *f80* val := val -f %st
;

FSUBR.reg80.reg80 dest, src
    *f80* val := src -f dest
;


# FSUBRP
FSUBRP.reg80 val
    *f80* val := val -f %st
    FPOP
;


# FUCOM
FUCOM
    *f80* tmpD := %st -f %st1
    SETFFLAGS(%st, %st1)
;

FUCOM.reg80 val
    *f80* tmpD := %st -f val
    SETFFLAGS(%st, val)
;


# FUCOMP
FUCOMP
    *f80* tmpD1 := %st
    *f80* tmpD2 := %st1
    *f80* tmpD  := %st -f %st1
    FPOP
    SETFFLAGS(tmpD1, tmpD2)
;

FUCOMP.reg80 val
    *f80* tmpD1 := %st
    *f80* tmpD2 := val
    *f80* tmpD  := %st -f val
    FPOP
    SETFFLAGS(tmpD1, tmpD2)
;


# FUCOMPP
FUCOMPP
    *f80* tmpD1 := %st
    *f80* tmpD2 := %st1
    *f80* tmpD  := %st -f %st1
    FPOP
    FPOP
    SETFFLAGS(tmpD1, tmpD2)
;


# FXCH
FXCH.reg80 i
    *f80* tmpD := %st
    *f80* %st := i
    *f80* i := tmpD
;


# IDIV
IDIV.reg32 divisor
    *64* tmp1 := (%edx << 32) | %eax
    *32* %eax := tmp1 /! tmp2
    *32* %edx := tmp1 %! tmp2
    undefineflags()
;

IDIV.rm8 divisor
    *16* tmph := %ax
    *8* %al := tmph /! divisor{8}
    *8* %ah := tmph %! divisor{8}
    undefineflags()
;

IDIV.rm16 divisor
    *32* tmpd := (%dx << 16) | %ax
    *16* %ax := tmpd /! divisor{16}
    *16* %dx := tmpd %! divisor{16}
    undefineflags()
;

IDIV.rm32 divisor
    *64* tmp1 := (%edx << 32) | %eax
    *32* %eax := tmp1 /! tmp2
    *32* %edx := tmp1 %! tmp2
    undefineflags()
;


# IMUL
IMUL.reg16.reg16 dest, src
    *16* dest := dest *! src
    IMULTFLAGS16(dest)
;

IMUL.reg16.reg16.imm16 dest, src1, src2
    *16* dest := src1 *! src2
    IMULTFLAGS16(dest)
;

IMUL.reg16.rm16 dest, src
    *16* dest := dest *! src
    IMULTFLAGS16(dest)
;

IMUL.reg16.rm16.imm8 dest, src1, src2
    *16* dest := src1 *! sgnex(8, 16, src2)
    IMULTFLAGS16(dest)
;

IMUL.reg16.rm16.imm16 dest, src1, src2
    *16* dest := src1 *! src2
    IMULTFLAGS16(dest)
;

IMUL.reg32 val
    *64* tmpresult := %eax *! val
    *32* %edx := truncu(64, 32, tmpresult) >> 32
    *32* %eax := truncu(64, 32, tmpresult)
    IMULTFLAGS32(tmpresult)
;

IMUL.reg32.reg32 dest, src
    *32* dest := dest *! src
    IMULTFLAGS32(dest)
;

IMUL.reg32.reg32.imm32 dest, src1, src2
    *32* dest := src1 *! src2
    IMULTFLAGS32(dest)
;

IMUL.reg32.rm32 dest, src
    *32* dest := dest *! src
    IMULTFLAGS32(dest)
;

IMUL.reg32.rm32.imm8 dest, src1, src2
    *32* dest := src1 *! sgnex(8, 32, src2)
    IMULTFLAGS32(dest)
;

IMUL.reg32.rm32.imm32 dest, src1, src2
    *32* dest := src1 *! src2
    IMULTFLAGS32(dest)
;

IMUL.rm8 val
    *16* tmpresult := %al *! val
    *16* %ax := tmpresult
    IMULTFLAGS8(tmpresult)
;

IMUL.rm16 val
    *32* tmpresult := %ax *! val
    *16* %dx := truncu(32, 16, tmpresult) >> 16
    *16* %ax := truncu(32, 16, tmpresult)
    IMULTFLAGS16(tmpresult)
;

IMUL.rm32 val
    *64* tmpresult := %eax *! val
    *32* %edx := truncu(64, 32, tmpresult) >> 32
    *32* %eax := truncu(64, 32, tmpresult)
    IMULTFLAGS32(tmpresult)
;


# INC
INC.reg8 val
    *8* tmpb := val
    *8* val := val + 1
    LOGICALFLAGS8(val)
;

INC.reg16 val
    *16* tmph := val
    *16* val := val + 1
    LOGICALFLAGS16(val)
;

INC.reg32 val
    *32* tmp1 := val
    *32* val := val + 1
    LOGICALFLAGS32(val)
;

INC.rm8 val
    *8* tmpb := val
    *8* val := val + 1
    LOGICALFLAGS8(val)
;

INC.rm16 val
    *16* tmph := val
    *16* val := val + 1
    LOGICALFLAGS16(val)
;

INC.rm32 val
    *32* tmp1 := val
    *32* val := val + 1
    LOGICALFLAGS32(val)
;

INC.rm64 val
    *64* tmp1 := val
    *64* val := val + 1
    LOGICALFLAGS64(val)
;


# INT
INT.imm32 n
    _
;


# INT1
INT1
    _
;


# INT3
INT3
    _
;

# INTO
INTO
    _
;


# Jcc
JA.imm32 dest       *32* ~%CF & ~%ZF            => %pc := dest;
JAE.imm32 dest      *32* %CF = 0                => %pc := dest;
JB.imm32 dest       *32* %CF = 1                => %pc := dest;
JBE.imm32 dest      *32* %CF | %ZF              => %pc := dest;
JC.imm32 dest       *32* %CF = 1                => %pc := dest;
JCXZ.imm32 dest     *32* %cx = 0                => %pc := dest;
JE.imm32 dest       *32* %ZF = 0                => %pc := dest;
JECXZ.imm32 dest    *32* %ecx = 0               => %pc := dest;
JG.imm32 dest       *32* ~%ZF & ~(%SF ^ %OF)    => %pc := dest;
JGE.imm32 dest      *32* ~(%SF ^ %OF)           => %pc := dest;
JL.imm32 dest       *32* %SF ^ %OF              => %pc := dest;
JLE.imm32 dest      *32* %ZF | (%SF ^ %OF)      => %pc := dest;
JMP.imm32 dest      *32*                           %pc := dest;
JMP.reg32 dest      *32*                           %pc := dest;
JMP.rm32 dest       *32*                           %pc := dest;
JNA.imm32 dest      *32* %CF | %ZF              => %pc := dest;
JNAE.imm32 dest     *32* %CF                    => %pc := dest;
JNB.imm32 dest      *32* ~%CF                   => %pc := dest;
JNBE.imm32 dest     *32* (~%CF & ~%ZF)          => %pc := dest;
JNC.imm32 dest      *32* ~%CF                   => %pc := dest;
JNE.imm32 dest      *32* ~%ZF                   => %pc := dest;
JNG.imm32 dest      *32* %ZF | (%SF ^ %OF)      => %pc := dest;
JNGE.imm32 dest     *32* ~%ZF & ~(%SF ^ %OF)    => %pc := dest;
JNL.imm32 dest      *32* ~(%SF ^ %OF)           => %pc := dest;
JNLE.imm32 dest     *32* ~%ZF & ~(%SF ^ %OF)    => %pc := dest;
JNO.imm32 dest      *32* ~%OF                   => %pc := dest;
JNP.imm32 dest      *32* ~%PF                   => %pc := dest;
JNS.imm32 dest      *32* ~%SF                   => %pc := dest;
JNZ.imm32 dest      *32* ~%ZF                   => %pc := dest;
JO.imm32 dest       *32* %OF                    => %pc := dest;
JP.imm32 dest       *32* %PF                    => %pc := dest;
JS.imm32 dest       *32* %SF                    => %pc := dest;
JZ.imm32 dest       *32* %ZF                    => %pc := dest;


# LAHF
LAHF
    *8* %ah := (%SF << 7) | (%ZF << 6) | (0 << 5) | (%AF << 4) | (0 << 3) | (%PF << 2) | (1 << 1) | (%CF << 0)
;


# LEA
LEA.reg16.rm16 dest, src
    *32* tmpaddr := addr(dest)
    *16* dest := truncu(32, 16, tmpaddr)
;

LEA.reg32.rm32 dest, src
    *32* dest := addr(src)
;

LEA.reg64.rm64 dest, src
    *64* dest := addr(src)
;


# LEAVE
LEAVE
    *32* %esp := %ebp
    *32* %ebp := m[%esp]
    *32* %esp := %esp + 4
;


# LOOP
LOOP.imm32 dest
    *32* %ecx := %ecx - 1
    *32* %ecx ~= 0 => %pc := dest
;


# MOV
MOV.reg8.imm8 dest, src
    *8* dest := src
;

MOV.reg8.reg8 dest, src
    *8* dest := src
;

MOV.reg8.rm8 dest, src
    *8* dest := src
;

MOV.reg16.imm16 dest, src
    *16* dest := src
;

MOV.reg16.reg16 dest, src
    *16* dest := src
;

MOV.reg16.rm16 dest, src
    *16* dest := src
;

MOV.reg32.imm32 dest, src
    *32* dest := src
;

MOV.reg32.reg32 dest, src
    *32* dest := src
;

MOV.reg32.rm32 dest, src
    *32* dest := src
;

MOV.reg64.imm64 dest, src
    *64* dest := src
;

MOV.reg64.reg64 dest, src
    *64* dest := src
;

MOV.reg64.rm64 dest, src
    *64* dest := src
;

MOV.rm8.imm8 dest, src
    *8* dest := src
;

MOV.rm8.reg8 dest, src
    *8* dest := src
;

MOV.rm16.imm16 dest, src
    *16* dest := src
;

MOV.rm16.reg16 dest, src
    *16* dest := src
;

MOV.rm32.imm32 dest, src
    *32* dest := src
;

MOV.rm32.reg32 dest, src
    *32* dest := src
;

MOV.rm64.imm32 dest, src
    *64* dest := sgnex(32, 64, src)
;

MOV.rm64.reg64 dest, src
    *64* dest := src
;


# MOVSX
MOVSX.reg16.reg8 dest, src
    *16* dest := sgnex(8, 16, src)
;

MOVSX.reg16.rm8 dest, src
    *16* dest := sgnex(8, 16, src)
;

MOVSX.reg32.reg8 dest, src
    *32* dest := sgnex(8, 32, src)
;

MOVSX.reg32.reg16 dest, src
    *32* dest := sgnex(16, 32, src)
;

MOVSX.reg32.rm8 dest, src
    *32* dest := sgnex(8, 32, src)
;

MOVSX.reg32.rm16 dest, src
    *32* dest := sgnex(16, 32, src)
;

MOVSX.reg64.rm8 dest, src
    *64* dest := sgnex(8, 64, src)
;

MOVSX.reg64.rm16 dest, src
    *64* dest := sgnex(16, 64, src)
;


# MOVSXD
MOVSXD.reg16.rm16 dest, src
    *16* dest := sgnex(16, 16, src)
;

MOVSXD.reg32.rm32 dest, src
    *32* dest := sgnex(32, 32, src)
;

MOVSXD.reg64.rm32 dest, src
    *64* dest := sgnex(32, 64, src)
;


# MOVZX
MOVZX.reg16.reg8 dest, src
    *16* dest := zfill(8, 16, src)
;

MOVZX.reg16.rm8 dest, src
    *16* dest := zfill(8, 16, src)
;

MOVZX.reg32.reg8 dest, src
    *32* dest := zfill(8, 32, src)
;

MOVZX.reg32.reg16 dest, src
    *32* dest := zfill(16, 32, src)
;

MOVZX.reg32.rm8 dest, src
    *32* dest := zfill(8, 32, src)
;

MOVZX.reg32.rm16 dest, src
    *32* dest := zfill(16, 32, src)
;

MOVZX.reg64.rm8 dest, src
    *64* dest := zfill(8, 64, src)
;

MOVZX.reg64.rm16 dest, src
    *64* dest := zfill(16, 64, src)
;


# MUL
MUL.reg8 src
    *16* tmp2 := %al * src{8}
    *16* %ax := tmp2
    MULTFLAGS8(tmp2)
;

MUL.reg16 src
    *32* tmp2 := %eax * src{16}
    *16* %ax := tmp2
    *16* %dx := tmp2 >> 16
    MULTFLAGS16(tmp2)
;

MUL.reg32 src
    *32* tmp1 := src{32}
    *64* tmpl := zfill(32, 64, %eax) * zfill(32, 64, tmp1)
    *32* %eax := tmpl
    *32* %edx := tmpl >> 32
    MULTFLAGS32(tmpl)
;

MUL.rm8 src
    *16* tmp2 := %al * src{8}
    *16* %ax := tmp2
    MULTFLAGS8(tmp2)
;

MUL.rm32 src
    *32* tmp1 := src{32}
    *64* tmpl := zfill(32, 64, %eax) * zfill(32, 64, tmp1)
    *32* %eax := tmpl
    *32* %edx := tmpl >> 32
    MULTFLAGS32(tmpl)
;


# NEG
NEG.reg8 val
    *8* tmpval := val
    *8* val := 0 - val
    SUBFLAGS8(0, tmpval, val)
;

NEG.reg16 val
    *16* tmpval := val
    *16* val := 0 - val
    SUBFLAGS16(0, tmpval, val)
;

NEG.reg32 val
    *32* tmpval := val
    *32* val := 0 - val
    SUBFLAGS32(0, tmpval, val)
;

NEG.reg64 val
    *64* tmpval := val
    *64* val := 0 - val
    SUBFLAGS64(0, tmpval, val)
;

NEG.rm32 val
    *32* tmpval := val
    *32* val := 0 - val
    SUBFLAGS32(0, tmpval, val)
;


# NOP
NOP
    _
;


# NOT
NOT.reg8 reg
    *8* reg := ~reg{8}
;

NOT.reg16 reg
    *16* reg := ~reg{16}
;

NOT.reg32 reg
    *32* reg := ~reg{32}
;

NOT.reg64 reg
    *64* reg := ~reg{64}
;

NOT.rm16 dest
    *16* dest := ~dest{32}
;

NOT.rm32 dest
    *32* dest := ~dest{32}
;


# OR
OR.reg8.imm8 dest, src
    *8* dest := dest | src
    LOGICALFLAGS8(dest)
;

OR.reg8.reg8 dest, src
    *8* dest := dest | src
    LOGICALFLAGS8(dest)
;

OR.reg8.rm8 dest, src
    *8* dest := dest | src
    LOGICALFLAGS8(dest)
;

OR.reg16.imm16 dest, src
    *16* dest := dest | src
    LOGICALFLAGS16(dest)
;

OR.reg16.reg16 dest, src
    *16* dest := dest | src
    LOGICALFLAGS16(dest)
;

OR.reg16.rm16 dest, src
    *16* dest := dest | src
    LOGICALFLAGS16(dest)
;

OR.reg32.imm32 dest, src
    *32* dest := dest | src
    LOGICALFLAGS32(dest)
;

OR.reg32.reg32 dest, src
    *32* dest := dest | src
    LOGICALFLAGS32(dest)
;

OR.reg32.rm32 dest, src
    *32* dest := dest | src
    LOGICALFLAGS32(dest)
;

OR.reg64.imm32 dest, src
    *64* dest := dest | sgnex(32, 64, src)
    LOGICALFLAGS64(dest)
;

OR.rm8.imm8 dest, src
    *8* dest := dest | src
    LOGICALFLAGS8(dest)
;

OR.rm8.reg8 dest, src
    *8* dest := dest | src
    LOGICALFLAGS8(dest)
;

OR.rm16.imm8 dest, src
    *16* dest := dest | sgnex(8, 16, src)
    LOGICALFLAGS16(dest)
;

OR.rm16.imm16 dest, src
    *16* dest := dest | src
    LOGICALFLAGS16(dest)
;

OR.rm16.reg16 dest, src
    *16* dest := dest | src
    LOGICALFLAGS16(dest)
;

OR.rm32.imm8 dest, src
    *32* dest := dest | sgnex(8, 32, src)
    LOGICALFLAGS32(dest)
;

OR.rm32.imm32 dest, src
    *32* dest := dest | src
    LOGICALFLAGS32(dest)
;

OR.rm32.reg32 dest, src
    *32* dest := dest | src
    LOGICALFLAGS32(dest)
;

OR.rm64.imm8 dest, src
    *64* dest := dest | sgnex(8, 64, src)
    LOGICALFLAGS64(dest)
;

OR.rm64.reg64 dest, src
    *64* dest := dest | src
    LOGICALFLAGS64(dest)
;


# PAUSE
PAUSE
    _
;


# POP
POP.reg16 reg
    *16* reg := m[%esp]{16}
    *16* %esp := %esp + 2
;

POP.reg32 reg
    *32* reg := m[%esp]{32}
    *32* %esp := %esp + 4
;

POP.rm16 rm
    *16* rm := m[%esp]{16}
    *16* %esp := %esp + 2
;

POP.rm32 rm
    *32* rm := m[%esp]{32}
    *32* %esp := %esp + 4
;


# POPA
POPA
    *16* %ax := m[%sp + 14]
    *16* %cx := m[%sp + 12]
    *16* %dx := m[%sp + 10]
    *16* %bx := m[%sp +  8]
    # throw away sp
    *16* %bp := m[%sp +  4]
    *16* %si := m[%sp +  2]
    *16* %di := m[%sp +  0]
    *16* %sp := %sp + 16
;


# POPAL
POPAL
    *32* %eax := m[%esp + 28]
    *32* %ecx := m[%esp + 24]
    *32* %edx := m[%esp + 20]
    *32* %ebx := m[%esp + 16]
    # throw away esp
    *32* %ebp := m[%esp +  8]
    *32* %esi := m[%esp +  4]
    *32* %edi := m[%esp +  0]
    *32* %esp := %esp + 32
;


# POPFD
POPFD
    *32* %eflags := m[%esp + 0]
    *32* %esp := %esp + 4
;


# PUSH
PUSH.imm8 val
    *32* m[%esp - 4] := sgnex(8, 32, val)
    *32* %esp := %esp - 4
;

PUSH.imm16 val
    *32* m[%esp - 4] := sgnex(16, 32, val)
    *32* %esp := %esp - 4
;

PUSH.imm32 val
    *32* m[%esp - 4] := val
    *32* %esp := %esp - 4
;

PUSH.reg16 reg
    *16* m[%esp - 2] := reg
    *32* %esp := %esp - 2
;

PUSH.reg32 reg
    *32* m[%esp - 4] := reg
    *32* %esp := %esp - 4
;

PUSH.rm16 rm
    *16* m[%esp - 2] := rm
    *32* %esp := %esp - 2
;

PUSH.rm32 rm
    *32* m[%esp - 4] := rm
    *32* %esp := %esp - 4
;


# PUSHA
PUSHA
    *16* m[%sp -  2] := %ax
    *16* m[%sp -  4] := %cx
    *16* m[%sp -  6] := %dx
    *16* m[%sp -  8] := %bx
    *16* m[%sp - 10] := %sp
    *16* m[%sp - 12] := %bp
    *16* m[%sp - 14] := %si
    *16* m[%sp - 16] := %di
    *16* %sp := %sp - 16
;


# PUSHAL
PUSHAL
    *32* m[%sp -  4] := %eax
    *32* m[%sp -  8] := %ecx
    *32* m[%sp - 12] := %edx
    *32* m[%sp - 16] := %ebx
    *16* m[%sp - 20] := %esp
    *16* m[%sp - 24] := %ebp
    *16* m[%sp - 28] := %esi
    *16* m[%sp - 32] := %edi
    *16* %esp := %esp - 32
;


# PUSHF
PUSHF
    *16* m[%esp - 2] := %flags
    *32* %esp := %esp - 2
;


# PUSHFD
PUSHFD
    *32* m[%esp - 4] := %eflags
    *32* %esp := %esp - 4
;


# RET
RET
    *32* %pc := m[%esp]
    *32* %esp := %esp + 4
;

RET.imm16 offset
    *32* %pc := m[%esp + offset]{32}
    *32* %esp := %esp + 4 + offset
;

RET.imm32 offset
    *32* %pc := m[%esp + offset]{32}
    *32* %esp := %esp + 4 + offset
;

RETF
    *32* %pc := m[%esp]
    *32* %esp := %esp + 4
;


# ROL
ROL.reg32.imm32 dest, src
    *32* tmp1 := dest
    *32* dest := dest rl src
    ROLFLAGS32(dest, tmp1, src)
;


# ROR
ROR.reg8.imm8 dest, src
    *8* tmp1 := dest
    *8* dest := dest rr src
    RORFLAGS8(dest, tmp1, src)
;

ROR.reg32.imm32 dest, src
    *32* tmp1 := dest
    *32* dest := dest rr src
    RORFLAGS32(dest, tmp1, src)
;


# SAHF
SAHF
    *1* %SF := %ah@[7:7]
    *1* %ZF := %ah@[6:6]
    *1* %AF := %ah@[4:4]
    *1* %PF := %ah@[2:2]
    *1* %CF := %ah@[0:0]
;


# SAR
SAR.reg8.imm8 dest, src
    *8* tmpb := dest
    *8* dest := dest >>A src
    SARFLAGS(dest, tmpb, src)
;

SAR.reg16.imm16 dest, src
    *16* tmph := dest
    *16* dest := dest >>A src
    SARFLAGS(dest, tmph, src)
;

SAR.reg16.reg8 dest, src
    *16* tmph := dest
    *16* dest := dest >>A src
    SARFLAGS(dest, tmph, src)
;

SAR.reg32.imm32 dest, src
    *32* tmp1 := dest
    *32* dest := dest >>A src
    SARFLAGS(dest, tmp1, src)
;

SAR.rm8.imm8 dest, src
    *8* tmpb := dest
    *8* dest := dest >>A src
    SARFLAGS(dest, tmpb, src)
;

SAR.rm8.reg8 dest, src
    *8* tmpb := dest
    *8* dest := dest >>A src
    SARFLAGS(dest, tmpb, src)
;

SAR.rm16.imm8 dest, src
    *16* tmph := dest
    *16* dest := dest >>A src
    SARFLAGS(dest, tmph, src)
;

SAR.rm16.imm16 dest, src
    *16* tmph := dest
    *16* dest := dest >>A src
    SARFLAGS(dest, tmph, src)
;

SAR.rm16.reg8 dest, src
    *16* tmph := dest
    *16* dest := dest >>A src
    SARFLAGS(dest, tmph, src)
;

SAR.rm32.imm8 dest, src
    *32* tmp1 := dest
    *32* dest := dest >>A src
    SARFLAGS(dest, tmp1, src)
;

SAR.rm64.imm8 dest, src
    *64* tmp1 := dest
    *64* dest := dest >>A src
    SARFLAGS(dest, tmp1, src)
;


# SBB
SBB.reg8.imm8 dest, src
    *8* tmpb := dest
    *8* dest := dest - src - %CF
    SUBFLAGS8(tmpb, src, dest)
;

SBB.reg8.reg8 dest, src
    *8* tmpb := dest
    *8* dest := dest - src - %CF
    SUBFLAGS8(tmpb, src, dest)
;

SBB.reg8.rm8 dest, src
    *8* tmpb := dest
    *8* dest := dest - src - %CF
    SUBFLAGS8(tmpb, src, dest)
;

SBB.reg16.imm16 dest, src
    *16* tmph := dest
    *16* dest := dest - src - %CF
    SUBFLAGS16(tmph, src, dest)
;

SBB.reg16.reg16 dest, src
    *16* tmph := dest
    *16* dest := dest - src - %CF
    SUBFLAGS16(tmph, src, dest)
;

SBB.reg16.rm16 dest, src
    *16* tmph := dest
    *16* dest := dest - src - %CF
    SUBFLAGS16(tmph, src, dest)
;

SBB.reg32.imm32 dest, src
    *32* tmp1 := dest
    *32* dest := dest - src - %CF
    SUBFLAGS32(tmp1, src, dest)
;

SBB.reg32.reg32 dest, src
    *32* tmp1 := dest
    *32* dest := dest - src - %CF
    SUBFLAGS32(tmp1, src, dest)
;

SBB.reg32.rm32 dest, src
    *32* tmp1 := dest
    *32* dest := dest - src - %CF
    SUBFLAGS32(tmp1, src, dest)
;

SBB.reg64.rm64 dest, src
    *64* tmp1 := dest
    *64* dest := dest - src - %CF
    SUBFLAGS64(tmp1, src, dest)
;

SBB.rm8.imm8 dest, src
    *8* tmpb := dest
    *8* dest := dest - src - %CF
    SUBFLAGS8(tmpb, src, dest)
;

SBB.rm8.reg8 dest, src
    *8* tmpb := dest
    *8* dest := dest - src - %CF
    SUBFLAGS8(tmpb, src, dest)
;

SBB.rm16.imm8 dest, src
    *16* tmph := dest
    *16* dest := dest - sgnex(8, 16, src) - %CF
    SUBFLAGS16(tmph, src, dest)
;

SBB.rm16.imm16 dest, src
    *16* tmph := dest
    *16* dest := dest - src - %CF
    SUBFLAGS16(tmph, src, dest)
;

SBB.rm16.reg16 dest, src
    *16* tmph := dest
    *16* dest := dest - src - %CF
    SUBFLAGS16(tmph, src, dest)
;

SBB.rm32.imm8 dest, src
    *32* tmp1 := dest
    *32* dest := dest - sgnex(8, 32, src) - %CF
    SUBFLAGS32(tmp1, src, dest)
;

SBB.rm32.imm32 dest, src
    *32* tmp1 := dest
    *32* dest := dest - src - %CF
    SUBFLAGS32(tmp1, src, dest)
;

SBB.rm32.reg32 dest, src
    *32* tmp1 := dest
    *32* dest := dest - src - %CF
    SUBFLAGS32(tmp1, src, dest)
;

SBB.rm64.imm8 dest, src
    *64* tmp1 := dest
    *32* dest := dest - sgnex(8, 64, src) - %CF
    SUBFLAGS64(tmp1, src, dest)
;

SBB.rm64.imm32 dest, src
    *64* tmp1 := dest
    *64* dest := dest - sgnex(32, 64, src) - %CF
    SUBFLAGS64(tmp1, src, dest)
;

SBB.rm64.reg64 dest, src
    *64* tmp1 := dest
    *64* dest := dest - src - %CF
    SUBFLAGS64(tmp1, src, dest)
;


# SETcc
SETA.reg8  dest         *8* dest := ~%CF & ~%ZF;
SETA.rm8   dest         *8* dest := ~%CF & ~%ZF;
SETAE.reg8 dest         *8* dest := ~%CF;
SETAE.rm8  dest         *8* dest := ~%CF;
SETB.reg8  dest         *8* dest := %CF;
SETB.rm8   dest         *8* dest := %CF;
SETBE.reg8 dest         *8* dest := %CF | %ZF;
SETBE.rm8  dest         *8* dest := %CF | %ZF;
SETE.reg8  dest         *8* dest := %ZF;
SETE.rm8   dest         *8* dest := %ZF;
SETG.reg8  dest         *8* dest := ~%ZF & ~(%SF ^ %OF);
SETG.rm8   dest         *8* dest := ~%ZF & ~(%SF ^ %OF);
SETGE.reg8 dest         *8* dest := ~(%SF ^ %OF);
SETGE.rm8  dest         *8* dest := ~(%SF ^ %OF);
SETL.reg8  dest         *8* dest := %SF ^ %OF;
SETL.rm8   dest         *8* dest := %SF ^ %OF;
SETLE.reg8 dest         *8* dest := %ZF | (%SF ^ %OF);
SETLE.rm8  dest         *8* dest := %ZF | (%SF ^ %OF);
SETNE.reg8 dest         *8* dest := ~%ZF;
SETNE.rm8  dest         *8* dest := ~%ZF;
SETNO.reg8 dest         *8* dest := ~%OF;
SETNO.rm8  dest         *8* dest := ~%OF;
SETNS.reg8 dest         *8* dest := ~%SF;
SETNS.rm8  dest         *8* dest := ~%SF;
SETNP.reg8 dest         *8* dest := ~%PF;
SETNP.rm8  dest         *8* dest := ~%PF;
SETP.reg8  dest         *8* dest := %PF;
SETP.rm8   dest         *8* dest := %PF;
SETS.reg8  dest         *8* dest := %SF;
SETS.rm8   dest         *8* dest := %SF;
SETO.reg8  dest         *8* dest := %OF;
SETO.rm8   dest         *8* dest := %OF;


# SHL
SHL.reg8.imm8 dest, src
    *8* tmpb := dest
    *8* dest := dest << src
    SALFLAGS8(dest, tmpb, src)
;

SHL.reg8.reg8 dest, src
    *8* tmpb := dest
    *8* dest := dest << src
    SALFLAGS8(dest, tmpb, src)
;

SHL.reg16.imm16 dest, src
    *16* tmph := dest
    *16* dest := dest << src
    SALFLAGS16(dest, tmpb, src)
;

SHL.reg16.reg8 dest, src
    *16* tmph := dest
    *16* dest := dest << src
    SALFLAGS16(dest, tmph, src)
;

SHL.reg32.imm32 dest, src
    *32* tmp1 := dest
    *32* dest := dest << src
    SALFLAGS32(dest, tmp1, src)
;

SHL.reg32.reg8 dest, src
    *32* tmp1 := dest
    *32* dest := dest << src
    SALFLAGS32(dest, tmp1, src)
;

SHL.rm8.imm8 dest, src
    *8* tmpb := dest
    *8* dest := dest << src
    SALFLAGS8(dest, tmpb, src)
;

SHL.rm8.reg8 dest, src
    *8* tmpb := dest
    *8* dest := dest << src
    SALFLAGS8(dest, tmpb, src)
;

SHL.rm16.imm16 dest, src
    *16* tmph := dest
    *16* dest := dest << src
    SALFLAGS16(dest, tmph, src)
;

SHL.rm32.reg8 dest, src
    *32* tmp1 := dest
    *32* dest := dest << src
    SALFLAGS32(dest, tmp1, src)
;

SHL.rm32.imm32 dest, src
    *32* tmp1 := dest
    *32* dest := dest << src
    SALFLAGS32(dest, tmp1, src)
;


# SHLD
SHLD.reg32.reg32.imm32 dest, src, count
    *64* tmp1 := dest{64} << 32 | src
    *32* dest := (tmp1 << count) >> 32
    SHLDFLAGS32(dest, tmp1, count)
;

SHLD.reg32.reg32.reg8 dest, src, count
    *64* tmp1 := dest{64} << 32 | src
    *32* dest := (tmp1 << count) >> 32
    SHLDFLAGS32(dest, tmp1, count)
;


# SHR
SHR.reg8.imm8 dest, src
    *8* tmpb := dest
    *8* dest := dest >> src
    SHRFLAGS8(dest, tmpb, src)
;

SHR.reg8.reg8 dest, src
    *8* tmpb := dest
    *8* dest := dest >> src
    SHRFLAGS8(dest, tmpb, src)
;

SHR.reg16.imm16 dest, src
    *8* tmph := dest
    *8* dest := dest >> src
    SHRFLAGS16(dest, tmph, src)
;

SHR.reg16.reg8 dest, src
    *8* tmph := dest
    *8* dest := dest >> src
    SHRFLAGS16(dest, tmph, src)
;

SHR.reg32.imm32 dest, src
    *32* tmp1 := dest
    *32* dest := dest >> src
    SHRFLAGS32(dest, tmp1, src)
;

SHR.reg32.reg8 dest, src
    *32* tmp1 := dest
    *32* dest := dest >> src
    SHRFLAGS32(dest, tmp1, src)
;

SHR.rm8.imm8 dest, src
    *8* tmpb := dest
    *8* dest := dest >> src
    SHRFLAGS8(dest, tmpb, src)
;

SHR.rm8.reg8 dest, src
    *8* tmpb := dest
    *8* dest := dest >> src
    SHRFLAGS8(dest, tmpb, src)
;

SHR.rm16.imm16 dest, src
    *8* tmph := dest
    *8* dest := dest >> src
    SHRFLAGS16(dest, tmph, src)
;

SHR.rm32.reg8 dest, src
    *32* tmp1 := dest
    *32* dest := dest >> src
    SHRFLAGS32(dest, tmp1, src)
;

SHR.rm32.imm32 dest, src
    *32* tmp1 := dest
    *32* dest := dest >> src
    SHRFLAGS32(dest, tmp1, src)
;




# SHRD
SHRD.reg32.reg32.imm32 dest, src, count
    *64* tmp1 := (src{64} << 32) | dest
    *32* dest := tmp1 >> count
    SHRDFLAGS32(dest, tmp1, count)
;

SHRD.reg32.reg32.reg8 dest, src, count
    *64* tmp1 := (src{64} << 32) | dest
    *32* dest := tmp1 >> count
    SHRDFLAGS32(dest, tmp1, count)
;


# STC
STC
    *1* %CF := 1
;


# STD
STD
    *1* %DF := 1
;


# SUB
SUB.reg8.imm8 dest, src
    *8* tmp1 := dest
    *8* dest := dest - src
    SUBFLAGS8(tmp1, src, dest)
;

SUB.reg8.reg8 dest, src
    *8* tmp1 := dest
    *8* dest := dest - src
    SUBFLAGS8(tmp1, src, dest)
;

SUB.reg8.rm8 dest, src
    *8* tmp1 := dest
    *8* dest := dest - src
    SUBFLAGS8(tmp1, src, dest)
;

SUB.reg16.imm16 dest, src
    *16* tmp1 := dest
    *16* dest := dest - src
    SUBFLAGS16(tmp1, src, dest)
;

SUB.reg16.reg16 dest, src
    *16* tmp1 := dest
    *16* dest := dest - src
    SUBFLAGS16(tmp1, src, dest)
;

SUB.reg16.rm16 dest, src
    *16* tmp1 := dest
    *16* dest := dest - src
    SUBFLAGS16(tmp1, src, dest)
;

SUB.reg32.imm32 dest, src
    *32* tmp1 := dest
    *32* dest := dest - src
    SUBFLAGS32(tmp1, src, dest)
;

SUB.reg32.reg32 dest, src
    *32* tmp1 := dest
    *32* dest := dest - src
    SUBFLAGS32(tmp1, src, dest)
;

SUB.reg32.rm32 dest, src
    *32* tmp1 := dest
    *32* dest := dest - src
    SUBFLAGS32(tmp1, src, dest)
;

SUB.rm8.imm8 dest, src
    *8* tmp1 := dest
    *8* dest := dest - src
    SUBFLAGS8(tmp1, src, dest)
;

SUB.rm8.reg8 dest, src
    *8* tmp1 := dest
    *8* dest := dest - src
    SUBFLAGS8(tmp1, src, dest)
;

SUB.rm16.imm16 dest, src
    *16* tmp1 := dest
    *16* dest := dest - src
    SUBFLAGS16(tmp1, src, dest)
;

SUB.rm16.reg16 dest, src
    *16* tmp1 := dest
    *16* dest := dest - src
    SUBFLAGS16(tmp1, src, dest)
;

SUB.rm32.imm32 dest, src
    *32* tmp1 := dest
    *32* dest := dest - src
    SUBFLAGS32(tmp1, src, dest)
;

SUB.rm32.reg32 dest, src
    *32* tmp1 := dest
    *32* dest := dest - src
    SUBFLAGS32(tmp1, src, dest)
;


# TEST
TEST.reg8.imm8 lhs, rhs
    *8* tmpb := lhs & rhs
    LOGICALFLAGS8(tmpb)
;

TEST.reg8.reg8 lhs, rhs
    *8* tmpb := lhs & rhs
    LOGICALFLAGS8(tmpb)
;

TEST.reg16.imm16 lhs, rhs
    *16* tmph := lhs & rhs
    LOGICALFLAGS16(tmph)
;

TEST.reg16.reg16 lhs, rhs
    *16* tmph := lhs & rhs
    LOGICALFLAGS16(tmph)
;

TEST.reg32.imm32 lhs, rhs
    *32* tmp1 := lhs & rhs
    LOGICALFLAGS32(tmp1)
;

TEST.reg32.reg32 lhs, rhs
    *32* tmp1 := lhs & rhs
    LOGICALFLAGS32(tmp1)
;

TEST.rm8.imm8 lhs, rhs
    *8* tmpb := lhs & rhs
    LOGICALFLAGS8(tmpb)
;

TEST.rm8.reg8 lhs, rhs
    *8* tmpb := lhs & rhs
    LOGICALFLAGS8(tmpb)
;

TEST.rm16.imm16 lhs, rhs
    *16* tmph := lhs & rhs
    LOGICALFLAGS16(tmph)
;

TEST.rm16.reg16 lhs, rhs
    *16* tmph := lhs & rhs
    LOGICALFLAGS16(tmph)
;

TEST.rm32.imm32 lhs, rhs
    *32* tmp1 := lhs & rhs
    LOGICALFLAGS32(tmp1)
;

TEST.rm32.reg32 lhs, rhs
    *32* tmp1 := lhs & rhs
    LOGICALFLAGS32(tmp1)
;


# UD2
UD2
    _
;


# WAIT
WAIT
    _
;


# XCHG
XCHG.reg8.reg8 reg1, reg2
    *8* tmpreg := reg1
    *8* reg1 := reg2
    *8* reg2 := tmpreg
;

XCHG.reg16.reg16 reg1, reg2
    *16* tmpreg := reg1
    *16* reg1 := reg2
    *16* reg2 := tmpreg
;

XCHG.reg32.reg32 reg1, reg2
    *32* tmpreg := reg1
    *32* reg1 := reg2
    *32* reg2 := tmpreg
;

XCHG.rm8.reg8 reg1, reg2
    *8* tmpreg := reg1
    *8* reg1 := reg2
    *8* reg2 := tmpreg
;

XCHG.rm16.reg16 reg1, reg2
    *16* tmpreg := reg1
    *16* reg1 := reg2
    *16* reg2 := tmpreg
;

XCHG.rm32.reg32 reg1, reg2
    *32* tmpreg := reg1
    *32* reg1 := reg2
    *32* reg2 := tmpreg
;


# XOR
XOR.reg8.imm8 dest, src
    *8* dest := dest ^ src
    LOGICALFLAGS8(dest)
;

XOR.reg8.reg8 dest, src
    *8* dest := (dest ^ src){8}
    LOGICALFLAGS8(dest)
;

XOR.reg8.rm8 dest, src
    *8* dest := (dest ^ src){8}
    LOGICALFLAGS8(dest)
;

XOR.reg16.imm16 dest, src
    *16* dest := dest ^ src
    LOGICALFLAGS16(dest)
;

XOR.reg16.reg16 dest, src
    *16* dest := dest ^ src
    LOGICALFLAGS16(dest)
;

XOR.reg16.rm16 dest, src
    *16* dest := dest ^ src
    LOGICALFLAGS16(dest)
;

XOR.reg32.imm32 dest, src
    *32* dest := dest ^ src
    LOGICALFLAGS32(dest)
;

XOR.reg32.reg32 dest, src
    *32* dest := dest ^ src
    LOGICALFLAGS32(dest)
;

XOR.reg32.rm32 dest, src
    *32* dest := dest ^ src
    LOGICALFLAGS32(dest)
;

XOR.rm8.imm8 dest, src
    *8* dest := dest ^ src
    LOGICALFLAGS8(dest)
;

XOR.rm8.reg8 dest, src
    *8* dest := dest ^ src
    LOGICALFLAGS8(dest)
;

XOR.rm16.imm16 dest, src
    *16* dest := dest ^ src
    LOGICALFLAGS16(dest)
;

XOR.rm16.reg16 dest, src
    *16* dest := dest ^ src
    LOGICALFLAGS16(dest)
;

XOR.rm32.imm32 dest, src
    *32* dest := dest ^ src
    LOGICALFLAGS32(dest)
;

XOR.rm32.reg32 dest, src
    *32* dest := dest ^ src
    LOGICALFLAGS32(dest)
;

