#
# This file is part of the Boomerang Decompiler.
#
# See the file "LICENSE.TERMS" for information on usage and
# redistribution of this file, and for a DISCLAIMER OF ALL
# WARRANTIES.
#

# Description for instruction semantics of the x86 instruction set.

ENDIANNESS LITTLE;

# Constants defined in hexadecimal (modelling manual)
MAX8BITS  := 0xFF;
MAX16BITS := 0xFFFF;
MAX32BITS := 0xFFFFFFFF;
MAX64BITS := 0xFFFFFFFFFFFFFFFF;
MAX8POS   := 0x7F;
MAX8NEG   := 0x80;
MAX16POS  := 0x7FFF;
MAX16NEG  := 0x8000;
MAX32POS  := 0x7FFFFFFF;
MAX32NEG  := 0x80000000;

INTEGER %eax[32] -> 24;
INTEGER %ecx[32] -> 25;
INTEGER %edx[32] -> 26;
INTEGER %ebx[32] -> 27;
INTEGER %esp[32] -> 28;
INTEGER %ebp[32] -> 29;
INTEGER %esi[32] -> 30;
INTEGER %edi[32] -> 31;

INTEGER %ax[16] -> 0 SHARES %eax@[0..15];
INTEGER %cx[16] -> 1 SHARES %ecx@[0..15];
INTEGER %dx[16] -> 2 SHARES %edx@[0..15];
INTEGER %bx[16] -> 3 SHARES %ebx@[0..15];
INTEGER %sp[16] -> 4 SHARES %esp@[0..15];
INTEGER %bp[16] -> 5 SHARES %ebp@[0..15];
INTEGER %si[16] -> 6 SHARES %esi@[0..15];
INTEGER %di[16] -> 7 SHARES %edi@[0..15];

INTEGER %al[8]  -> 8  SHARES %ax@[0..7];
INTEGER %cl[8]  -> 9  SHARES %cx@[0..7];
INTEGER %dl[8]  -> 10 SHARES %dx@[0..7];
INTEGER %bl[8]  -> 11 SHARES %bx@[0..7];
INTEGER %ah[8]  -> 12 SHARES %ax@[8..15];
INTEGER %ch[8]  -> 13 SHARES %cx@[8..15];
INTEGER %dh[8]  -> 14 SHARES %dx@[8..15];
INTEGER %bh[8]  -> 15 SHARES %bx@[8..15];

INTEGER %ss[16] -> 16;
INTEGER %cs[16] -> 17;
INTEGER %ds[16] -> 18;
INTEGER %es[16] -> 19;
INTEGER %fs[16] -> 20;
INTEGER %gs[16] -> 21;

INTEGER %pc[32] -> -1;

# flags
FLAGS %eflags[32] -> 100;
FLAGS %flags[16]  -> 101 SHARES %eflags@[0..15];

FLAGS %CF[1]   -> -1 SHARES %flags@[0..0];
FLAGS %PF[1]   -> -1 SHARES %flags@[2..2];
FLAGS %AF[1]   -> -1 SHARES %flags@[4..4];
FLAGS %ZF[1]   -> -1 SHARES %flags@[6..6];
FLAGS %SF[1]   -> -1 SHARES %flags@[7..7]; # Negative sign flag
FLAGS %TF[1]   -> -1 SHARES %flags@[8..8];
FLAGS %IF[1]   -> -1 SHARES %flags@[9..9];
FLAGS %DF[1]   -> -1 SHARES %flags@[10..10];
FLAGS %OF[1]   -> -1 SHARES %flags@[11..11];
FLAGS %IOPL[2] -> -1 SHARES %flags@[12..13];
FLAGS %NT[1]   -> -1 SHARES %flags@[14..14];
# Bit 15 is reserved.
FLAGS %RF[1]   -> -1 SHARES %eflags@[16..16];
FLAGS %VM[1]   -> -1 SHARES %eflags@[17..17];
FLAGS %AC[1]   -> -1 SHARES %eflags@[18..18];
FLAGS %VIF[1]  -> -1 SHARES %eflags@[19..19];
FLAGS %VIP[1]  -> -1 SHARES %eflags@[20..20];
FLAGS %ID[1]   -> -1 SHARES %eflags@[21..21];

# FP related
FLOAT %st[80] -> 32;
FLOAT %st1[80] -> 33;
FLOAT %st2[80] -> 34;
FLOAT %st3[80] -> 35;
FLOAT %st4[80] -> 36;
FLOAT %st5[80] -> 37;
FLOAT %st6[80] -> 38;
FLOAT %st7[80] -> 39;

FLAGS %fcw[16] -> 50;
FLAGS %IM[1] -> 51 SHARES %fcw@[0..0];
FLAGS %DM[1] -> 52 SHARES %fcw@[1..1];
FLAGS %ZM[1] -> 53 SHARES %fcw@[2..2];
FLAGS %OM[1] -> 54 SHARES %fcw@[3..3];
FLAGS %UM[1] -> 55 SHARES %fcw@[4..4];
FLAGS %PM[1] -> 56 SHARES %fcw@[5..5];
FLAGS %FPC[2] -> 57 SHARES %fcw@[8..9];   # FP precision control
FLAGS %FRC[2] -> 58 SHARES %fcw@[10..11]; # FP rounding control
FLAGS %X[1] -> 59 SHARES %fcw@[12..12];   # FP infty control

FLAGS %fsw[16] -> 60;
FLAGS %IE[1] -> 61 SHARES %fsw@[0..0];    # Invalid Operand
FLAGS %DE[1] -> 62 SHARES %fsw@[1..1];    # Denormal operand
FLAGS %ZE[1] -> 63 SHARES %fsw@[2..2];    # Div by zero
FLAGS %OE[1] -> 64 SHARES %fsw@[3..3];    # Overflow
FLAGS %UE[1] -> 65 SHARES %fsw@[4..4];    # Underflow
FLAGS %PE[1] -> 66 SHARES %fsw@[5..5];    # Precision
FLAGS %FSF[1] -> 67 SHARES %fsw@[6..6];   # FP stack fault
FLAGS %ES[1] -> 68 SHARES %fsw@[7..7];    # Error summary status
FLAGS %C0[1] -> 69 SHARES %fsw@[8..8];
FLAGS %C1[1] -> 70 SHARES %fsw@[9..9];
FLAGS %C2[1] -> 71 SHARES %fsw@[10..10];
FLAGS %TOP[3] -> 72 SHARES %fsw@[11..13]; # Top of stack
FLAGS %C3[1] -> 73 SHARES %fsw@[14..14];
FLAGS %B[1]  -> 74 SHARES %fsw@[15..15];  # FP busy


# pseudo registers (only to work around IR limitations)
FLAGS %SKIP[1] -> -1;
FLAGS %RPT[1] -> -1;
FLAGS %fflags[8] -> -1; # TODO: remove this


#
# Flag adjust functions
#
ADDFLAGS8(op1, op2, result)  {
    *1* %OF := (op1@[7:7] & op2@[7:7] & ~result@[7:7])
                | (~op1@[7:7] & ~op2@[7:7] & result@[7:7])
    *1* %SF := result@[7:7]
    *1* %ZF := (result = 0)
    *1* %CF := (op1@[7:7] & op2@[7:7]) | (~result@[7:7] & (op1@[7:7] | op2@[7:7]))
    *1* %PF := ((result@[7:7] ^ result@[6:6]) ^ (result@[5:5] ^ result@[4:4])) ^ ((result@[3:3] ^ result@[2:2]) ^ (result@[1:1] ^ result@[0:0]))
#   *1* %AF := ?? TODO
};

ADDFLAGS16(op1, op2, result)  {
    *1* %OF := (op1@[15:15] & op2@[15:15] & ~result@[15:15])
                | (~op1@[15:15] & ~op2@[15:15] & result@[15:15])
    *1* %SF := result@[15:15]
    *1* %ZF := (result = 0)
    *1* %CF := (op1@[15:15] & op2@[15:15]) | (~result@[15:15] & (op1@[15:15] | op2@[15:15]))
    *1* %PF := ((result@[7:7] ^ result@[6:6]) ^ (result@[5:5] ^ result@[4:4])) ^ ((result@[3:3] ^ result@[2:2]) ^ (result@[1:1] ^ result@[0:0]))
#   *1* %AF := ?? TODO
};

ADDFLAGS32(op1, op2, result)  {
    *1* %OF := (op1@[31:31] & op2@[31:31] & ~result@[31:31])
                | (~op1@[31:31] & ~op2@[31:31] & result@[31:31])
    *1* %SF := result@[31:31]
    *1* %ZF := (result = 0)
    *1* %CF := (op1@[31:31] & op2@[31:31]) | (~result@[31:31] & (op1@[31:31] | op2@[31:31]))
    *1* %PF := ((result@[7:7] ^ result@[6:6]) ^ (result@[5:5] ^ result@[4:4])) ^ ((result@[3:3] ^ result@[2:2]) ^ (result@[1:1] ^ result@[0:0]))
#   *1* %AF := ??
};

ADDFLAGS64(op1, op2, result)  {
    *1* %OF := (op1@[63:63] & op2@[63:63] & ~result@[63:63])
                | (~op1@[63:63] & ~op2@[63:63] & result@[63:63])
    *1* %SF := result@[63:63]
    *1* %ZF := (result = 0)
    *1* %CF := (op1@[63:63] & op2@[63:63]) | (~result@[63:63] & (op1@[63:63] | op2@[63:63]))
    *1* %PF := ((result@[7:7] ^ result@[6:6]) ^ (result@[5:5] ^ result@[4:4])) ^ ((result@[3:3] ^ result@[2:2]) ^ (result@[1:1] ^ result@[0:0]))
#   *1* %AF := ??
};


SUBFLAGS8(op1, op2, result)  {
    *1* %OF := (op1@[7:7] & ~op2@[7:7] & ~result@[7:7])
                | (~op1@[7:7] & op2@[7:7] & result@[7:7])
    *1* %SF := result@[7:7]
    *1* %ZF := (result = 0)
    *1* %CF := (~op1@[7:7] & op2@[7:7])
                | (result@[7:7] & ~(op1@[7:7] | op2@[7:7]))
    *1* %PF := ((result@[7:7] ^ result@[6:6]) ^ (result@[5:5] ^ result@[4:4])) ^ ((result@[3:3] ^ result@[2:2]) ^ (result@[1:1] ^ result@[0:0]))
#   *1* %AF := ??
};

SUBFLAGS16(op1, op2, result)  {
    *1* %OF := (op1@[15:15] & ~op2@[15:15] & ~result@[15:15])
                | (~op1@[15:15] &(op2@[15:15] & result@[15:15]))
    *1* %SF := result@[15:15]
    *1* %ZF := (result = 0)
    *1* %CF := (~op1@[15:15] & op2@[15:15])
                | (result@[15:15] & (~op1@[15:15] | op2@[15:15]))
    *1* %PF := ((result@[7:7] ^ result@[6:6]) ^ (result@[5:5] ^ result@[4:4])) ^ ((result@[3:3] ^ result@[2:2]) ^ (result@[1:1] ^ result@[0:0]))
#   *1* %AF := ??
};

SUBFLAGS32(op1, op2, result)  {
    *1* %OF := (op1@[31:31] & ~op2@[31:31] & ~result@[31:31])
                | (~op1@[31:31] & op2@[31:31] & result@[31:31])
    *1* %SF := result@[31:31]
    *1* %ZF := (result = 0)
    *1* %CF := (~op1@[31:31] & op2@[31:31])
                | (result@[31:31] & (~op1@[31:31] | op2@[31:31]))
    *1* %PF := ((result@[7:7] ^ result@[6:6]) ^ (result@[5:5] ^ result@[4:4])) ^ ((result@[3:3] ^ result@[2:2]) ^ (result@[1:1] ^ result@[0:0]))
#   *1* %AF := ??
};

SUBFLAGS64(op1, op2, result)  {
    *1* %OF := (op1@[63:63] & ~op2@[63:63] & ~result@[63:63])
                | (~op1@[63:63] & op2@[63:63] & result@[63:63])
    *1* %SF := result@[63:63]
    *1* %ZF := (result = 0)
    *1* %CF := (~op1@[63:63] & op2@[63:63])
                | (result@[63:63] & (~op1@[63:63] | op2@[63:63]))
    *1* %PF := ((result@[7:7] ^ result@[6:6]) ^ (result@[5:5] ^ result@[4:4])) ^ ((result@[3:3] ^ result@[2:2]) ^ (result@[1:1] ^ result@[0:0]))
#   *1* %AF := ??
};

SUBFLAGSFL(op1, op2) {
    *1* %CF := op1 < op2
    *1* %ZF := op1 = op2
};

INCDECFLAGS8(result) {
    *1* %OF := 0
    *1* %ZF := (result = 0)
    *1* %SF := result@[7:7]
    *1* %PF := ((result@[7:7] ^ result@[6:6]) ^ (result@[5:5] ^ result@[4:4])) ^ ((result@[3:3] ^ result@[2:2]) ^ (result@[1:1] ^ result@[0:0]))
#   *1* %AF := ??
};

INCDECFLAGS16(result)  {
    *1* %OF := 0
    *1* %ZF := (result = 0)
    *1* %SF := result@[15:15]
    *1* %PF := ((result@[7:7] ^ result@[6:6]) ^ (result@[5:5] ^ result@[4:4])) ^ ((result@[3:3] ^ result@[2:2]) ^ (result@[1:1] ^ result@[0:0]))
#   *1* %AF := ??
};

INCDECFLAGS32(result)  {
    *1* %OF := 0
    *1* %ZF := (result = 0)
    *1* %SF := result@[31:31]
    *1* %PF := ((result@[7:7] ^ result@[6:6]) ^ (result@[5:5] ^ result@[4:4])) ^ ((result@[3:3] ^ result@[2:2]) ^ (result@[1:1] ^ result@[0:0]))
#   *1* %AF := ??
};

INCDECFLAGS64(result)  {
    *1* %OF := 0
    *1* %ZF := (result = 0)
    *1* %SF := result@[63:63]
    *1* %PF := ((result@[7:7] ^ result@[6:6]) ^ (result@[5:5] ^ result@[4:4])) ^ ((result@[3:3] ^ result@[2:2]) ^ (result@[1:1] ^ result@[0:0]))
#   *1* %AF := ??
};

LOGICALFLAGS8(result)  {
    *1* %CF := 0
    *1* %OF := 0
    *1* %ZF := (result = 0)
    *1* %SF := result@[7:7]
    *1* %PF := ((result@[7:7] ^ result@[6:6]) ^ (result@[5:5] ^ result@[4:4])) ^ ((result@[3:3] ^ result@[2:2]) ^ (result@[1:1] ^ result@[0:0]))
#   *1* %AF := ??
};

LOGICALFLAGS16(result)  {
    *1* %CF := 0
    *1* %OF := 0
    *1* %ZF := (result = 0)
    *1* %SF := result@[15:15]
    *1* %PF := ((result@[7:7] ^ result@[6:6]) ^ (result@[5:5] ^ result@[4:4])) ^ ((result@[3:3] ^ result@[2:2]) ^ (result@[1:1] ^ result@[0:0]))
#   *1* %AF := ??
};

LOGICALFLAGS32(result)  {
    *1* %CF := 0
    *1* %OF := 0
    *1* %ZF := (result = 0)
    *1* %SF := result@[31:31]
    *1* %PF := ((result@[7:7] ^ result@[6:6]) ^ (result@[5:5] ^ result@[4:4])) ^ ((result@[3:3] ^ result@[2:2]) ^ (result@[1:1] ^ result@[0:0]))
#   *1* %AF := ??
};

LOGICALFLAGS64(result)  {
    *1* %CF := 0
    *1* %OF := 0
    *1* %ZF := (result = 0)
    *1* %SF := result@[63:63]
    *1* %PF := ((result@[7:7] ^ result@[6:6]) ^ (result@[5:5] ^ result@[4:4])) ^ ((result@[3:3] ^ result@[2:2]) ^ (result@[1:1] ^ result@[0:0]))
#   *1* %AF := ??
};


IMULTFLAGS8(result)  {
    *1* %CF := (result@[7:15] = 0 || result@[7:15] = 1)
    *1* %OF := (result@[7:15] = 0 || result@[7:15] = 1)
};

IMULTFLAGS16(result)  {
    *1* %CF := (result@[15:31] = 0 || result@[15:31] = 1)
    *1* %OF := (result@[15:31] = 0 || result@[15:31] = 1)
};

IMULTFLAGS32(result)  {
    *1* %CF := (result@[31:63] = 0 || result@[31:63] = 1)
    *1* %OF := (result@[31:63] = 0 || result@[31:63] = 1)
};


MULTFLAGS8(result)  {
    *1* %CF := (result@[8:15] ~= 0)
    *1* %OF := (result@[8:15] ~= 0)
};

MULTFLAGS16(result)  {
    *1* %CF := (result@[16:31] ~= 0)
    *1* %OF := (result@[16:31] ~= 0)
};

MULTFLAGS32(result)  {
    *1* %CF := (result@[32:63] ~= 0)
    *1* %OF := (result@[32:63] ~= 0)
};

ROLFLAGS8(result, op1, count)  {
    *1*              %CF := op1@[(8-count):(8-count)]
    *1* count=1  =>  %OF := result@[7:7] ^ %CF
};

ROLFLAGS16(result, op1, count)  {
    *1*              %CF := op1@[(16-count):(16-count)]
    *1* count=1  =>  %OF := result@[15:15] ^ %CF
};

ROLFLAGS32(result, op1, count)  {
    *1*              %CF := op1@[(32-count):(32-count)]
    *1* count=1  =>  %OF := result@[31:31] ^ %CF
};

RORFLAGS8(result, op1, count)  {
    *1*              %CF := op1@[(count - 1):(count - 1)]
    *1* count=1  =>  %OF := result@[7:7] ^ result@[6:6]
};

RORFLAGS16(result, op1, count)  {
    *1*              %CF := op1@[(count - 1):(count - 1)]
    *1* count=1  =>  %OF := result@[15:15] ^ result@[14:14]
};

RORFLAGS32(result, op1, count)  {
    *1*              %CF := op1@[(count - 1):(count - 1)]
    *1* count=1  =>  %OF := result@[31:31] ^ result@[30:30]
};

SALFLAGS8(result, op1, count)  {
    *1*              %CF := op1@[(8 - count):(8 - count)]
    *1* count=1  =>  %OF := result@[7:7] ^ %CF
};

SALFLAGS16(result, op1, count)  {
    *1*              %CF := op1@[(16 - count):(16 - count)]
    *1* count=1  =>  %OF := result@[15:15] ^ %CF
};

SALFLAGS32(result, op1, count)  {
    *1*              %CF := op1@[(32 - count):(32 - count)]
    *1* count=1  =>  %OF := result@[31:31] ^ %CF
};

SARFLAGS(result, op1, count)  {
    *1*              %CF := op1@[(count - 1):(count - 1)]
    *1* count=1  =>  %OF := 0
};

SHRFLAGS8(result, op1, count)  {
    *1*              %CF := op1@[(count - 1):(count - 1)]
    *1* count=1  =>  %OF := result@[7:7] ^ %CF
};

SHRFLAGS16(result, op1, count)  {
    *1*              %CF := op1@[(count - 1):(count - 1)]
    *1* count=1  =>  %OF := result@[15:15] ^ %CF
};

SHRFLAGS32(result, op1, count)  {
    *1*              %CF := op1@[(count - 1):(count - 1)]
    *1* count=1  =>  %OF := result@[31:31] ^ %CF
};

SHLDFLAGS16(result, combine, count)  {
    *1* count>0  =>  %CF := combine@[(16 - count):(16 - count)]
    *1* count=1  =>  %OF := result@[15:15] ^ %CF
};

SHLDFLAGS32(result, combine, count)  {
    *1* count>0  =>  %CF := combine@[(32 - count):(32 - count)]
    *1* count=1  =>  %OF := result@[31:31] ^ %CF
};

SHLDFLAGS64(result, combine, count)  {
    *1* count>0  =>  %CF := combine@[(64 - count):(64 - count)]
    *1* count=1  =>  %OF := result@[63:63] ^ %CF
};

SHRDFLAGS16(result, combine, count)  {
    *1* count>0  =>  %CF := combine@[(count - 1):(count - 1)]
    *1* count=1  =>  %OF := combine@[15:15] ^ result@[15:15]
};

SHRDFLAGS32(result, combine, count)  {
    *1* count>0  =>  %CF := combine@[(count - 1):(count - 1)]
    *1* count=1  =>  %OF := combine@[31:31] ^ result@[31:31]
};

SHRDFLAGS64(result, combine, count)  {
    *1* count>0  =>  %CF := combine@[(count - 1):(count - 1)]
    *1* count=1  =>  %OF := combine@[63:63] ^ result@[63:63]
};

SETFFLAGS(op1, op2)  {
    *1* %C3  := [(op1 = op2) ? 1 : 0]
    *1* %C0  := [(op1 < op2) ? 1 : 0]
    *1* %C2  := 0 # If comparison result is unordered, (C3 C2 C0) == 111
};


SAHFFLAGS(reg) { _ };

#
# String instructions
#

# The string instructions
REPS  := { "REP", "REPNE" };                      # Repeat prefixes
OREPS := { "REP", "REPNE", "" };                  # Optional repeat prefixes
ALLSZ := { "Breg8rm8",   "Brm8reg8",   "Brm8rm8",
           "Wreg16rm16", "Wrm16reg16", "Wrm16rm16",
           "Dreg32rm32", "Drm32reg32", "Drm32rm32" }; # All size suffixes

# String instructions, not repeated
STRS := { "CMPS", "LODS", "MOVS", "SCAS", "STOS" };

# String instructions, repeated
STRS_R := REPS . STRS;

# String instructions, optionally repeated
STRS_OR := OREPS . STRS;

STRFL    :=         { "CMPS", "SCAS" };                  # Update flags
STRNF    :=         { "LODS", "MOVS", "STOS" };          # No update flags
STRSI    := OREPS . { "CMPS", "LODS", "MOVS" };          # Update esi
STRDI    := OREPS . { "CMPS", "MOVS", "SCAS", "STOS" };  # Update edi
STRFL_OR := OREPS . STRFL;                               # Optionally repeated; flags

CMPS_OR := OREPS . CMPS;      # Compare with optional repeat
LODS_OR := OREPS . LODS;      # Load with optional repeat
MOVS_OR := OREPS . MOVS;      # Move with optional repeat
SCAS_OR := OREPS . SCAS;      # Scan with optional repeat
STOS_OR := OREPS . STOS;      # Store with optional repeat

# All repeated string instructions
INSTRUCTION STRS_R[X] . ALLSZ[Y] (dest, src)              { *1* %SKIP := (%ecx = 0) };

INSTRUCTION CMPS_OR[X] . ".B.reg8.rm8" (dest, src)             { *8*  tmpb := dest - src };
INSTRUCTION CMPS_OR[X] . ".B.rm8.reg8" (dest, src)             { *8*  tmpb := dest - src };
INSTRUCTION CMPS_OR[X] . ".B.rm8.rm8" (dest, src)              { *8*  tmpb := dest - src };
INSTRUCTION CMPS_OR[X] . ".W.reg16.rm16" (dest, src)           { *16* tmph := dest - src };
INSTRUCTION CMPS_OR[X] . ".W.rm16.reg16" (dest, src)           { *16* tmph := dest - src };
INSTRUCTION CMPS_OR[X] . ".W.rm16.rm16" (dest, src)            { *16* tmph := dest - src };
INSTRUCTION CMPS_OR[X] . ".D.reg32.rm32" (dest, src)           { *32* tmp1 := dest - src };
INSTRUCTION CMPS_OR[X] . ".D.rm32.reg32" (dest, src)           { *32* tmp1 := dest - src };
INSTRUCTION CMPS_OR[X] . ".D.rm32.rm32" (dest, src)            { *32* tmp1 := dest - src };

INSTRUCTION LODS_OR[X] . ".B.reg8.rm8" (dest, src)             { *8*  dest := src };
INSTRUCTION LODS_OR[X] . ".B.rm8.reg8" (dest, src)             { *8*  dest := src };
INSTRUCTION LODS_OR[X] . ".B.rm8.rm8" (dest, src)              { *8*  dest := src };
INSTRUCTION LODS_OR[X] . ".W.reg16.rm16" (dest, src)           { *16* dest := src };
INSTRUCTION LODS_OR[X] . ".W.rm16.reg16" (dest, src)           { *16* dest := src };
INSTRUCTION LODS_OR[X] . ".W.rm16.rm16" (dest, src)            { *16* dest := src };
INSTRUCTION LODS_OR[X] . ".D.reg32.rm32" (dest, src)           { *32* dest := src };
INSTRUCTION LODS_OR[X] . ".D.rm32.reg32" (dest, src)           { *32* dest := src };
INSTRUCTION LODS_OR[X] . ".D.rm32.rm32" (dest, src)            { *32* dest := src };

INSTRUCTION MOVS_OR[X] . ".B.reg8.rm8" (dest, src)             { *8*  dest := src };
INSTRUCTION MOVS_OR[X] . ".B.rm8.reg8" (dest, src)             { *8*  dest := src };
INSTRUCTION MOVS_OR[X] . ".B.rm8.rm8" (dest, src)              { *8*  dest := src };
INSTRUCTION MOVS_OR[X] . ".W.reg16.rm16" (dest, src)           { *16* dest := src };
INSTRUCTION MOVS_OR[X] . ".W.rm16.reg16" (dest, src)           { *16* dest := src };
INSTRUCTION MOVS_OR[X] . ".W.rm16.rm16" (dest, src)            { *16* dest := src };
INSTRUCTION MOVS_OR[X] . ".D.reg32.rm32" (dest, src)           { *32* dest := src };
INSTRUCTION MOVS_OR[X] . ".D.rm32.reg32" (dest, src)           { *32* dest := src };
INSTRUCTION MOVS_OR[X] . ".D.rm32.rm32" (dest, src)            { *32* dest := src };

INSTRUCTION SCAS_OR[X] . ".B.reg8.rm8" (dest, src)             { *8*  tmpb := dest - src };
INSTRUCTION SCAS_OR[X] . ".B.rm8.reg8" (dest, src)             { *8*  tmpb := dest - src };
INSTRUCTION SCAS_OR[X] . ".B.rm8.rm8" (dest, src)              { *8*  tmpb := dest - src };
INSTRUCTION SCAS_OR[X] . ".W.reg16.rm16" (dest, src)           { *16* tmph := dest - src };
INSTRUCTION SCAS_OR[X] . ".W.rm16.reg16" (dest, src)           { *16* tmph := dest - src };
INSTRUCTION SCAS_OR[X] . ".W.rm16.rm16" (dest, src)            { *16* tmph := dest - src };
INSTRUCTION SCAS_OR[X] . ".D.reg32.rm32" (dest, src)           { *32* tmp1 := dest - src };
INSTRUCTION SCAS_OR[X] . ".D.rm32.reg32" (dest, src)           { *32* tmp1 := dest - src };
INSTRUCTION SCAS_OR[X] . ".D.rm32.rm32" (dest, src)            { *32* tmp1 := dest - src };

INSTRUCTION STOS_OR[X] . ".B.reg8.rm8" (dest, src)             { *8*  dest := src };
INSTRUCTION STOS_OR[X] . ".B.rm8.reg8" (dest, src)             { *8*  dest := src };
INSTRUCTION STOS_OR[X] . ".B.rm8.rm8" (dest, src)              { *8*  dest := src };
INSTRUCTION STOS_OR[X] . ".W.reg16.rm16" (dest, src)           { *16* dest := src };
INSTRUCTION STOS_OR[X] . ".W.rm16.reg16" (dest, src)           { *16* dest := src };
INSTRUCTION STOS_OR[X] . ".W.rm16.rm16" (dest, src)            { *16* dest := src };
INSTRUCTION STOS_OR[X] . ".D.reg32.rm32" (dest, src)           { *32* dest := src };
INSTRUCTION STOS_OR[X] . ".D.rm32.reg32" (dest, src)           { *32* dest := src };
INSTRUCTION STOS_OR[X] . ".D.rm32.rm32" (dest, src)            { *32* dest := src };

# update flags
INSTRUCTION STRFL_OR[X] . ".B.reg8.rm8" (dest, src)            { SUBFLAGS8(dest,  src, tmpb) };
INSTRUCTION STRFL_OR[X] . ".B.rm8.reg8" (dest, src)            { SUBFLAGS8(dest,  src, tmpb) };
INSTRUCTION STRFL_OR[X] . ".B.rm8.rm8" (dest, src)             { SUBFLAGS8(dest,  src, tmpb) };
INSTRUCTION STRFL_OR[X] . ".W.reg16.rm16" (dest, src)          { SUBFLAGS16(dest, src, tmph) };
INSTRUCTION STRFL_OR[X] . ".W.rm16.reg16" (dest, src)          { SUBFLAGS16(dest, src, tmph) };
INSTRUCTION STRFL_OR[X] . ".W.rm16.rm16" (dest, src)           { SUBFLAGS16(dest, src, tmph) };
INSTRUCTION STRFL_OR[X] . ".D.reg32.rm32" (dest, src)          { SUBFLAGS32(dest, src, tmp1) };
INSTRUCTION STRFL_OR[X] . ".D.rm32.reg32" (dest, src)          { SUBFLAGS32(dest, src, tmp1) };
INSTRUCTION STRFL_OR[X] . ".D.rm32.rm32" (dest, src)           { SUBFLAGS32(dest, src, tmp1) };

# update (e)si
INSTRUCTION STRSI[IDX] . ".B.reg8.rm8" (dest, src)             { *32* %esi := %esi + [%DF = 0?1:-1] };
INSTRUCTION STRSI[IDX] . ".B.rm8.reg8" (dest, src)             { *32* %esi := %esi + [%DF = 0?1:-1] };
INSTRUCTION STRSI[IDX] . ".B.rm8.rm8" (dest, src)              { *32* %esi := %esi + [%DF = 0?1:-1] };
INSTRUCTION STRSI[IDX] . ".W.reg16.rm16" (dest, src)           { *32* %esi := %esi + [%DF = 0?2:-2] };
INSTRUCTION STRSI[IDX] . ".W.rm16.reg16" (dest, src)           { *32* %esi := %esi + [%DF = 0?2:-2] };
INSTRUCTION STRSI[IDX] . ".W.rm16.rm16" (dest, src)            { *32* %esi := %esi + [%DF = 0?2:-2] };
INSTRUCTION STRSI[IDX] . ".D.reg32.rm32" (dest, src)           { *32* %esi := %esi + [%DF = 0?4:-4] };
INSTRUCTION STRSI[IDX] . ".D.rm32.reg32" (dest, src)           { *32* %esi := %esi + [%DF = 0?4:-4] };
INSTRUCTION STRSI[IDX] . ".D.rm32.rm32" (dest, src)            { *32* %esi := %esi + [%DF = 0?4:-4] };

# update (e)di
INSTRUCTION STRDI[IDX] . ".B.reg8.rm8" (dest, src)             { *32* %edi := %edi + [%DF = 0?1:-1] };
INSTRUCTION STRDI[IDX] . ".B.rm8.reg8" (dest, src)             { *32* %edi := %edi + [%DF = 0?1:-1] };
INSTRUCTION STRDI[IDX] . ".B.rm8.rm8" (dest, src)              { *32* %edi := %edi + [%DF = 0?1:-1] };
INSTRUCTION STRDI[IDX] . ".W.reg16.rm16" (dest, src)           { *32* %edi := %edi + [%DF = 0?2:-2] };
INSTRUCTION STRDI[IDX] . ".W.rm16.reg16" (dest, src)           { *32* %edi := %edi + [%DF = 0?2:-2] };
INSTRUCTION STRDI[IDX] . ".W.rm16.rm16" (dest, src)            { *32* %edi := %edi + [%DF = 0?2:-2] };
INSTRUCTION STRDI[IDX] . ".D.reg32.rm32" (dest, src)           { *32* %edi := %edi + [%DF = 0?4:-4] };
INSTRUCTION STRDI[IDX] . ".D.rm32.reg32" (dest, src)           { *32* %edi := %edi + [%DF = 0?4:-4] };
INSTRUCTION STRDI[IDX] . ".D.rm32.rm32" (dest, src)            { *32* %edi := %edi + [%DF = 0?4:-4] };

# All repeated instructions decrement %ecx
INSTRUCTION STRS_R[X] . ALLSZ[Y] (dest, src)              { *32* %ecx := %ecx - 1 };

# Do the repeat logic
REPIFZ  := REP   . STRFL;
REPIFNZ := REPNE . STRFL;
REPALL  := REPS  . STRNF;

INSTRUCTION REPIFZ[X]  . ALLSZ[Y] (dest, src)             { *1* %RPT := %ZF };
INSTRUCTION REPIFNZ[X] . ALLSZ[Y] (dest, src)             { *1* %RPT := ~%ZF };
INSTRUCTION REPALL[X]  . ALLSZ[Y] (dest, src)             { *1* %RPT := 1 };


#
# Remaining instructions (sorted alphabetically)
#

# AAA
INSTRUCTION "AAA" () {
    *1* tmpadjust := ((%al & 0x0F) > 9) | %AF
    *16* %ax := %ax + 0x0106 * tmpadjust
    *1*  %AF := tmpadjust
    *1*  %CF := tmpadjust
    *8*  %al := %al & 0x0F
};


# AAD
INSTRUCTION "AAD" () {
    *8* %al := (%al + (%ah * 0x0A)) & 0xFF
    *8* %ah := 0
};

INSTRUCTION "AAD.imm8" (imm8) {
    *8* %al := (%al + (%ah * imm8)) & 0xFF
    *8* %ah := 0
};


# AAM
INSTRUCTION "AAM" () {
    *8* %ah := %al / 0x0A
    *8* %al := %al % 0x0A
};

INSTRUCTION "AAM.imm8" (imm8) {
    *8* %ah := %al / imm8
    *8* %al := %al % imm8
};


# AAS
INSTRUCTION "AAS" () {
    *1* tmpadjust := %AF | ((%al & 0x0F) > 9)
    *16* %ax := %ax - 6 * tmpadjust
    *8*  %ah := %ah - tmpadjust
    *1*  %AF := tmpadjust
    *1*  %CF := tmpadjust
    *8*  %al := %al & 0x0F
};


# ADC
INSTRUCTION "ADC.reg8.imm8" (dest, src) {
    *8* tmpdest := dest
    *8* dest := dest + src + %CF
    ADDFLAGS8(tmpdest, src, dest)
};

INSTRUCTION "ADC.reg8.reg8" (dest, src) {
    *8* tmpdest := dest
    *8* dest := dest + src + %CF
    ADDFLAGS8(tmpdest, src, dest)
};

INSTRUCTION "ADC.reg8.rm8" (dest, src) {
    *8* tmpdest := dest
    *8* dest := dest + src + %CF
    ADDFLAGS8(tmpdest, src, dest)
};

INSTRUCTION "ADC.reg16.imm16" (dest, src) {
    *16* tmpdest := dest
    *16* dest := dest + src + %CF
    ADDFLAGS16(tmpdest, src, dest)
};

INSTRUCTION "ADC.reg16.reg16" (dest, src) {
    *16* tmpdest := dest
    *16* dest := dest + src + %CF
    ADDFLAGS16(tmpdest, src, dest)
};

INSTRUCTION "ADC.reg16.rm16" (dest, src) {
    *16* tmpdest := dest
    *16* dest := dest + src + %CF
    ADDFLAGS16(tmpdest, src, dest)
};

INSTRUCTION "ADC.reg32.imm32" (dest, src) {
    *32* tmpdest := dest
    *32* dest := dest + src + %CF
    ADDFLAGS32(tmpdest, src, dest)
};

INSTRUCTION "ADC.reg32.reg32" (dest, src) {
    *32* tmpdest := dest
    *32* dest := dest + src + %CF
    ADDFLAGS32(tmpdest, src, dest)
};

INSTRUCTION "ADC.reg32.rm32" (dest, src) {
    *32* tmpdest := dest
    *32* dest := dest + src + %CF
    ADDFLAGS32(tmpdest, src, dest)
};

INSTRUCTION "ADC.reg64.rm64" (dest, src) {
    *64* tmpdest := dest
    *64* dest := dest + src + %CF
    ADDFLAGS64(tmpdest, src, dest)
};

INSTRUCTION "ADC.rm8.imm8" (dest, src) {
    *8* tmpdest := dest
    *8* dest := dest + src + %CF
    ADDFLAGS8(tmpdest, src, dest)
};

INSTRUCTION "ADC.rm8.reg8" (dest, src) {
    *8* tmpdest := dest
    *8* dest := dest + src + %CF
    ADDFLAGS8(tmpdest, src, dest)
};

INSTRUCTION "ADC.rm16.imm8" (dest, src) {
    *16* tmpdest := dest
    *16* tmpsrc := sgnex(8, 16, src)
    *16* dest := dest + tmpsrc + %CF
    ADDFLAGS16(tmpdest, tmpsrc, dest)
};

INSTRUCTION "ADC.rm16.imm16" (dest, src) {
    *16* tmpdest := dest
    *16* dest := dest + src + %CF
    ADDFLAGS16(tmpdest, src, dest)
};

INSTRUCTION "ADC.rm16.reg16" (dest, src) {
    *16* tmpdest := dest
    *16* dest := dest + src + %CF
    ADDFLAGS16(tmpdest, src, dest)
};

INSTRUCTION "ADC.rm32.imm8" (dest, src) {
    *32* tmpdest := dest
    *32* tmpsrc := sgnex(8, 32, src)
    *32* dest := dest + tmpsrc + %CF
    ADDFLAGS32(tmpdest, tmpsrc, dest)
};

INSTRUCTION "ADC.rm32.imm32" (dest, src) {
    *32* tmpdest := dest
    *32* dest := dest + src + %CF
    ADDFLAGS32(tmpdest, src, dest)
};

INSTRUCTION "ADC.rm32.reg32" (dest, src) {
    *32* tmpdest := dest
    *32* dest := dest + src + %CF
    ADDFLAGS32(tmpdest, src, dest)
};

INSTRUCTION "ADC.rm64.imm8" (dest, src) {
    *64* tmpdest := dest
    *64* tmpsrc := sgnex(8, 64, src)
    *64* dest := dest + tmpsrc + %CF
    ADDFLAGS64(tmpdest, tmpsrc, dest)
};

INSTRUCTION "ADC.rm64.imm32" (dest, src) {
    *64* tmpdest := dest
    *64* tmpsrc := sgnex(32, 64, src)
    *64* dest := dest + tmpsrc + %CF
    ADDFLAGS64(tmpdest, tmpsrc, dest)
};

INSTRUCTION "ADC.rm64.imm64" (dest, src) {
    *64* tmpdest := dest
    *64* dest := dest + src + %CF
    ADDFLAGS64(tmpdest, src, dest)
};


# ADD
INSTRUCTION "ADD.reg8.imm8" (dest, src) {
    *8* tmp1 := dest
    *8* dest := dest + src
    ADDFLAGS8(tmp1, src, dest)
};

INSTRUCTION "ADD.reg8.reg8" (dest, src) {
    *8* tmp1 := dest
    *8* dest := dest + src
    ADDFLAGS8(tmp1, src, dest)
};

INSTRUCTION "ADD.reg8.rm8" (dest, src) {
    *8* tmp1 := dest
    *8* dest := dest + src
    ADDFLAGS8(tmp1, src, dest)
};

INSTRUCTION "ADD.reg16.imm16" (dest, src) {
    *16* tmp1 := dest
    *16* dest := dest + src
    ADDFLAGS16(tmp1, src, dest)
};

INSTRUCTION "ADD.reg16.reg16" (dest, src) {
    *16* tmp1 := dest
    *16* dest := dest + src
    ADDFLAGS16(tmp1, src, dest)
};

INSTRUCTION "ADD.reg16.rm16" (dest, src) {
    *16* tmp1 := dest
    *16* dest := dest + src
    ADDFLAGS16(tmp1, src, dest)
};

INSTRUCTION "ADD.reg32.imm32" (dest, src) {
    *32* tmp1 := dest
    *32* dest := dest + src
    ADDFLAGS32(tmp1, src, dest)
};

INSTRUCTION "ADD.reg32.reg32" (dest, src) {
    *32* tmp1 := dest
    *32* dest := dest + src
    ADDFLAGS32(tmp1, src, dest)
};

INSTRUCTION "ADD.reg32.rm32" (dest, src) {
    *32* tmp1 := dest
    *32* dest := dest + src
    ADDFLAGS32(tmp1, src, dest)
};

INSTRUCTION "ADD.reg64.rm64" (dest, src) {
    *64* tmp1 := dest
    *64* dest := dest + src
    ADDFLAGS64(tmp1, src, dest)
};

INSTRUCTION "ADD.rm8.imm8" (dest, src) {
    *8* tmp1 := dest
    *8* dest := dest + src
    ADDFLAGS8(tmp1, src, dest)
};

INSTRUCTION "ADD.rm8.reg8" (dest, src) {
    *8* tmp1 := dest
    *8* dest := dest + src
    ADDFLAGS8(tmp1, src, dest)
};

INSTRUCTION "ADD.rm16.imm8" (dest, src) {
    *16* tmp1 := dest
    *16* tmpsrc := sgnex(8, 16, src)
    *16* dest := dest + tmpsrc
    ADDFLAGS16(tmp1, tmpsrc, dest)
};

INSTRUCTION "ADD.rm16.imm16" (dest, src) {
    *16* tmp1 := dest
    *16* dest := dest + src
    ADDFLAGS16(tmp1, src, dest)
};

INSTRUCTION "ADD.rm16.reg16" (dest, src) {
    *16* tmp1 := dest
    *16* dest := dest + src
    ADDFLAGS16(tmp1, src, dest)
};

INSTRUCTION "ADD.rm32.imm8" (dest, src) {
    *32* tmp1 := dest
    *32* tmpsrc := sgnex(8, 32, src)
    *32* dest := dest + tmpsrc
    ADDFLAGS32(tmp1, tmpsrc, dest)
};

INSTRUCTION "ADD.rm32.imm32" (dest, src) {
    *32* tmp1 := dest
    *32* dest := dest + src
    ADDFLAGS32(tmp1, src, dest)
};

INSTRUCTION "ADD.rm32.reg32" (dest, src) {
    *32* tmp1 := dest
    *32* dest := dest + src
    ADDFLAGS32(tmp1, src, dest)
};

INSTRUCTION "ADD.rm64.imm8" (dest, src) {
    *64* tmp1 := dest
    *64* tmpsrc := sgnex(8, 64, src)
    *64* dest := dest + tmpsrc
    ADDFLAGS64(tmp1, tmpsrc, dest)
};

INSTRUCTION "ADD.rm64.imm32" (dest, src) {
    *64* tmp1 := dest
    *64* tmpsrc := sgnex(32, 64, src)
    *64* dest := dest + tmpsrc
    ADDFLAGS64(tmp1, tmpsrc, dest)
};

INSTRUCTION "ADD.rm64.imm64" (dest, src) {
    *64* tmp1 := dest
    *64* dest := dest + src
    ADDFLAGS64(tmp1, src, dest)
};


# AND
INSTRUCTION "AND.reg8.imm8" (dest, src) {
    *8* dest := dest & src
    LOGICALFLAGS8(dest)
};

INSTRUCTION "AND.reg8.reg8" (dest, src) {
    *8* dest := dest & src
    LOGICALFLAGS8(dest)
};

INSTRUCTION "AND.reg8.rm8" (dest, src) {
    *8* dest := dest & src
    LOGICALFLAGS8(dest)
};

INSTRUCTION "AND.reg16.imm16" (dest, src) {
    *16* dest := dest & src
    LOGICALFLAGS16(dest)
};

INSTRUCTION "AND.reg16.reg16" (dest, src) {
    *16* dest := dest & src
    LOGICALFLAGS16(dest)
};

INSTRUCTION "AND.reg16.rm16" (dest, src) {
    *16* dest := dest & src
    LOGICALFLAGS16(dest)
};

INSTRUCTION "AND.reg32.imm32" (dest, src) {
    *32* dest := dest & src
    LOGICALFLAGS32(dest)
};

INSTRUCTION "AND.reg32.reg32" (dest, src) {
    *32* dest := dest & src
    LOGICALFLAGS32(dest)
};

INSTRUCTION "AND.reg32.rm32" (dest, src) {
    *32* dest := dest & src
    LOGICALFLAGS32(dest)
};

INSTRUCTION "AND.reg64.rm64" (dest, src) {
    *64* dest := dest & src
    LOGICALFLAGS64(dest)
};

INSTRUCTION "AND.rm8.imm8" (dest, src) {
    *8* dest := dest & src
    LOGICALFLAGS8(dest)
};

INSTRUCTION "AND.rm8.reg8" (dest, src) {
    *8* dest := dest & src
    LOGICALFLAGS8(dest)
};

INSTRUCTION "AND.rm16.imm8" (dest, src) {
    *16* dest := dest & sgnex(8, 16, src)
    LOGICALFLAGS16(dest)
};

INSTRUCTION "AND.rm16.imm16" (dest, src) {
    *16* dest := dest & src
    LOGICALFLAGS16(dest)
};

INSTRUCTION "AND.rm16.reg16" (dest, src) {
    *16* dest := dest & src
    LOGICALFLAGS16(dest)
};

INSTRUCTION "AND.rm32.imm8" (dest, src) {
    *32* dest := dest & sgnex(8, 32, src)
    LOGICALFLAGS32(dest)
};

INSTRUCTION "AND.rm32.imm32" (dest, src) {
    *32* dest := dest & src
    LOGICALFLAGS32(dest)
};

INSTRUCTION "AND.rm32.reg32" (dest, src) {
    *32* dest := dest & src
    LOGICALFLAGS32(dest)
};

INSTRUCTION "AND.rm64.imm8" (dest, src) {
    *64* dest := dest & sgnex(8, 64, src)
    LOGICALFLAGS64(dest)
};

INSTRUCTION "AND.rm64.imm32" (dest, src) {
    *64* dest := dest & sgnex(32, 64, src)
    LOGICALFLAGS64(dest)
};

INSTRUCTION "AND.rm64.reg64" (dest, src) {
    *64* dest := dest & src
    LOGICALFLAGS64(dest)
};

# BSF / BSR not handled here - the semantics are hard-coded

# BSWAP
INSTRUCTION "BSWAP.reg16" (dest) {
    *16* dest := ((dest & 0x00FF) << 8) |
                 ((dest & 0xFF00) >> 8)
};


INSTRUCTION "BSWAP.reg32" (dest) {
    *32* dest := ((dest & 0x000000FF) << 24) |
                 ((dest & 0x0000FF00) <<  8) |
                 ((dest & 0x00FF0000) >>  8) |
                 ((dest & 0xFF000000) >> 24)
};


# BT
INSTRUCTION "BT.reg16.imm8" (src, bit) {
    *1* %CF := src@[bit:bit]
};

INSTRUCTION "BT.reg16.imm16" (src, bit) {
    *1* %CF := src@[bit:bit]
};

INSTRUCTION "BT.reg16.reg16" (src, bit) {
    *1* %CF := src@[bit:bit]
};

INSTRUCTION "BT.reg32.imm8" (src, bit) {
    *1* %CF := src@[bit:bit]
};

INSTRUCTION "BT.reg32.imm32" (src, bit) {
    *1* %CF := src@[bit:bit]
};

INSTRUCTION "BT.reg32.reg32" (src, bit) {
    *1* %CF := src@[bit:bit]
};

INSTRUCTION "BT.rm16.imm16" (src, bit) {
    *1* %CF := src@[bit:bit]
};

INSTRUCTION "BT.rm16.reg16" (src, bit) {
    *1* %CF := src@[bit:bit]
};

INSTRUCTION "BT.rm32.imm32" (src, bit) {
    *1* %CF := src@[bit:bit]
};

INSTRUCTION "BT.rm32.reg32" (src, bit) {
    *1* %CF := src@[bit:bit]
};

INSTRUCTION "BT.rm64.reg64" (src, bit) {
    *1* %CF := src@[bit:bit]
};


# BTC
INSTRUCTION "BTC.reg16.imm8" (dest, bit) {
    *1* %CF := dest@[bit:bit]
    *16* dest := dest ^ (1 << bit)
};

INSTRUCTION "BTC.reg16.imm16" (dest, bit) {
    *1* %CF := dest@[bit:bit]
    *16* dest := dest ^ (1 << bit)
};

INSTRUCTION "BTC.reg16.reg16" (dest, bit) {
    *1* %CF := dest@[bit:bit]
    *16* dest := dest ^ (1 << bit)
};

INSTRUCTION "BTC.reg32.imm8" (dest, bit) {
    *1* %CF := dest@[bit:bit]
    *32* dest := dest ^ (1 << bit)
};

INSTRUCTION "BTC.reg32.imm32" (dest, bit) {
    *1* %CF := dest@[bit:bit]
    *32* dest := dest ^ (1 << bit)
};

INSTRUCTION "BTC.reg32.reg32" (dest, bit) {
    *1* %CF := dest@[bit:bit]
    *32* dest := dest ^ (1 << bit)
};

INSTRUCTION "BTC.rm16.imm16" (dest, bit) {
    *1* %CF := dest@[bit:bit]
    *16* dest := dest ^ (1 << bit)
};

INSTRUCTION "BTC.rm16.reg16" (dest, bit) {
    *1* %CF := dest@[bit:bit]
    *16* dest := dest ^ (1 << bit)
};


INSTRUCTION "BTC.rm32.reg32" (dest, bit) {
    *1* %CF := dest@[bit:bit]
    *32* dest := dest ^ (1 << bit)
};


# BTR
INSTRUCTION "BTR.reg16.imm8" (dest, bit) {
    *1* %CF := dest@[bit:bit]
    *16* dest := dest & ~(1 << bit)
};

INSTRUCTION "BTR.reg16.imm16" (dest, bit) {
    *1* %CF := dest@[bit:bit]
    *16* dest := dest & ~(1 << bit)
};

INSTRUCTION "BTR.reg16.reg16" (dest, bit) {
    *1* %CF := dest@[bit:bit]
    *16* dest := dest & ~(1 << bit)
};

INSTRUCTION "BTR.reg32.imm8" (dest, bit) {
    *1* %CF := dest@[bit:bit]
    *32* dest := dest & ~(1 << bit)
};

INSTRUCTION "BTR.reg32.imm32" (dest, bit) {
    *1* %CF := dest@[bit:bit]
    *32* dest := dest & ~(1 << bit)
};

INSTRUCTION "BTR.reg32.reg32" (dest, bit) {
    *1* %CF := dest@[bit:bit]
    *32* dest := dest & ~(1 << bit)
};

INSTRUCTION "BTR.rm16.imm16" (dest, bit) {
    *1* %CF := dest@[bit:bit]
    *16* dest := dest & ~(1 << bit)
};

INSTRUCTION "BTR.rm16.reg16" (dest, bit) {
    *1* %CF := dest@[bit:bit]
    *16* dest := dest & ~(1 << bit)
};

INSTRUCTION "BTR.rm32.imm32" (dest, bit) {
    *1* %CF := dest@[bit:bit]
    *32* dest := dest & ~(1 << bit)
};

INSTRUCTION "BTR.rm32.reg32" (dest, bit) {
    *1* %CF := dest@[bit:bit]
    *32* dest := dest & ~(1 << bit)
};


# BTS
INSTRUCTION "BTS.reg16.imm8" (dest, bit) {
    *1* %CF := dest@[bit:bit]
    *16* dest := dest | (1 << bit)
};

INSTRUCTION "BTS.reg16.imm16" (dest, bit) {
    *1* %CF := dest@[bit:bit]
    *16* dest := dest | (1 << bit)
};

INSTRUCTION "BTS.reg16.reg16" (dest, bit) {
    *1* %CF := dest@[bit:bit]
    *16* dest := dest | (1 << bit)
};

INSTRUCTION "BTS.reg32.imm8" (dest, bit) {
    *1* %CF := dest@[bit:bit]
    *32* dest := dest | (1 << bit)
};

INSTRUCTION "BTS.reg32.imm32" (dest, bit) {
    *1* %CF := dest@[bit:bit]
    *32* dest := dest | (1 << bit)
};

INSTRUCTION "BTS.reg32.reg32" (dest, bit) {
    *1* %CF := dest@[bit:bit]
    *32* dest := dest | (1 << bit)
};

INSTRUCTION "BTS.rm16.imm16" (dest, bit) {
    *1* %CF := dest@[bit:bit]
    *16* dest := dest | (1 << bit)
};

INSTRUCTION "BTS.rm16.reg16" (dest, bit) {
    *1* %CF := dest@[bit:bit]
    *16* dest := dest | (1 << bit)
};

INSTRUCTION "BTS.rm32.imm32" (dest, bit) {
    *1* %CF := dest@[bit:bit]
    *32* dest := dest | (1 << bit)
};

INSTRUCTION "BTS.rm32.reg32" (dest, bit) {
    *1* %CF := dest@[bit:bit]
    *32* dest := dest | (1 << bit)
};


# CALL
INSTRUCTION "CALL.imm16" (dest) {
    *16* %sp := %sp - 4
    *16* m[%sp] := %pc
    call dest
};

INSTRUCTION "CALL.imm32" (dest) {
    *32* %esp := %esp - 4
    *32* m[%esp] := %pc
    call dest
};

INSTRUCTION "CALL.reg16" (dest) {
    *16* %sp := %sp - 4
    *16* m[%sp] := %pc
    call dest
};

INSTRUCTION "CALL.reg32" (dest) {
    *32* %esp := %esp - 4
    *32* m[%esp] := %pc
    call dest
};

INSTRUCTION "CALL.rm16" (dest) {
    *16* %sp := %sp - 4
    *16* m[%sp] := %pc
    call dest
};

INSTRUCTION "CALL.rm32" (dest) {
    *32* %esp := %esp - 4
    *32* m[%esp] := %pc
    call dest
};


# CBW
INSTRUCTION "CBW" () {
    *16* %ax := sgnex(8, 16, %al)
};


# CDQ
INSTRUCTION "CDQ" () {
    *32* %edx := [%eax@[31:31] = 0 ? 0:0xFFFFFFFF]
};


# CLC
INSTRUCTION "CLC" () {
    *1* %CF := 0
};


# CLD
INSTRUCTION "CLD" () {
    *1* %DF := 0
};


# CLI
INSTRUCTION "CLI" () {
    *1* %IF := 0
};


# CMC
INSTRUCTION "CMC" () {
    *1*%CF := ~%CF
};


# CMOVcc
INSTRUCTION "CMOVA.reg16.reg16"    (dest, src) { *16* dest := [(~%CF && ~%ZF)         ? src : dest] };
INSTRUCTION "CMOVA.reg16.rm16"     (dest, src) { *16* dest := [(~%CF && ~%ZF)         ? src : dest] };
INSTRUCTION "CMOVA.reg32.reg32"    (dest, src) { *32* dest := [(~%CF && ~%ZF)         ? src : dest] };
INSTRUCTION "CMOVA.reg32.rm32"     (dest, src) { *32* dest := [(~%CF && ~%ZF)         ? src : dest] };

INSTRUCTION "CMOVAE.reg16.reg16"   (dest, src) { *16* dest := [(%CF = 0)              ? src : dest] };
INSTRUCTION "CMOVAE.reg16.rm16"    (dest, src) { *16* dest := [(%CF = 0)              ? src : dest] };
INSTRUCTION "CMOVAE.reg32.reg32"   (dest, src) { *32* dest := [(%CF = 0)              ? src : dest] };
INSTRUCTION "CMOVAE.reg32.rm32"    (dest, src) { *32* dest := [(%CF = 0)              ? src : dest] };

INSTRUCTION "CMOVB.reg16.reg16"    (dest, src) { *16* dest := [(%CF = 1)              ? src : dest] };
INSTRUCTION "CMOVB.reg16.rm16"     (dest, src) { *16* dest := [(%CF = 1)              ? src : dest] };
INSTRUCTION "CMOVB.reg32.reg32"    (dest, src) { *32* dest := [(%CF = 1)              ? src : dest] };
INSTRUCTION "CMOVB.reg32.rm32"     (dest, src) { *32* dest := [(%CF = 1)              ? src : dest] };

INSTRUCTION "CMOVBE.reg16.reg16"   (dest, src) { *16* dest := [(%CF || %ZF)           ? src : dest] };
INSTRUCTION "CMOVBE.reg16.rm16"    (dest, src) { *16* dest := [(%CF || %ZF)           ? src : dest] };
INSTRUCTION "CMOVBE.reg32.reg32"   (dest, src) { *32* dest := [(%CF || %ZF)           ? src : dest] };
INSTRUCTION "CMOVBE.reg32.rm32"    (dest, src) { *32* dest := [(%CF || %ZF)           ? src : dest] };

INSTRUCTION "CMOVC.reg16.reg16"    (dest, src) { *16* dest := [(%CF = 1)              ? src : dest] };
INSTRUCTION "CMOVC.reg16.rm16"     (dest, src) { *16* dest := [(%CF = 1)              ? src : dest] };
INSTRUCTION "CMOVC.reg32.reg32"    (dest, src) { *32* dest := [(%CF = 1)              ? src : dest] };
INSTRUCTION "CMOVC.reg32.rm32"     (dest, src) { *32* dest := [(%CF = 1)              ? src : dest] };

INSTRUCTION "CMOVE.reg16.reg16"    (dest, src) { *16* dest := [(%ZF = 1)              ? src : dest] };
INSTRUCTION "CMOVE.reg16.rm16"     (dest, src) { *16* dest := [(%ZF = 1)              ? src : dest] };
INSTRUCTION "CMOVE.reg32.reg32"    (dest, src) { *32* dest := [(%ZF = 1)              ? src : dest] };
INSTRUCTION "CMOVE.reg32.rm32"     (dest, src) { *32* dest := [(%ZF = 1)              ? src : dest] };

INSTRUCTION "CMOVG.reg16.reg16"    (dest, src) { *16* dest := [(~%ZF && ~(%SF ^ %OF)) ? src : dest] };
INSTRUCTION "CMOVG.reg16.rm16"     (dest, src) { *16* dest := [(~%ZF && ~(%SF ^ %OF)) ? src : dest] };
INSTRUCTION "CMOVG.reg32.reg32"    (dest, src) { *32* dest := [(~%ZF && ~(%SF ^ %OF)) ? src : dest] };
INSTRUCTION "CMOVG.reg32.rm32"     (dest, src) { *32* dest := [(~%ZF && ~(%SF ^ %OF)) ? src : dest] };

INSTRUCTION "CMOVGE.reg16.reg16"   (dest, src) { *16* dest := [(~(%SF ^ %OF))         ? src : dest] };
INSTRUCTION "CMOVGE.reg16.rm16"    (dest, src) { *16* dest := [(~(%SF ^ %OF))         ? src : dest] };
INSTRUCTION "CMOVGE.reg32.reg32"   (dest, src) { *32* dest := [(~(%SF ^ %OF))         ? src : dest] };
INSTRUCTION "CMOVGE.reg32.rm32"    (dest, src) { *32* dest := [(~(%SF ^ %OF))         ? src : dest] };

INSTRUCTION "CMOVL.reg16.reg16"    (dest, src) { *16* dest := [(%SF ^ %OF)            ? src : dest] };
INSTRUCTION "CMOVL.reg16.rm16"     (dest, src) { *16* dest := [(%SF ^ %OF)            ? src : dest] };
INSTRUCTION "CMOVL.reg32.reg32"    (dest, src) { *32* dest := [(%SF ^ %OF)            ? src : dest] };
INSTRUCTION "CMOVL.reg32.rm32"     (dest, src) { *32* dest := [(%SF ^ %OF)            ? src : dest] };

INSTRUCTION "CMOVLE.reg16.reg16"   (dest, src) { *16* dest := [(%ZF || (%SF ^ %OF))   ? src : dest] };
INSTRUCTION "CMOVLE.reg16.rm16"    (dest, src) { *16* dest := [(%ZF || (%SF ^ %OF))   ? src : dest] };
INSTRUCTION "CMOVLE.reg32.reg32"   (dest, src) { *32* dest := [(%ZF || (%SF ^ %OF))   ? src : dest] };
INSTRUCTION "CMOVLE.reg32.rm32"    (dest, src) { *32* dest := [(%ZF || (%SF ^ %OF))   ? src : dest] };

INSTRUCTION "CMOVNA.reg16.reg16"   (dest, src) { *16* dest := [(%CF || %ZF)           ? src : dest] };
INSTRUCTION "CMOVNA.reg16.rm16"    (dest, src) { *16* dest := [(%CF || %ZF)           ? src : dest] };
INSTRUCTION "CMOVNA.reg32.reg32"   (dest, src) { *32* dest := [(%CF || %ZF)           ? src : dest] };
INSTRUCTION "CMOVNA.reg32.rm32"    (dest, src) { *32* dest := [(%CF || %ZF)           ? src : dest] };

INSTRUCTION "CMOVNAE.reg16.reg16"  (dest, src) { *16* dest := [(%CF = 1)              ? src : dest] };
INSTRUCTION "CMOVNAE.reg16.rm16"   (dest, src) { *16* dest := [(%CF = 1)              ? src : dest] };
INSTRUCTION "CMOVNAE.reg32.reg32"  (dest, src) { *32* dest := [(%CF = 1)              ? src : dest] };
INSTRUCTION "CMOVNAE.reg32.rm32"   (dest, src) { *32* dest := [(%CF = 1)              ? src : dest] };

INSTRUCTION "CMOVNB.reg16.reg16"   (dest, src) { *16* dest := [(%CF = 0)              ? src : dest] };
INSTRUCTION "CMOVNB.reg16.rm16"    (dest, src) { *16* dest := [(%CF = 0)              ? src : dest] };
INSTRUCTION "CMOVNB.reg32.reg32"   (dest, src) { *32* dest := [(%CF = 0)              ? src : dest] };
INSTRUCTION "CMOVNB.reg32.rm32"    (dest, src) { *32* dest := [(%CF = 0)              ? src : dest] };

INSTRUCTION "CMOVNBE.reg16.reg16"  (dest, src) { *16* dest := [(~%CF && ~%ZF)         ? src : dest] };
INSTRUCTION "CMOVNBE.reg16.rm16"   (dest, src) { *16* dest := [(~%CF && ~%ZF)         ? src : dest] };
INSTRUCTION "CMOVNBE.reg32.reg32"  (dest, src) { *32* dest := [(~%CF && ~%ZF)         ? src : dest] };
INSTRUCTION "CMOVNBE.reg32.rm32"   (dest, src) { *32* dest := [(~%CF && ~%ZF)         ? src : dest] };

INSTRUCTION "CMOVNC.reg16.reg16"   (dest, src) { *16* dest := [(%CF = 0)              ? src : dest] };
INSTRUCTION "CMOVNC.reg16.rm16"    (dest, src) { *16* dest := [(%CF = 0)              ? src : dest] };
INSTRUCTION "CMOVNC.reg32.reg32"   (dest, src) { *32* dest := [(%CF = 0)              ? src : dest] };
INSTRUCTION "CMOVNC.reg32.rm32"    (dest, src) { *32* dest := [(%CF = 0)              ? src : dest] };

INSTRUCTION "CMOVNE.reg16.reg16"   (dest, src) { *16* dest := [(%ZF = 0)              ? src : dest] };
INSTRUCTION "CMOVNE.reg16.rm16"    (dest, src) { *16* dest := [(%ZF = 0)              ? src : dest] };
INSTRUCTION "CMOVNE.reg32.reg32"   (dest, src) { *32* dest := [(%ZF = 0)              ? src : dest] };
INSTRUCTION "CMOVNE.reg32.rm32"    (dest, src) { *32* dest := [(%ZF = 0)              ? src : dest] };

INSTRUCTION "CMOVNG.reg16.reg16"   (dest, src) { *16* dest := [(%ZF || (%SF ^ %OF))   ? src : dest] };
INSTRUCTION "CMOVNG.reg16.rm16"    (dest, src) { *16* dest := [(%ZF || (%SF ^ %OF))   ? src : dest] };
INSTRUCTION "CMOVNG.reg32.reg32"   (dest, src) { *32* dest := [(%ZF || (%SF ^ %OF))   ? src : dest] };
INSTRUCTION "CMOVNG.reg32.rm32"    (dest, src) { *32* dest := [(%ZF || (%SF ^ %OF))   ? src : dest] };

INSTRUCTION "CMOVNGE.reg16.reg16"  (dest, src) { *16* dest := [(~%ZF && ~(%SF ^ %OF)) ? src : dest] };
INSTRUCTION "CMOVNGE.reg16.rm16"   (dest, src) { *16* dest := [(~%ZF && ~(%SF ^ %OF)) ? src : dest] };
INSTRUCTION "CMOVNGE.reg32.reg32"  (dest, src) { *32* dest := [(~%ZF && ~(%SF ^ %OF)) ? src : dest] };
INSTRUCTION "CMOVNGE.reg32.rm32"   (dest, src) { *32* dest := [(~%ZF && ~(%SF ^ %OF)) ? src : dest] };

INSTRUCTION "CMOVNL.reg16.reg16"   (dest, src) { *16* dest := [(~(%SF ^ %OF))         ? src : dest] };
INSTRUCTION "CMOVNL.reg16.rm16"    (dest, src) { *16* dest := [(~(%SF ^ %OF))         ? src : dest] };
INSTRUCTION "CMOVNL.reg32.reg32"   (dest, src) { *32* dest := [(~(%SF ^ %OF))         ? src : dest] };
INSTRUCTION "CMOVNL.reg32.rm32"    (dest, src) { *32* dest := [(~(%SF ^ %OF))         ? src : dest] };

INSTRUCTION "CMOVNLE.reg16.reg16"  (dest, src) { *16* dest := [(~%ZF && ~(%SF ^ %OF)) ? src : dest] };
INSTRUCTION "CMOVNLE.reg16.rm16"   (dest, src) { *16* dest := [(~%ZF && ~(%SF ^ %OF)) ? src : dest] };
INSTRUCTION "CMOVNLE.reg32.reg32"  (dest, src) { *32* dest := [(~%ZF && ~(%SF ^ %OF)) ? src : dest] };
INSTRUCTION "CMOVNLE.reg32.rm32"   (dest, src) { *32* dest := [(~%ZF && ~(%SF ^ %OF)) ? src : dest] };

INSTRUCTION "CMOVNO.reg16.reg16"   (dest, src) { *16* dest := [(~%OF)                 ? src : dest] };
INSTRUCTION "CMOVNO.reg16.rm16"    (dest, src) { *16* dest := [(~%OF)                 ? src : dest] };
INSTRUCTION "CMOVNO.reg32.reg32"   (dest, src) { *32* dest := [(~%OF)                 ? src : dest] };
INSTRUCTION "CMOVNO.reg32.rm32"    (dest, src) { *32* dest := [(~%OF)                 ? src : dest] };

INSTRUCTION "CMOVNP.reg16.reg16"   (dest, src) { *16* dest := [(~%PF)                 ? src : dest] };
INSTRUCTION "CMOVNP.reg16.rm16"    (dest, src) { *16* dest := [(~%PF)                 ? src : dest] };
INSTRUCTION "CMOVNP.reg32.reg32"   (dest, src) { *32* dest := [(~%PF)                 ? src : dest] };
INSTRUCTION "CMOVNP.reg32.rm32"    (dest, src) { *32* dest := [(~%PF)                 ? src : dest] };

INSTRUCTION "CMOVNS.reg16.reg16"   (dest, src) { *16* dest := [(~%SF)                 ? src : dest] };
INSTRUCTION "CMOVNS.reg16.rm16"    (dest, src) { *16* dest := [(~%SF)                 ? src : dest] };
INSTRUCTION "CMOVNS.reg32.reg32"   (dest, src) { *32* dest := [(~%SF)                 ? src : dest] };
INSTRUCTION "CMOVNS.reg32.rm32"    (dest, src) { *32* dest := [(~%SF)                 ? src : dest] };

INSTRUCTION "CMOVNZ.reg16.reg16"   (dest, src) { *16* dest := [(~%ZF)                 ? src : dest] };
INSTRUCTION "CMOVNZ.reg16.rm16"    (dest, src) { *16* dest := [(~%ZF)                 ? src : dest] };
INSTRUCTION "CMOVNZ.reg32.reg32"   (dest, src) { *32* dest := [(~%ZF)                 ? src : dest] };
INSTRUCTION "CMOVNZ.reg32.rm32"    (dest, src) { *32* dest := [(~%ZF)                 ? src : dest] };

INSTRUCTION "CMOVO.reg16.reg16"    (dest, src) { *16* dest := [(%OF)                  ? src : dest] };
INSTRUCTION "CMOVO.reg16.rm16"     (dest, src) { *16* dest := [(%OF)                  ? src : dest] };
INSTRUCTION "CMOVO.reg32.reg32"    (dest, src) { *32* dest := [(%OF)                  ? src : dest] };
INSTRUCTION "CMOVO.reg32.rm32"     (dest, src) { *32* dest := [(%OF)                  ? src : dest] };

INSTRUCTION "CMOVP.reg16.reg16"    (dest, src) { *16* dest := [(%PF)                  ? src : dest] };
INSTRUCTION "CMOVP.reg16.rm16"     (dest, src) { *16* dest := [(%PF)                  ? src : dest] };
INSTRUCTION "CMOVP.reg32.reg32"    (dest, src) { *32* dest := [(%PF)                  ? src : dest] };
INSTRUCTION "CMOVP.reg32.rm32"     (dest, src) { *32* dest := [(%PF)                  ? src : dest] };

INSTRUCTION "CMOVS.reg16.reg16"    (dest, src) { *16* dest := [(%SF)                  ? src : dest] };
INSTRUCTION "CMOVS.reg16.rm16"     (dest, src) { *16* dest := [(%SF)                  ? src : dest] };
INSTRUCTION "CMOVS.reg32.reg32"    (dest, src) { *32* dest := [(%SF)                  ? src : dest] };
INSTRUCTION "CMOVS.reg32.rm32"     (dest, src) { *32* dest := [(%SF)                  ? src : dest] };

INSTRUCTION "CMOVZ.reg16.reg16"    (dest, src) { *16* dest := [(%ZF)                  ? src : dest] };
INSTRUCTION "CMOVZ.reg16.rm16"     (dest, src) { *16* dest := [(%ZF)                  ? src : dest] };
INSTRUCTION "CMOVZ.reg32.reg32"    (dest, src) { *32* dest := [(%ZF)                  ? src : dest] };
INSTRUCTION "CMOVZ.reg32.rm32"     (dest, src) { *32* dest := [(%ZF)                  ? src : dest] };


# CMP
INSTRUCTION "CMP.reg8.imm8" (lhs, rhs) {
    *8* tmpb := lhs - rhs
    SUBFLAGS8(lhs, rhs, tmpb)
};

INSTRUCTION "CMP.reg8.reg8" (lhs, rhs) {
    *8* tmpb := lhs - rhs
    SUBFLAGS8(lhs, rhs, tmpb)
};

INSTRUCTION "CMP.reg8.rm8" (lhs, rhs) {
    *8* tmpb := lhs - rhs
    SUBFLAGS8(lhs, rhs, tmpb)
};

INSTRUCTION "CMP.reg16.imm16" (lhs, rhs) {
    *16* tmph := lhs - rhs
    SUBFLAGS16(lhs, rhs, tmph)
};

INSTRUCTION "CMP.reg16.reg16" (lhs, rhs) {
    *16* tmph := lhs - rhs
    SUBFLAGS16(lhs, rhs, tmph)
};

INSTRUCTION "CMP.reg16.rm16" (lhs, rhs) {
    *16* tmph := lhs - rhs
    SUBFLAGS16(lhs, rhs, tmph)
};

INSTRUCTION "CMP.reg32.imm8" (lhs, rhs) {
    *32* tmprhs  := sgnex(8, 32, rhs)
    *32* tmp1 := lhs - tmprhs
    SUBFLAGS32(lhs, tmprhs, tmp1)
};

INSTRUCTION "CMP.reg32.imm32" (lhs, rhs) {
    *32* tmp1 := lhs - rhs
    SUBFLAGS32(lhs, rhs, tmp1)
};

INSTRUCTION "CMP.reg32.reg32" (lhs, rhs) {
    *32* tmp1 := lhs - rhs
    SUBFLAGS32(lhs, rhs, tmp1)
};

INSTRUCTION "CMP.reg32.rm32" (lhs, rhs) {
    *32* tmp1 := lhs - rhs
    SUBFLAGS32(lhs, rhs, tmp1)
};

INSTRUCTION "CMP.reg64.rm64" (lhs, rhs) {
    *64* tmp1 := lhs - rhs
    SUBFLAGS64(lhs, rhs, tmp1)
};

INSTRUCTION "CMP.rm8.imm8" (lhs, rhs) {
    *8* tmpb := lhs - rhs
    SUBFLAGS8(lhs, rhs, tmpb)
};

INSTRUCTION "CMP.rm8.reg8" (lhs, rhs) {
    *8* tmpb := lhs - rhs
    SUBFLAGS8(lhs, rhs, tmpb)
};

INSTRUCTION "CMP.rm16.imm8" (lhs, rhs) {
    *16* tmprhs := sgnex(8, 16, rhs)
    *16* tmph := lhs - tmprhs
    SUBFLAGS16(lhs, tmprhs, tmph)
};

INSTRUCTION "CMP.rm16.imm16" (lhs, rhs) {
    *16* tmph := lhs - rhs
    SUBFLAGS16(lhs, rhs, tmph)
};

INSTRUCTION "CMP.rm16.reg16" (lhs, rhs) {
    *16* tmph := lhs - rhs
    SUBFLAGS16(lhs, rhs, tmph)
};

INSTRUCTION "CMP.rm32.imm8" (lhs, rhs) {
    *32* tmprhs := sgnex(8, 32, rhs)
    *32* tmp1 := lhs - tmprhs
    SUBFLAGS32(lhs, tmprhs, tmp1)
};

INSTRUCTION "CMP.rm32.imm32" (lhs, rhs) {
    *32* tmp1 := lhs - rhs
    SUBFLAGS32(lhs, rhs, tmp1)
};

INSTRUCTION "CMP.rm32.reg32" (lhs, rhs) {
    *32* tmp1 := lhs - rhs
    SUBFLAGS32(lhs, rhs, tmp1)
};

INSTRUCTION "CMP.rm64.imm8" (lhs, rhs) {
    *64* tmprhs := sgnex(8, 64, rhs)
    *64* tmp1 := lhs - tmprhs
    SUBFLAGS64(lhs, tmprhs, tmp1)
};

INSTRUCTION "CMP.rm64.imm32" (lhs, rhs) {
    *64* tmprhs := sgnex(32, 64, rhs)
    *64* tmp1 := lhs - tmprhs
    SUBFLAGS64(lhs, tmprhs, tmp1)
};

INSTRUCTION "CMP.rm64.reg64" (lhs, rhs) {
    *64* tmp1 := lhs - rhs
    SUBFLAGS64(lhs, rhs, tmp1)
};


# CMPXCHG
INSTRUCTION "CMPXCHG.reg8.reg8" (dest, src) {
    *1* %ZF := %al = dest
    *8* %ZF = 1 => dest := src
    *8* %ZF = 0 => %al := dest
};

INSTRUCTION "CMPXCHG.reg16.reg16" (dest, src) {
    *1* %ZF := %ax = dest
    *16* %ZF = 1 => dest := src
    *16* %ZF = 0 => %ax := dest
};

INSTRUCTION "CMPXCHG.reg32.reg32" (dest, src) {
    *1* %ZF := %eax = dest
    *32* %ZF = 1 => dest := src
    *32* %ZF = 0 => %eax := dest
};

INSTRUCTION "CMPXCHG.rm32.reg32" (dest, src) {
    *1* %ZF := %eax = dest
    *32* %ZF = 1 => dest := src
    *32* %ZF = 0 => %eax := dest
};


# CMPXCHG8B
INSTRUCTION "CMPXCHG8B.rm64" (dest) {
    *1* %ZF := (dest@[0:31] = %eax) && (dest@[32:63] = %edx)
    *64* %ZF = 1 => dest := %ebx | %ecx << 32
    *32* %ZF = 0 => %eax := dest@[0:31]
    *32* %ZF = 0 => %edx := dest@[32:63]
};


# CWD
INSTRUCTION "CWD" () {
    *16* %dx := [%ax@[15:15] = 0 ? 0:0xFFFF]
};


# CWDE
INSTRUCTION "CWDE" () {
    *32* %eax := sgnex(16, 32, %ax)
};


# DEC
INSTRUCTION "DEC.reg8" (val) {
    *8* tmpb := val
    *8* val := val - 1
    INCDECFLAGS8(val)
};

INSTRUCTION "DEC.reg16" (val) {
    *16* tmph := val
    *16* val := val - 1
    INCDECFLAGS16(val)
};

INSTRUCTION "DEC.reg32" (val) {
    *32* tmp1 := val
    *32* val := val - 1
    INCDECFLAGS32(val)
};

INSTRUCTION "DEC.rm8" (val) {
    *8* tmpb := val
    *8* val := val - 1
    INCDECFLAGS8(val)
};

INSTRUCTION "DEC.rm16" (val) {
    *16* tmph := val
    *16* val := val - 1
    INCDECFLAGS16(val)
};

INSTRUCTION "DEC.rm32" (val) {
    *32* tmp1 := val
    *32* val := val - 1
    INCDECFLAGS32(val)
};

INSTRUCTION "DEC.rm64" (val) {
    *64* tmp1 := val
    *64* val := val - 1
    INCDECFLAGS64(val)
};


# DIV (unsigned divide)
INSTRUCTION "DIV.reg8" (divisor) {
    *16* tmph := %ax
    *8*  %al := tmph / divisor
    *8*  %ah := tmph % divisor
};

INSTRUCTION "DIV.rm8" (divisor) {
    *16* tmph := %ax
    *8*  %al := tmph / divisor
    *8*  %ah := tmph % divisor
};

INSTRUCTION "DIV.reg16" (divisor) {
    *32* tmp1 := (zfill(16, 32, %dx) << 16) | zfill(16, 32, %ax)
    *16*  %ax := tmp1 / divisor
    *16*  %dx := tmp1 % divisor
};

INSTRUCTION "DIV.reg32" (divisor) {
    *64* tmp1 := (zfill(32, 64, %edx) << 32) | zfill(32, 64, %eax)
    *32* %eax := tmp1 / divisor
    *32* %edx := tmp1 % divisor
};

INSTRUCTION "DIV.rm8" (divisor) {
    *16* tmph := %ax
    *8*  %al := tmph / divisor
    *8*  %ah := tmph % divisor
};

INSTRUCTION "DIV.rm16" (divisor) {
    *32* tmp1 := (zfill(16, 32, %dx) << 16) | zfill(16, 32, %ax)
    *16*  %ax := tmp1 / divisor
    *16*  %dx := tmp1 % divisor
};

INSTRUCTION "DIV.rm32" (divisor) {
    *64* tmp1 := (zfill(32, 64, %edx) << 32) | zfill(32, 64, %eax)
    *32* %eax := tmp1 / divisor
    *32* %edx := tmp1 % divisor
};


# ENTER
INSTRUCTION "ENTER.imm32.imm32" (allocSz, nstLevel) {
    *32* %esp := %esp - 4
    *32* m[%esp] := %ebp
    *32* tmpframe := %esp

    # Note: Boomerang does not support for loops at present so we assume 0 <= nstLevel <= 1
    # if (nstLevel > 1) for (i=1 to nstLvel - 1) { %ebp -= 4; PUSH m[%ebp]; }
    *32* nstLevel>=1 => %esp := %esp - 4
    *32* nstLevel>=1 => m[%esp] := tmpframe

    *32* %ebp := tmpframe
    *32* %esp := %esp - allocSz
};


# FABS
INSTRUCTION "FABS" () {
    *1* %C1 := 0
    *f80* %st := fabs(%st)
};


# FADD
INSTRUCTION "FADD" () {
    *f80* %st1 := %st1 +f %st
    FPOP
};

INSTRUCTION "FADD.reg80" (val) {
    *f80* %st := %st +f val
};

INSTRUCTION "FADD.rm32" (val) {
    *f80* %st := %st +f fsize(32, 80, val)
};

INSTRUCTION "FADD.rm64" (val) {
    *f80* %st := %st +f fsize(64, 80, val)
};

INSTRUCTION "FADD.reg80.reg80" (dest, src) {
    *f80* dest := dest +f src
};


# FADDP
INSTRUCTION "FADDP" () {
    *f80* %st1 := %st1 +f %st
    FPOP
};

INSTRUCTION "FADDP.reg80" (val) {
    *f80* val := val +f %st
    FPOP
};


# FCHS
INSTRUCTION "FCHS" () {
    *f80* %st := 0 -f %st
    *1* %C1 := 0
};


# FCMOVcc
# Note the flags (C[0-3]) are modified, but we don't model this yet.
INSTRUCTION "FCMOVB.reg80.reg80"   (dest, src) {  *f80*   %CF = 1      =>  dest := src };
INSTRUCTION "FCMOVBE.reg80.reg80"  (dest, src) {  *f80*   %CF | %ZF    =>  dest := src };
INSTRUCTION "FCMOVE.reg80.reg80"   (dest, src) {  *f80*   %ZF = 1      =>  dest := src };
INSTRUCTION "FCMOVU.reg80.reg80"   (dest, src) {  *f80*   %PF = 1      =>  dest := src };
INSTRUCTION "FCMOVNB.reg80.reg80"  (dest, src) {  *f80*   %CF = 0      =>  dest := src };
INSTRUCTION "FCMOVNBE.reg80.reg80" (dest, src) {  *f80*   ~(%CF & %ZF) =>  dest := src };
INSTRUCTION "FCMOVNE.reg80.reg80"  (dest, src) {  *f80*   %ZF = 0      =>  dest := src };
INSTRUCTION "FCMOVNU.reg80.reg80"  (dest, src) {  *f80*   %PF = 0      =>  dest := src };

# FCOM
INSTRUCTION "FCOM" () {
    *f80* tmpD1 := %st
    *f80* tmpD2 := %st1
    *f80* tmpD := %st -f %st1
    SETFFLAGS(tmpD1, tmpD2)
};

INSTRUCTION "FCOM.rm32" (val) {
    *f80* tmpD1 := %st
    *f80* tmpD2 := fsize(32, 80, val)
    *f80* tmpD  := %st -f fsize(32, 80, val)
    SETFFLAGS(tmpD1, tmpD2)
};

INSTRUCTION "FCOM.rm64" (val) {
    *f80* tmpD1 := %st
    *f80* tmpD2 := fsize(64, 80, val)
    *f80* tmpD  := %st -f fsize(64, 80, val)
    SETFFLAGS(tmpD1, tmpD2)
};


# FCOMP
INSTRUCTION "FCOMP" () {
    *f80* tmpD1 := %st
    *f80* tmpD2 := %st1
    *f80* tmpD := %st -f %st1
    FPOP
    SETFFLAGS(tmpD1, tmpD2)
};

INSTRUCTION "FCOMP.rm32" (val) {
    *f80* tmpD1 := %st
    *f80* tmpD2 := fsize(32, 80, val)
    *f80* tmpD  := %st -f fsize(32, 80, val)
    FPOP
    SETFFLAGS(tmpD1, tmpD2)
};

INSTRUCTION "FCOMP.rm64" (val) {
    *f80* tmpD1 := %st
    *f80* tmpD2 := fsize(64, 80, val)
    *f80* tmpD  := %st -f fsize(64, 80, val)
    FPOP
    SETFFLAGS(tmpD1, tmpD2)
};


# FCOMPP
INSTRUCTION "FCOMPP" () {
    *f80* tmpD1 := %st
    *f80* tmpD2 := %st1
    *f80* tmpD := %st -f %st1
    FPOP
    FPOP
    SETFFLAGS(tmpD1, tmpD2)
};


# FCOS
INSTRUCTION "FCOS" () {
    *f80* %st := cos(%st)
};


# FDECSTP
INSTRUCTION "FDECSTP" () {
    FPOP
    *1* %C1 := 0
};


# FDIV
INSTRUCTION "FDIV.reg80" (val) {
    *f80* %st := %st /f val
};

INSTRUCTION "FDIV.reg80.reg80" (dest, src) {
    *f80* dest := dest /f src
};

INSTRUCTION "FDIV.rm32" (val) {
    *f80* %st := %st /f fsize(32, 80, val)
};

INSTRUCTION "FDIV.rm64" (val) {
    *f80* %st := %st /f fsize(64, 80, val)
};


# FDIVP
INSTRUCTION "FDIVP.reg80" (val) {
    *f80* val := val /f %st
    FPOP
};

INSTRUCTION "FDIVP.reg80.reg80" (dest, src) {
    *f80* dest := dest /f src
    FPOP
};


# FDIVR
INSTRUCTION "FDIVR.reg80" (val) {
    *f80* %st := val /f %st
};

INSTRUCTION "FDIVR.reg80.reg80" (dest, src) {
    *f80* dest := src /f dest
};

INSTRUCTION "FDIVR.rm32" (val) {
    *f80* %st := fsize(32, 80, val) /f %st
};

INSTRUCTION "FDIVR.rm64" (val) {
    *f80* %st := fsize(64, 80, val) /f %st
};


# FDIVRP
INSTRUCTION "FDIVRP.reg80" (val) {
    *f80* val := %st /f val
    FPOP
};


# FILD
INSTRUCTION "FILD.rm16" (val) {
    FPUSH
    *f80* %st := itof(16, 80, val)
};

INSTRUCTION "FILD.rm32" (val) {
    FPUSH
    *f80* %st := itof(32, 80, val)
};

INSTRUCTION "FILD.rm64" (val) {
    FPUSH
    *f80* %st := itof(64, 80, val)
};


# FIMUL
INSTRUCTION "FIMUL.rm16" (val) {
    *f80* %st := %st *f itof(16, 80, val)
};

INSTRUCTION "FIMUL.rm32" (val) {
    *f80* %st := %st *f itof(32, 80, val)
};


# FINT
INSTRUCTION "FINIT" () {
    *16* %fcw := 0x037F
    *16* %fsw := 0
    *1*  %C0 := 0
    *1*  %C1 := 0
    *1*  %C2 := 0
    *1*  %C3 := 0
};


# FIST
INSTRUCTION "FIST.rm16" (dest) {
    *16* dest := ftoi(80, 16, %st)
};

INSTRUCTION "FIST.rm32" (dest) {
    *32* dest := ftoi(80, 32, %st)
};


# FISTP
INSTRUCTION "FISTP.rm16" (dest) {
    *16* dest := ftoi(80, 16, %st)
    FPOP
};

INSTRUCTION "FISTP.rm32" (dest) {
    *32* dest := ftoi(80, 32, %st)
    FPOP
};

INSTRUCTION "FISTP.rm64" (dest) {
    *64* dest := ftoi(80, 64, %st)
    FPOP
};


# FISUB
INSTRUCTION "FISUB.rm16" (val) {
    *f80* %st := %st - itof(16, 80, val)
};


# FISUBR
INSTRUCTION "FISUBR.rm16" (val) {
    *f80* %st := itof(16, 80, val) - %st
};


# FLD
INSTRUCTION "FLD.reg80" (val) {
    *f80* tmpD1 := val
    FPUSH
    *f80* %st := tmpD1
};

INSTRUCTION "FLD.rm32" (val) {
    FPUSH
    *f80* %st := fsize(32, 80, val)
};

INSTRUCTION "FLD.rm64" (val) {
    FPUSH
    *f80* %st := fsize(64, 80, val)
};

INSTRUCTION "FLD.rm80" (val) {
    FPUSH
    *f80* %st := val
};


# FLD1
INSTRUCTION "FLD1" () {
    FPUSH
    *f80* %st := 1.0
};


# FLDCW
INSTRUCTION "FLDCW.rm16" (val) {
    *16* %fcw := val
};


# FLDPI
INSTRUCTION "FLDPI" () {
    FPUSH
    *f80* %st := 3.141592653589793
};


# FLDZ
INSTRUCTION "FLDZ" () {
    FPUSH
    *f80* %st := 0.0
};


# FMUL
INSTRUCTION "FMUL.reg80" (val) {
    *f80* %st := %st *f val
};

INSTRUCTION "FMUL.reg80.reg80" (dest, src) {
    *f80* dest := dest *f src
};

INSTRUCTION "FMUL.rm32" (val) {
    *f80* %st := %st *f fsize(32, 80, val)
};

INSTRUCTION "FMUL.rm64" (val) {
    *f80* %st := %st *f fsize(64, 80, val)
};


# FMULP
INSTRUCTION "FMULP.reg80" (val) {
    *f80* val := val *f %st
    FPOP
};


# FNCLEX
INSTRUCTION "FNCLEX" () {
    *8* %fsw@[0:7] := 0
    *1* %fsw@[15:15] := 0
};


# FNINIT
INSTRUCTION "FNINIT" () {
    *16* %fcw := 0x037F
    *16* %fsw := 0
    *1*  %C0 := 0
    *1*  %C1 := 0
    *1*  %C2 := 0
    *1*  %C3 := 0
};


# FNOP
INSTRUCTION "FNOP" () {
    _
};


# FNSTCW
INSTRUCTION "FNSTCW.rm16" (dest) {
    *16* dest := %fcw
};


# FNSTSW
INSTRUCTION "FNSTSW.reg16" (dest) { # fnstsw.ax
    *8* %ah := %fflags
    *8* %al := 0     # Just so we know it's changed
};


INSTRUCTION "FNSTSW.rm16" (dest) {
    *16* dest := 0
    *1* dest@[14:14] := %C3
    *1* dest@[10:10] := %C2
    *1* dest@[ 9: 9] := %C1
    *1* dest@[ 8: 8] := %C0
};


# FRNDINT
INSTRUCTION "FRNDINT" () {
    *f80* %st := fround(80, 80, %st)
};


# FSIN
INSTRUCTION "FSIN" () {
    *f80* %st := sin(%st)
};


# FSINCOS
INSTRUCTION "FSINCOS" () {
    FPUSH
    *f80* %st  := cos(%st1)
    *f80* %st1 := sin(%st1)
};


# FSQRT
INSTRUCTION "FSQRT" () {
    *f80* %st := sqrt(%st)
};


# FST
INSTRUCTION "FST.rm32" (dest) {
    *32* dest := fsize(80, 32, %st)
};

INSTRUCTION "FST.rm64" (dest) {
    *64* dest := fsize(80, 64, %st)
};


# FSTP
INSTRUCTION "FSTP.reg80" (dest) {
    *f80* dest := %st
    FPOP
};

INSTRUCTION "FSTP.rm32" (dest) {
    *32* dest := fsize(80,32,%st)
    FPOP
};

INSTRUCTION "FSTP.rm64" (dest) {
    *64* dest := fsize(80,64,%st)
    FPOP
};

INSTRUCTION "FSTP.rm80" (dest) {
    *f80* dest := %st
    FPOP
};


# FSTSW
INSTRUCTION "FSTSW.reg16" (dest) {
    *16* dest := 0
    *1* dest@[14:14] := %C3
    *1* dest@[10:10] := %C2
    *1* dest@[ 9: 9] := %C1
    *1* dest@[ 8: 8] := %C0
};

INSTRUCTION "FSTSW.rm16" (dest) {
    *16* dest := 0
    *1* dest@[14:14] := %C3
    *1* dest@[10:10] := %C2
    *1* dest@[ 9: 9] := %C1
    *1* dest@[ 8: 8] := %C0
};


# FSUB
INSTRUCTION "FSUB.reg80" (val) {
    *f80* %st := %st -f val
};


INSTRUCTION "FSUB.reg80.reg80" (dest, src) {
    *f80* dest := dest -f src
};

INSTRUCTION "FSUB.rm32" (val) {
    *f80* %st := %st -f fsize(32, 80, val)
};

INSTRUCTION "FSUB.rm64" (val) {
    *f80* %st := %st -f fsize(64, 80, val)
};


# FSUBP
INSTRUCTION "FSUBP.reg80" (val) {
    *f80* val := %st -f val
    FPOP
};


# FSUBR
INSTRUCTION "FSUBR.reg80" (val) {
    *f80* %st := val -f %st
};

INSTRUCTION "FSUBR.reg80.reg80" (dest, src) {
    *f80* dest := src -f dest
};

INSTRUCTION "FSUBR.rm32" (val) {
    *f80* %st := fsize(32, 80, val) -f %st
};

INSTRUCTION "FSUBR.rm64" (val) {
    *f80* %st := fsize(64, 80, val) -f %st
};


# FSUBRP
INSTRUCTION "FSUBRP.reg80" (val) {
    *f80* val := val -f %st
    FPOP
};


# FUCOM
INSTRUCTION "FUCOM" () {
    *f80* tmpD := %st -f %st1
    SETFFLAGS(%st, %st1)
};

INSTRUCTION "FUCOM.reg80" (val) {
    *f80* tmpD := %st -f val
    SETFFLAGS(%st, val)
};


# FUCOMI
INSTRUCTION "FUCOMI.reg80" (reg) {
    SUBFLAGSFL(%st, reg)
};


# FUCOMIP
INSTRUCTION "FUCOMIP.reg80" (reg) {
    SUBFLAGSFL(%st, reg)
    FPOP
};


# FUCOMP
INSTRUCTION "FUCOMP" () {
    *f80* tmpD1 := %st
    *f80* tmpD2 := %st1
    *f80* tmpD  := %st -f %st1
    FPOP
    SETFFLAGS(tmpD1, tmpD2)
};

INSTRUCTION "FUCOMP.reg80" (val) {
    *f80* tmpD1 := %st
    *f80* tmpD2 := val
    *f80* tmpD  := %st -f val
    FPOP
    SETFFLAGS(tmpD1, tmpD2)
};


# FUCOMPP
INSTRUCTION "FUCOMPP" () {
    *f80* tmpD1 := %st
    *f80* tmpD2 := %st1
    *f80* tmpD  := %st -f %st1
    FPOP
    FPOP
    SETFFLAGS(tmpD1, tmpD2)
};


# FXCH
INSTRUCTION "FXCH.reg80" (i) {
    *f80* tmpD := %st
    *f80* %st := i
    *f80* i := tmpD
};

INSTRUCTION "FXCH.reg80.reg80" (i, j) {
    *f80* tmpD := j
    *f80* j := i
    *f80* i := tmpD
};


# IDIV
INSTRUCTION "IDIV.reg8" (divisor) {
    *16* tmph := %ax
    *8* %al := tmph /! divisor
    *8* %ah := tmph %! divisor
};

INSTRUCTION "IDIV.reg16" (divisor) {
    *32* tmpd := (%dx << 16) | %ax
    *16* %ax := tmpd /! divisor
    *16* %dx := tmpd %! divisor
};

INSTRUCTION "IDIV.reg32" (divisor) {
    *64* tmp1 := (%edx << 32) | %eax
    *32* %eax := tmp1 /! divisor
    *32* %edx := tmp1 %! divisor
};

INSTRUCTION "IDIV.rm8" (divisor) {
    *16* tmph := %ax
    *8* %al := tmph /! divisor
    *8* %ah := tmph %! divisor
};

INSTRUCTION "IDIV.rm16" (divisor) {
    *32* tmpd := (%dx << 16) | %ax
    *16* %ax := tmpd /! divisor
    *16* %dx := tmpd %! divisor
};

INSTRUCTION "IDIV.rm32" (divisor) {
    *64* tmp1 := (%edx << 32) | %eax
    *32* %eax := tmp1 /! divisor
    *32* %edx := tmp1 %! divisor
};


# IMUL
INSTRUCTION "IMUL.reg8" (val) {
    *16* tmph := %al *! val
    *16* %ax := tmph
    IMULTFLAGS8(tmph)
};

INSTRUCTION "IMUL.reg16" (val) {
    *32* tmp1 := %al *! val
    *16* %ax := tmp1@[0:15]
    *16* %dx := tmp1@[16:31]
    IMULTFLAGS16(tmp1)
};

INSTRUCTION "IMUL.reg16.reg16" (dest, src) {
    *16* dest := dest *! src
    IMULTFLAGS16(dest)
};

INSTRUCTION "IMUL.reg16.reg16.imm16" (dest, src1, src2) {
    *16* dest := src1 *! src2
    IMULTFLAGS16(dest)
};

INSTRUCTION "IMUL.reg16.rm16" (dest, src) {
    *16* dest := dest *! src
    IMULTFLAGS16(dest)
};

INSTRUCTION "IMUL.reg16.rm16.imm8" (dest, src1, src2) {
    *16* dest := src1 *! sgnex(8, 16, src2)
    IMULTFLAGS16(dest)
};

INSTRUCTION "IMUL.reg16.rm16.imm16" (dest, src1, src2) {
    *16* dest := src1 *! src2
    IMULTFLAGS16(dest)
};

INSTRUCTION "IMUL.reg32" (val) {
    *64* tmpresult := %eax *! val
    *32* %edx := truncu(64, 32, tmpresult) >> 32
    *32* %eax := truncu(64, 32, tmpresult)
    IMULTFLAGS32(tmpresult)
};

INSTRUCTION "IMUL.reg32.reg32" (dest, src) {
    *32* dest := dest *! src
    IMULTFLAGS32(dest)
};

INSTRUCTION "IMUL.reg32.reg32.imm32" (dest, src1, src2) {
    *32* dest := src1 *! src2
    IMULTFLAGS32(dest)
};

INSTRUCTION "IMUL.reg32.rm32" (dest, src) {
    *32* dest := dest *! src
    IMULTFLAGS32(dest)
};

INSTRUCTION "IMUL.reg32.rm32.imm8" (dest, src1, src2) {
    *32* dest := src1 *! sgnex(8, 32, src2)
    IMULTFLAGS32(dest)
};

INSTRUCTION "IMUL.reg32.rm32.imm32" (dest, src1, src2) {
    *32* dest := src1 *! src2
    IMULTFLAGS32(dest)
};

INSTRUCTION "IMUL.rm8" (val) {
    *16* tmpresult := %al *! val
    *16* %ax := tmpresult
    IMULTFLAGS8(tmpresult)
};

INSTRUCTION "IMUL.rm16" (val) {
    *32* tmpresult := %ax *! val
    *16* %dx := truncu(32, 16, tmpresult) >> 16
    *16* %ax := truncu(32, 16, tmpresult)
    IMULTFLAGS16(tmpresult)
};

INSTRUCTION "IMUL.rm32" (val) {
    *64* tmpresult := %eax *! val
    *32* %edx := truncu(64, 32, tmpresult) >> 32
    *32* %eax := truncu(64, 32, tmpresult)
    IMULTFLAGS32(tmpresult)
};


# INC
INSTRUCTION "INC.reg8" (val) {
    *8* tmpb := val
    *8* val := val + 1
    INCDECFLAGS8(val)
};

INSTRUCTION "INC.reg16" (val) {
    *16* tmph := val
    *16* val := val + 1
    INCDECFLAGS16(val)
};

INSTRUCTION "INC.reg32" (val) {
    *32* tmp1 := val
    *32* val := val + 1
    INCDECFLAGS32(val)
};

INSTRUCTION "INC.rm8" (val) {
    *8* tmpb := val
    *8* val := val + 1
    INCDECFLAGS8(val)
};

INSTRUCTION "INC.rm16" (val) {
    *16* tmph := val
    *16* val := val + 1
    INCDECFLAGS16(val)
};

INSTRUCTION "INC.rm32" (val) {
    *32* tmp1 := val
    *32* val := val + 1
    INCDECFLAGS32(val)
};

INSTRUCTION "INC.rm64" (val) {
    *64* tmp1 := val
    *64* val := val + 1
    INCDECFLAGS64(val)
};


# INT
INSTRUCTION "INT.imm8" (n) {
    _
};

INSTRUCTION "INT.imm16" (n) {
    _
};

INSTRUCTION "INT.imm32" (n) {
    _
};


# INT1
INSTRUCTION "INT1" () {
    _
};


# INT3
INSTRUCTION "INT3" () {
    _
};

# INTO
INSTRUCTION "INTO" () {
    _
};


# IRET
INSTRUCTION "IRET" () {
    ret
};


# IRETD
INSTRUCTION "IRETD" () {
    ret
};


# Jcc
INSTRUCTION "JA.imm16"    (dest) { ~%CF & ~%ZF            => goto dest };
INSTRUCTION "JA.imm32"    (dest) { ~%CF & ~%ZF            => goto dest };
INSTRUCTION "JAE.imm16"   (dest) { %CF = 0                => goto dest };
INSTRUCTION "JAE.imm32"   (dest) { %CF = 0                => goto dest };
INSTRUCTION "JB.imm16"    (dest) { %CF = 1                => goto dest };
INSTRUCTION "JB.imm32"    (dest) { %CF = 1                => goto dest };
INSTRUCTION "JBE.imm16"   (dest) { %CF | %ZF              => goto dest };
INSTRUCTION "JBE.imm32"   (dest) { %CF | %ZF              => goto dest };
INSTRUCTION "JC.imm16"    (dest) { %CF = 1                => goto dest };
INSTRUCTION "JC.imm32"    (dest) { %CF = 1                => goto dest };
INSTRUCTION "JCXZ.imm16"  (dest) { %cx = 0                => goto dest };
INSTRUCTION "JCXZ.imm32"  (dest) { %cx = 0                => goto dest };
INSTRUCTION "JE.imm16"    (dest) { %ZF = 1                => goto dest };
INSTRUCTION "JE.imm32"    (dest) { %ZF = 1                => goto dest };
INSTRUCTION "JECXZ.imm16" (dest) { %ecx = 0               => goto dest };
INSTRUCTION "JECXZ.imm32" (dest) { %ecx = 0               => goto dest };
INSTRUCTION "JG.imm16"    (dest) { ~%ZF & ~(%SF ^ %OF)    => goto dest };
INSTRUCTION "JG.imm32"    (dest) { ~%ZF & ~(%SF ^ %OF)    => goto dest };
INSTRUCTION "JGE.imm16"   (dest) { ~(%SF ^ %OF)           => goto dest };
INSTRUCTION "JGE.imm32"   (dest) { ~(%SF ^ %OF)           => goto dest };
INSTRUCTION "JL.imm16"    (dest) { %SF ^ %OF              => goto dest };
INSTRUCTION "JL.imm32"    (dest) { %SF ^ %OF              => goto dest };
INSTRUCTION "JLE.imm16"   (dest) { %ZF | (%SF ^ %OF)      => goto dest };
INSTRUCTION "JLE.imm32"   (dest) { %ZF | (%SF ^ %OF)      => goto dest };
INSTRUCTION "JMP.imm16"   (dest) {                           goto dest };
INSTRUCTION "JMP.imm32"   (dest) {                           goto dest };
INSTRUCTION "JMP.reg16"   (dest) {                           goto dest };
INSTRUCTION "JMP.reg32"   (dest) {                           goto dest };
INSTRUCTION "JMP.rm16"    (dest) {                           goto dest };
INSTRUCTION "JMP.rm32"    (dest) {                           goto dest };
INSTRUCTION "JNA.imm16"   (dest) { %CF | %ZF              => goto dest };
INSTRUCTION "JNA.imm32"   (dest) { %CF | %ZF              => goto dest };
INSTRUCTION "JNAE.imm16"  (dest) { %CF                    => goto dest };
INSTRUCTION "JNAE.imm32"  (dest) { %CF                    => goto dest };
INSTRUCTION "JNB.imm16"   (dest) { ~%CF                   => goto dest };
INSTRUCTION "JNB.imm32"   (dest) { ~%CF                   => goto dest };
INSTRUCTION "JNBE.imm16"  (dest) { (~%CF & ~%ZF)          => goto dest };
INSTRUCTION "JNBE.imm32"  (dest) { (~%CF & ~%ZF)          => goto dest };
INSTRUCTION "JNC.imm16"   (dest) { ~%CF                   => goto dest };
INSTRUCTION "JNC.imm32"   (dest) { ~%CF                   => goto dest };
INSTRUCTION "JNE.imm16"   (dest) { ~%ZF                   => goto dest };
INSTRUCTION "JNE.imm32"   (dest) { ~%ZF                   => goto dest };
INSTRUCTION "JNG.imm16"   (dest) { %ZF | (%SF ^ %OF)      => goto dest };
INSTRUCTION "JNG.imm32"   (dest) { %ZF | (%SF ^ %OF)      => goto dest };
INSTRUCTION "JNGE.imm16"  (dest) { ~%ZF & ~(%SF ^ %OF)    => goto dest };
INSTRUCTION "JNGE.imm32"  (dest) { ~%ZF & ~(%SF ^ %OF)    => goto dest };
INSTRUCTION "JNL.imm16"   (dest) { ~(%SF ^ %OF)           => goto dest };
INSTRUCTION "JNL.imm32"   (dest) { ~(%SF ^ %OF)           => goto dest };
INSTRUCTION "JNLE.imm16"  (dest) { ~%ZF & ~(%SF ^ %OF)    => goto dest };
INSTRUCTION "JNLE.imm32"  (dest) { ~%ZF & ~(%SF ^ %OF)    => goto dest };
INSTRUCTION "JNO.imm16"   (dest) { ~%OF                   => goto dest };
INSTRUCTION "JNO.imm32"   (dest) { ~%OF                   => goto dest };
INSTRUCTION "JNP.imm16"   (dest) { ~%PF                   => goto dest };
INSTRUCTION "JNP.imm32"   (dest) { ~%PF                   => goto dest };
INSTRUCTION "JNS.imm16"   (dest) { ~%SF                   => goto dest };
INSTRUCTION "JNS.imm32"   (dest) { ~%SF                   => goto dest };
INSTRUCTION "JNZ.imm16"   (dest) { ~%ZF                   => goto dest };
INSTRUCTION "JNZ.imm32"   (dest) { ~%ZF                   => goto dest };
INSTRUCTION "JO.imm16"    (dest) { %OF                    => goto dest };
INSTRUCTION "JO.imm32"    (dest) { %OF                    => goto dest };
INSTRUCTION "JP.imm16"    (dest) { %PF                    => goto dest };
INSTRUCTION "JP.imm32"    (dest) { %PF                    => goto dest };
INSTRUCTION "JS.imm16"    (dest) { %SF                    => goto dest };
INSTRUCTION "JS.imm32"    (dest) { %SF                    => goto dest };
INSTRUCTION "JZ.imm16"    (dest) { %ZF                    => goto dest };
INSTRUCTION "JZ.imm32"    (dest) { %ZF                    => goto dest };


# LAHF
INSTRUCTION "LAHF" () {
    *8* %ah := (%SF << 7) | (%ZF << 6) | (0 << 5) | (%AF << 4) | (0 << 3) | (%PF << 2) | (1 << 1) | (%CF << 0)
};


# LDS
INSTRUCTION "LDS.reg16.rm32" (dest, src) {
    *16* %ds  := src@[16:31]
    *16* dest := src@[0:15]
};

INSTRUCTION "LDS.reg32.rm32" (dest, src) {
    *16* %ds  := src@[32:47]
    *32* dest := src@[0:31]
};


# LEA
INSTRUCTION "LEA.reg16.rm16" (dest, src) {
    *32* tmpaddr := addr(dest)
    *16* dest := truncu(32, 16, tmpaddr)
};

INSTRUCTION "LEA.reg32.rm32" (dest, src) {
    *32* dest := addr(src)
};

INSTRUCTION "LEA.reg64.rm64" (dest, src) {
    *64* dest := addr(src)
};


# LEAVE
INSTRUCTION "LEAVE" () {
    *32* %esp := %ebp
    *32* %ebp := m[%esp]
    *32* %esp := %esp + 4
};


# LES
INSTRUCTION "LES.reg16.rm32" (dest, src) {
    *16* %es  := src@[16:31]
    *16* dest := src@[0:15]
};

INSTRUCTION "LES.reg32.rm32" (dest, src) {
    *16* %es  := src@[32:47]
    *32* dest := src@[0:31]
};


# LFS
INSTRUCTION "LFS.reg16.rm32" (dest, src) {
    *16* %fs  := src@[16:31]
    *16* dest := src@[0:15]
};

INSTRUCTION "LFS.reg32.rm32" (dest, src) {
    *16* %fs  := src@[32:47]
    *32* dest := src@[0:31]
};


# LGS
INSTRUCTION "LGS.reg16.rm32" (dest, src) {
    *16* %gs  := src@[16:31]
    *16* dest := src@[0:15]
};

INSTRUCTION "LGS.reg32.rm32" (dest, src) {
    *16* %gs  := src@[32:47]
    *32* dest := src@[0:31]
};


# LOOP
INSTRUCTION "LOOP.imm16" (dest) {
    *16* %cx := %cx - 1
    *16* %cx ~= 0 => %pc := dest
};

INSTRUCTION "LOOP.imm32" (dest) {
    *32* %ecx := %ecx - 1
    *32* %ecx ~= 0 => %pc := dest
};


# LOOPE
INSTRUCTION "LOOPE.imm16" (dest) {
    *16* %cx := %cx - 1
    *16* %cx ~= 0 && %ZF = 1 => %pc := dest
};

INSTRUCTION "LOOPE.imm32" (dest) {
    *32* %ecx := %ecx - 1
    *32* %ecx ~= 0 && %ZF = 1 => %pc := dest
};


# LOOPNE
INSTRUCTION "LOOPNE.imm16" (dest) {
    *16* %cx := %cx - 1
    *16* %cx ~= 0 && %ZF = 0 => %pc := dest
};

INSTRUCTION "LOOPNE.imm32" (dest) {
    *32* %ecx := %ecx - 1
    *32* %ecx ~= 0 && %ZF = 0 => %pc := dest
};


# LSS
INSTRUCTION "LSS.reg16.rm32" (dest, src) {
    *16* %ss  := src@[16:31]
    *16* dest := src@[0:15]
};

INSTRUCTION "LSS.reg32.rm32" (dest, src) {
    *16* %ss  := src@[32:47]
    *32* dest := src@[0:31]
};


# MOV
INSTRUCTION "MOV.reg8.imm8" (dest, src) {
    *8* dest := src
};

INSTRUCTION "MOV.reg8.reg8" (dest, src) {
    *8* dest := src
};

INSTRUCTION "MOV.reg8.rm8" (dest, src) {
    *8* dest := src
};

INSTRUCTION "MOV.reg16.imm16" (dest, src) {
    *16* dest := src
};

INSTRUCTION "MOV.reg16.reg16" (dest, src) {
    *16* dest := src
};

INSTRUCTION "MOV.reg16.rm16" (dest, src) {
    *16* dest := src
};

INSTRUCTION "MOV.reg32.imm32" (dest, src) {
    *32* dest := src
};

INSTRUCTION "MOV.reg32.reg32" (dest, src) {
    *32* dest := src
};

INSTRUCTION "MOV.reg32.rm32" (dest, src) {
    *32* dest := src
};

INSTRUCTION "MOV.reg64.imm64" (dest, src) {
    *64* dest := src
};

INSTRUCTION "MOV.reg64.reg64" (dest, src) {
    *64* dest := src
};

INSTRUCTION "MOV.reg64.rm64" (dest, src) {
    *64* dest := src
};

INSTRUCTION "MOV.rm8.imm8" (dest, src) {
    *8* dest := src
};

INSTRUCTION "MOV.rm8.reg8" (dest, src) {
    *8* dest := src
};

INSTRUCTION "MOV.rm16.imm16" (dest, src) {
    *16* dest := src
};

INSTRUCTION "MOV.rm16.reg16" (dest, src) {
    *16* dest := src
};

INSTRUCTION "MOV.rm32.imm32" (dest, src) {
    *32* dest := src
};

INSTRUCTION "MOV.rm32.reg32" (dest, src) {
    *32* dest := src
};

INSTRUCTION "MOV.rm64.imm32" (dest, src) {
    *64* dest := sgnex(32, 64, src)
};

INSTRUCTION "MOV.rm64.reg64" (dest, src) {
    *64* dest := src
};


# MOVSX
INSTRUCTION "MOVSX.reg16.reg8" (dest, src) {
    *16* dest := sgnex(8, 16, src)
};

INSTRUCTION "MOVSX.reg16.rm8" (dest, src) {
    *16* dest := sgnex(8, 16, src)
};

INSTRUCTION "MOVSX.reg32.reg8" (dest, src) {
    *32* dest := sgnex(8, 32, src)
};

INSTRUCTION "MOVSX.reg32.reg16" (dest, src) {
    *32* dest := sgnex(16, 32, src)
};

INSTRUCTION "MOVSX.reg32.rm8" (dest, src) {
    *32* dest := sgnex(8, 32, src)
};

INSTRUCTION "MOVSX.reg32.rm16" (dest, src) {
    *32* dest := sgnex(16, 32, src)
};

INSTRUCTION "MOVSX.reg64.rm8" (dest, src) {
    *64* dest := sgnex(8, 64, src)
};

INSTRUCTION "MOVSX.reg64.rm16" (dest, src) {
    *64* dest := sgnex(16, 64, src)
};


# MOVSXD
INSTRUCTION "MOVSXD.reg16.rm16" (dest, src) {
    *16* dest := sgnex(16, 16, src)
};

INSTRUCTION "MOVSXD.reg32.rm32" (dest, src) {
    *32* dest := sgnex(32, 32, src)
};

INSTRUCTION "MOVSXD.reg64.rm32" (dest, src) {
    *64* dest := sgnex(32, 64, src)
};


# MOVZX
INSTRUCTION "MOVZX.reg16.reg8" (dest, src) {
    *16* dest := zfill(8, 16, src)
};

INSTRUCTION "MOVZX.reg16.rm8" (dest, src) {
    *16* dest := zfill(8, 16, src)
};

INSTRUCTION "MOVZX.reg32.reg8" (dest, src) {
    *32* dest := zfill(8, 32, src)
};

INSTRUCTION "MOVZX.reg32.reg16" (dest, src) {
    *32* dest := zfill(16, 32, src)
};

INSTRUCTION "MOVZX.reg32.rm8" (dest, src) {
    *32* dest := zfill(8, 32, src)
};

INSTRUCTION "MOVZX.reg32.rm16" (dest, src) {
    *32* dest := zfill(16, 32, src)
};

INSTRUCTION "MOVZX.reg64.rm8" (dest, src) {
    *64* dest := zfill(8, 64, src)
};

INSTRUCTION "MOVZX.reg64.rm16" (dest, src) {
    *64* dest := zfill(16, 64, src)
};


# MUL
INSTRUCTION "MUL.reg8" (src) {
    *16* tmph := %al * src
    *16* %ax := tmph
    MULTFLAGS8(tmph)
};

INSTRUCTION "MUL.reg16" (src) {
    *32* tmp1 := %ax * src
    *16* %ax := tmp1
    *16* %dx := tmp1 >> 16
    MULTFLAGS16(tmp1)
};

INSTRUCTION "MUL.reg32" (src) {
    *32* tmp1 := src
    *64* tmpl := zfill(32, 64, %eax) * zfill(32, 64, tmp1)
    *32* %eax := tmpl@[0:31]
    *32* %edx := tmpl@[32:63]
    MULTFLAGS32(tmpl)
};

INSTRUCTION "MUL.rm8" (src) {
    *16* tmph := %al * src
    *16* %ax := tmph
    MULTFLAGS8(tmph)
};

INSTRUCTION "MUL.rm32" (src) {
    *32* tmp1 := src
    *64* tmpl := zfill(32, 64, %eax) * zfill(32, 64, tmp1)
    *32* %eax := tmpl@[0:31]
    *32* %edx := tmpl@[32:63]
    MULTFLAGS32(tmpl)
};


# NEG
INSTRUCTION "NEG.reg8" (val) {
    *8* tmpval := val
    *8* val := 0 - val
    SUBFLAGS8(0, tmpval, val)
};

INSTRUCTION "NEG.reg16" (val) {
    *16* tmpval := val
    *16* val := 0 - val
    SUBFLAGS16(0, tmpval, val)
};

INSTRUCTION "NEG.reg32" (val) {
    *32* tmpval := val
    *32* val := 0 - val
    SUBFLAGS32(0, tmpval, val)
};

INSTRUCTION "NEG.reg64" (val) {
    *64* tmpval := val
    *64* val := 0 - val
    SUBFLAGS64(0, tmpval, val)
};

INSTRUCTION "NEG.rm8" (val) {
    *8* tmpval := val
    *8* val := 0 - val
    SUBFLAGS8(0, tmpval, val)
};

INSTRUCTION "NEG.rm16" (val) {
    *16* tmpval := val
    *16* val := 0 - val
    SUBFLAGS16(0, tmpval, val)
};

INSTRUCTION "NEG.rm32" (val) {
    *32* tmpval := val
    *32* val := 0 - val
    SUBFLAGS32(0, tmpval, val)
};


# NOP
INSTRUCTION "NOP" () {
    _
};

INSTRUCTION "NOP.rm16" (dummy) {
    _
};

INSTRUCTION "NOP.rm32" (dummy) {
    _
};


# NOT
INSTRUCTION "NOT.reg8" (reg) {
    *8* reg := ~reg
};

INSTRUCTION "NOT.reg16" (reg) {
    *16* reg := ~reg
};

INSTRUCTION "NOT.reg32" (reg) {
    *32* reg := ~reg
};

INSTRUCTION "NOT.reg64" (reg) {
    *64* reg := ~reg
};

INSTRUCTION "NOT.rm8" (dest) {
    *8* dest := ~dest
};

INSTRUCTION "NOT.rm16" (dest) {
    *16* dest := ~dest
};

INSTRUCTION "NOT.rm32" (dest) {
    *32* dest := ~dest
};


# OR
INSTRUCTION "OR.reg8.imm8" (dest, src) {
    *8* dest := dest | src
    LOGICALFLAGS8(dest)
};

INSTRUCTION "OR.reg8.reg8" (dest, src) {
    *8* dest := dest | src
    LOGICALFLAGS8(dest)
};

INSTRUCTION "OR.reg8.rm8" (dest, src) {
    *8* dest := dest | src
    LOGICALFLAGS8(dest)
};

INSTRUCTION "OR.reg16.imm16" (dest, src) {
    *16* dest := dest | src
    LOGICALFLAGS16(dest)
};

INSTRUCTION "OR.reg16.reg16" (dest, src) {
    *16* dest := dest | src
    LOGICALFLAGS16(dest)
};

INSTRUCTION "OR.reg16.rm16" (dest, src) {
    *16* dest := dest | src
    LOGICALFLAGS16(dest)
};

INSTRUCTION "OR.reg32.imm32" (dest, src) {
    *32* dest := dest | src
    LOGICALFLAGS32(dest)
};

INSTRUCTION "OR.reg32.reg32" (dest, src) {
    *32* dest := dest | src
    LOGICALFLAGS32(dest)
};

INSTRUCTION "OR.reg32.rm32" (dest, src) {
    *32* dest := dest | src
    LOGICALFLAGS32(dest)
};

INSTRUCTION "OR.reg64.imm32" (dest, src) {
    *64* dest := dest | sgnex(32, 64, src)
    LOGICALFLAGS64(dest)
};

INSTRUCTION "OR.rm8.imm8" (dest, src) {
    *8* dest := dest | src
    LOGICALFLAGS8(dest)
};

INSTRUCTION "OR.rm8.reg8" (dest, src) {
    *8* dest := dest | src
    LOGICALFLAGS8(dest)
};

INSTRUCTION "OR.rm16.imm8" (dest, src) {
    *16* dest := dest | sgnex(8, 16, src)
    LOGICALFLAGS16(dest)
};

INSTRUCTION "OR.rm16.imm16" (dest, src) {
    *16* dest := dest | src
    LOGICALFLAGS16(dest)
};

INSTRUCTION "OR.rm16.reg16" (dest, src) {
    *16* dest := dest | src
    LOGICALFLAGS16(dest)
};

INSTRUCTION "OR.rm32.imm8" (dest, src) {
    *32* dest := dest | sgnex(8, 32, src)
    LOGICALFLAGS32(dest)
};

INSTRUCTION "OR.rm32.imm32" (dest, src) {
    *32* dest := dest | src
    LOGICALFLAGS32(dest)
};

INSTRUCTION "OR.rm32.reg32" (dest, src) {
    *32* dest := dest | src
    LOGICALFLAGS32(dest)
};

INSTRUCTION "OR.rm64.imm8" (dest, src) {
    *64* dest := dest | sgnex(8, 64, src)
    LOGICALFLAGS64(dest)
};

INSTRUCTION "OR.rm64.reg64" (dest, src) {
    *64* dest := dest | src
    LOGICALFLAGS64(dest)
};


# PAUSE
INSTRUCTION "PAUSE" () {
    _
};


# POP
INSTRUCTION "POP.reg16" (reg) {
    *16* reg := m[%esp]
    *16* %esp := %esp + 2
};

INSTRUCTION "POP.reg32" (reg) {
    *32* reg := m[%esp]
    *32* %esp := %esp + 4
};

INSTRUCTION "POP.rm16" (rm) {
    *16* rm := m[%esp]
    *16* %esp := %esp + 2
};

INSTRUCTION "POP.rm32" (rm) {
    *32* rm := m[%esp]
    *32* %esp := %esp + 4
};


# POPA
INSTRUCTION "POPA" () {
    *16* %ax := m[%sp + 14]
    *16* %cx := m[%sp + 12]
    *16* %dx := m[%sp + 10]
    *16* %bx := m[%sp +  8]
    # throw away sp
    *16* %bp := m[%sp +  4]
    *16* %si := m[%sp +  2]
    *16* %di := m[%sp +  0]
    *16* %sp := %sp + 16
};


# POPAL
INSTRUCTION "POPAL" () {
    *32* %eax := m[%esp + 28]
    *32* %ecx := m[%esp + 24]
    *32* %edx := m[%esp + 20]
    *32* %ebx := m[%esp + 16]
    # throw away esp
    *32* %ebp := m[%esp +  8]
    *32* %esi := m[%esp +  4]
    *32* %edi := m[%esp +  0]
    *32* %esp := %esp + 32
};


# POPAW
INSTRUCTION "POPAW" () {
    *16* %ax := m[%sp + 14]
    *16* %cx := m[%sp + 12]
    *16* %dx := m[%sp + 10]
    *16* %bx := m[%sp +  8]
    # throw away sp
    *16* %bp := m[%sp +  4]
    *16* %si := m[%sp +  2]
    *16* %di := m[%sp +  0]
    *16* %sp := %sp + 16
};


# POPF
INSTRUCTION "POPF" () {
    *16* %flags := m[%esp + 0]
    *32* %esp := %esp + 2
};


# POPFD
INSTRUCTION "POPFD" () {
    *32* %eflags := m[%esp + 0]
    *32* %esp := %esp + 4
};


# PUSH
INSTRUCTION "PUSH.imm8" (val) {
    *32* m[%esp - 4] := sgnex(8, 32, val)
    *32* %esp := %esp - 4
};

INSTRUCTION "PUSH.imm16" (val) {
    *32* m[%esp - 4] := sgnex(16, 32, val)
    *32* %esp := %esp - 4
};

INSTRUCTION "PUSH.imm32" (val) {
    *32* m[%esp - 4] := val
    *32* %esp := %esp - 4
};

INSTRUCTION "PUSH.reg16" (reg) {
    *16* m[%esp - 2] := reg
    *32* %esp := %esp - 2
};

INSTRUCTION "PUSH.reg32" (reg) {
    *32* m[%esp - 4] := reg
    *32* %esp := %esp - 4
};

INSTRUCTION "PUSH.rm16" (rm) {
    *16* m[%esp - 2] := rm
    *32* %esp := %esp - 2
};

INSTRUCTION "PUSH.rm32" (rm) {
    *32* m[%esp - 4] := rm
    *32* %esp := %esp - 4
};


# PUSHA
INSTRUCTION "PUSHA" () {
    *16* m[%sp -  2] := %ax
    *16* m[%sp -  4] := %cx
    *16* m[%sp -  6] := %dx
    *16* m[%sp -  8] := %bx
    *16* m[%sp - 10] := %sp
    *16* m[%sp - 12] := %bp
    *16* m[%sp - 14] := %si
    *16* m[%sp - 16] := %di
    *16* %sp := %sp - 16
};


# PUSHAL
INSTRUCTION "PUSHAL" () {
    *32* m[%sp -  4] := %eax
    *32* m[%sp -  8] := %ecx
    *32* m[%sp - 12] := %edx
    *32* m[%sp - 16] := %ebx
    *16* m[%sp - 20] := %esp
    *16* m[%sp - 24] := %ebp
    *16* m[%sp - 28] := %esi
    *16* m[%sp - 32] := %edi
    *16* %esp := %esp - 32
};


# PUSHAW
INSTRUCTION "PUSHAW" () {
    *16* m[%sp -  2] := %ax
    *16* m[%sp -  4] := %cx
    *16* m[%sp -  6] := %dx
    *16* m[%sp -  8] := %bx
    *16* m[%sp - 10] := %sp
    *16* m[%sp - 12] := %bp
    *16* m[%sp - 14] := %si
    *16* m[%sp - 16] := %di
    *16* %sp := %sp - 16
};


# PUSHF
INSTRUCTION "PUSHF" () {
    *16* m[%esp - 2] := %flags
    *32* %esp := %esp - 2
};


# PUSHFD
INSTRUCTION "PUSHFD" () {
    *32* m[%esp - 4] := %eflags
    *32* %esp := %esp - 4
};


# RCL
INSTRUCTION "RCL.reg8.imm8" (dest, src) {
    *8* tmpb := dest
    *8* dest := dest rlc src
    ROLFLAGS8(dest, tmpb, src)
};

INSTRUCTION "RCL.reg8.reg8" (dest, src) {
    *8* tmpb := dest
    *8* dest := dest rlc src
    ROLFLAGS8(dest, tmpb, src)
};

INSTRUCTION "RCL.reg16.imm8" (dest, src) {
    *16* tmph := dest
    *16* dest := dest rlc src
    ROLFLAGS16(dest, tmph, src)
};

INSTRUCTION "RCL.reg16.imm16" (dest, src) {
    *16* tmph := dest
    *16* dest := dest rlc src
    ROLFLAGS16(dest, tmph, src)
};

INSTRUCTION "RCL.reg16.reg8" (dest, src) {
    *16* tmph := dest
    *16* dest := dest rlc src
    ROLFLAGS16(dest, tmph, src)
};

INSTRUCTION "RCL.reg32.imm8" (dest, src) {
    *32* tmp1 := dest
    *32* dest := dest rlc src
    ROLFLAGS32(dest, tmp1, src)
};

INSTRUCTION "RCL.reg32.reg8" (dest, src) {
    *32* tmp1 := dest
    *32* dest := dest rlc src
    ROLFLAGS32(dest, tmp1, src)
};

INSTRUCTION "RCL.reg32.imm32" (dest, src) {
    *32* tmp1 := dest
    *32* dest := dest rlc src
    ROLFLAGS32(dest, tmp1, src)
};

INSTRUCTION "RCL.rm8.imm8" (dest, src) {
    *8* tmpb := dest
    *8* dest := dest rlc src
    ROLFLAGS8(dest, tmpb, src)
};

INSTRUCTION "RCL.rm8.reg8" (dest, src) {
    *8* tmpb := dest
    *8* dest := dest rlc src
    ROLFLAGS8(dest, tmpb, src)
};

INSTRUCTION "RCL.rm32.imm32" (dest, src) {
    *32* tmp1 := dest
    *32* dest := dest rlc src
    ROLFLAGS32(dest, tmp1, src)
};


# RCR
INSTRUCTION "RCR.reg8.imm8" (dest, src) {
    *8* tmp1 := dest
    *8* dest := dest rrc src
    RORFLAGS8(dest, tmp1, src)
};

INSTRUCTION "RCR.reg8.reg8" (dest, src) {
    *8* tmp1 := dest
    *8* dest := dest rrc src
    RORFLAGS8(dest, tmp1, src)
};

INSTRUCTION "RCR.reg16.imm8" (dest, src) {
    *16* tmp1 := dest
    *16* dest := dest rrc src
    RORFLAGS16(dest, tmp1, src)
};

INSTRUCTION "RCR.reg16.imm16" (dest, src) {
    *16* tmp1 := dest
    *16* dest := dest rrc src
    RORFLAGS16(dest, tmp1, src)
};

INSTRUCTION "RCR.reg16.reg8" (dest, src) {
    *16* tmp1 := dest
    *16* dest := dest rrc src
    RORFLAGS16(dest, tmp1, src)
};

INSTRUCTION "RCR.reg32.reg8" (dest, src) {
    *32* tmp1 := dest
    *32* dest := dest rrc src
    RORFLAGS32(dest, tmp1, src)
};

INSTRUCTION "RCR.reg32.imm8" (dest, src) {
    *32* tmp1 := dest
    *32* dest := dest rrc src
    RORFLAGS32(dest, tmp1, src)
};

INSTRUCTION "RCR.reg32.imm32" (dest, src) {
    *32* tmp1 := dest
    *32* dest := dest rrc src
    RORFLAGS32(dest, tmp1, src)
};

INSTRUCTION "RCR.rm32.imm32" (dest, src) {
    *32* tmp1 := dest
    *32* dest := dest rrc src
    RORFLAGS32(dest, tmp1, src)
};


# RET
INSTRUCTION "RET" () {
    *32* %pc := m[%esp]
    *32* %esp := %esp + 4
    ret
};


INSTRUCTION "RET.imm16" (offset) {
    *32* %pc := m[%esp + offset]
    *32* %esp := %esp + 4 + offset
    ret
};


INSTRUCTION "RET.imm32" (offset) {
    *32* %pc := m[%esp + offset]
    *32* %esp := %esp + 4 + offset
    ret
};


# RETF
INSTRUCTION "RETF" () {
    *32* %pc := m[%esp]
    *32* %esp := %esp + 4
    ret
};

INSTRUCTION "RETF.imm16" (offset) {
    *32* %pc := m[%esp + offset]
    *32* %esp := %esp + 4 + offset
    ret
};

INSTRUCTION "RETF.imm32" (offset) {
    *32* %pc := m[%esp + offset]
    *32* %esp := %esp + 4 + offset
    ret
};


# ROL
INSTRUCTION "ROL.reg8.imm8" (dest, src) {
    *8* tmpb := dest
    *8* dest := dest rl src
    ROLFLAGS8(dest, tmpb, src)
};

INSTRUCTION "ROL.reg8.reg8" (dest, src) {
    *8* tmpb := dest
    *8* dest := dest rl src
    ROLFLAGS8(dest, tmpb, src)
};

INSTRUCTION "ROL.reg16.imm8" (dest, src) {
    *16* tmp1 := dest
    *16* dest := dest rl src
    ROLFLAGS16(dest, tmp1, src)
};

INSTRUCTION "ROL.reg16.imm16" (dest, src) {
    *16* tmp1 := dest
    *16* dest := dest rl src
    ROLFLAGS16(dest, tmp1, src)
};

INSTRUCTION "ROL.reg16.reg8" (dest, src) {
    *16* tmp1 := dest
    *16* dest := dest rl src
    ROLFLAGS16(dest, tmp1, src)
};

INSTRUCTION "ROL.reg32.imm8" (dest, src) {
    *32* tmp1 := dest
    *32* dest := dest rl src
    ROLFLAGS32(dest, tmp1, src)
};

INSTRUCTION "ROL.reg32.reg8" (dest, src) {
    *32* tmp1 := dest
    *32* dest := dest rl src
    ROLFLAGS32(dest, tmp1, src)
};

INSTRUCTION "ROL.reg32.imm32" (dest, src) {
    *32* tmp1 := dest
    *32* dest := dest rl src
    ROLFLAGS32(dest, tmp1, src)
};


# ROR
INSTRUCTION "ROR.reg8.imm8" (dest, src) {
    *8* tmpb := dest
    *8* dest := dest rr src
    RORFLAGS8(dest, tmpb, src)
};

INSTRUCTION "ROR.reg8.reg8" (dest, src) {
    *8* tmpb := dest
    *8* dest := dest rr src
    RORFLAGS8(dest, tmpb, src)
};

INSTRUCTION "ROR.reg16.imm8" (dest, src) {
    *16* tmp1 := dest
    *16* dest := dest rr src
    RORFLAGS16(dest, tmp1, src)
};

INSTRUCTION "ROR.reg16.imm16" (dest, src) {
    *16* tmp1 := dest
    *16* dest := dest rr src
    RORFLAGS16(dest, tmp1, src)
};

INSTRUCTION "ROR.reg16.reg8" (dest, src) {
    *16* tmp1 := dest
    *16* dest := dest rr src
    RORFLAGS16(dest, tmp1, src)
};

INSTRUCTION "ROR.reg32.reg8" (dest, src) {
    *32* tmp1 := dest
    *32* dest := dest rr src
    RORFLAGS32(dest, tmp1, src)
};

INSTRUCTION "ROR.reg32.imm8" (dest, src) {
    *32* tmp1 := dest
    *32* dest := dest rr src
    RORFLAGS32(dest, tmp1, src)
};

INSTRUCTION "ROR.reg32.imm32" (dest, src) {
    *32* tmp1 := dest
    *32* dest := dest rr src
    RORFLAGS32(dest, tmp1, src)
};

INSTRUCTION "ROR.rm32.imm32" (dest, src) {
    *32* tmp1 := dest
    *32* dest := dest rr src
    RORFLAGS32(dest, tmp1, src)
};

INSTRUCTION "ROR.rm32.reg8" (dest, src) {
    *32* tmp1 := dest
    *32* dest := dest rr src
    RORFLAGS32(dest, tmp1, src)
};


# SAHF
INSTRUCTION "SAHF" () {
    *1* %SF := %ah@[7:7]
    *1* %ZF := %ah@[6:6]
    *1* %AF := %ah@[4:4]
    *1* %PF := %ah@[2:2]
    *1* %CF := %ah@[0:0]
    SAHFFLAGS(%ah)
};


# SAR
INSTRUCTION "SAR.reg8.imm8" (dest, src) {
    *8* tmpb := dest
    *8* dest := dest >>A (src & 0x1F)
    SARFLAGS(dest, tmpb, src)
};

INSTRUCTION "SAR.reg8.reg8" (dest, src) {
    *8* tmpb := dest
    *8* dest := dest >>A (src & 0x1F)
    SARFLAGS(dest, tmpb, src)
};

INSTRUCTION "SAR.reg16.imm8" (dest, src) {
    *16* tmph := dest
    *16* dest := dest >>A (src & 0x1F)
    SARFLAGS(dest, tmph, src)
};

INSTRUCTION "SAR.reg16.imm16" (dest, src) {
    *16* tmph := dest
    *16* dest := dest >>A (src & 0x1F)
    SARFLAGS(dest, tmph, src)
};

INSTRUCTION "SAR.reg16.reg8" (dest, src) {
    *16* tmph := dest
    *16* dest := dest >>A (src & 0x1F)
    SARFLAGS(dest, tmph, src)
};

INSTRUCTION "SAR.reg32.imm8" (dest, src) {
    *32* tmp1 := dest
    *32* dest := dest >>A (src & 0x1F)
    SARFLAGS(dest, tmp1, src)
};

INSTRUCTION "SAR.reg32.imm32" (dest, src) {
    *32* tmp1 := dest
    *32* dest := dest >>A (src & 0x1F)
    SARFLAGS(dest, tmp1, src)
};

INSTRUCTION "SAR.reg32.reg8" (dest, src) {
    *32* tmp1 := dest
    *32* dest := dest >>A (src & 0x1F)
    SARFLAGS(dest, tmp1, src)
};

INSTRUCTION "SAR.rm8.imm8" (dest, src) {
    *8* tmpb := dest
    *8* dest := dest >>A (src & 0x1F)
    SARFLAGS(dest, tmpb, src)
};

INSTRUCTION "SAR.rm8.reg8" (dest, src) {
    *8* tmpb := dest
    *8* dest := dest >>A (src & 0x1F)
    SARFLAGS(dest, tmpb, src)
};

INSTRUCTION "SAR.rm16.imm8" (dest, src) {
    *16* tmph := dest
    *16* dest := dest >>A (src & 0x1F)
    SARFLAGS(dest, tmph, src)
};

INSTRUCTION "SAR.rm16.imm16" (dest, src) {
    *16* tmph := dest
    *16* dest := dest >>A (src & 0x1F)
    SARFLAGS(dest, tmph, src)
};

INSTRUCTION "SAR.rm16.reg8" (dest, src) {
    *16* tmph := dest
    *16* dest := dest >>A (src & 0x1F)
    SARFLAGS(dest, tmph, src)
};

INSTRUCTION "SAR.rm32.imm8" (dest, src) {
    *32* tmp1 := dest
    *32* dest := dest >>A (src & 0x1F)
    SARFLAGS(dest, tmp1, src)
};

INSTRUCTION "SAR.rm32.imm32" (dest, src) {
    *32* tmp1 := dest
    *32* dest := dest >>A (src & 0x1F)
    SARFLAGS(dest, tmp1, src)
};

INSTRUCTION "SAR.rm64.imm8" (dest, src) {
    *64* tmp1 := dest
    *64* dest := dest >>A (src & 0x1F)
    SARFLAGS(dest, tmp1, src)
};


# SBB
INSTRUCTION "SBB.reg8.imm8" (dest, src) {
    *8* tmpb := dest
    *8* dest := dest - src - %CF
    SUBFLAGS8(tmpb, src, dest)
};

INSTRUCTION "SBB.reg8.reg8" (dest, src) {
    *8* tmpb := dest
    *8* dest := dest - src - %CF
    SUBFLAGS8(tmpb, src, dest)
};

INSTRUCTION "SBB.reg8.rm8" (dest, src) {
    *8* tmpb := dest
    *8* dest := dest - src - %CF
    SUBFLAGS8(tmpb, src, dest)
};

INSTRUCTION "SBB.reg16.imm16" (dest, src) {
    *16* tmph := dest
    *16* dest := dest - src - %CF
    SUBFLAGS16(tmph, src, dest)
};

INSTRUCTION "SBB.reg16.reg16" (dest, src) {
    *16* tmph := dest
    *16* dest := dest - src - %CF
    SUBFLAGS16(tmph, src, dest)
};

INSTRUCTION "SBB.reg16.rm16" (dest, src) {
    *16* tmph := dest
    *16* dest := dest - src - %CF
    SUBFLAGS16(tmph, src, dest)
};

INSTRUCTION "SBB.reg32.imm32" (dest, src) {
    *32* tmp1 := dest
    *32* dest := dest - src - %CF
    SUBFLAGS32(tmp1, src, dest)
};

INSTRUCTION "SBB.reg32.reg32" (dest, src) {
    *32* tmp1 := dest
    *32* dest := dest - src - %CF
    SUBFLAGS32(tmp1, src, dest)
};

INSTRUCTION "SBB.reg32.rm32" (dest, src) {
    *32* tmp1 := dest
    *32* dest := dest - src - %CF
    SUBFLAGS32(tmp1, src, dest)
};

INSTRUCTION "SBB.reg64.rm64" (dest, src) {
    *64* tmp1 := dest
    *64* dest := dest - src - %CF
    SUBFLAGS64(tmp1, src, dest)
};

INSTRUCTION "SBB.rm8.imm8" (dest, src) {
    *8* tmpb := dest
    *8* dest := dest - src - %CF
    SUBFLAGS8(tmpb, src, dest)
};

INSTRUCTION "SBB.rm8.reg8" (dest, src) {
    *8* tmpb := dest
    *8* dest := dest - src - %CF
    SUBFLAGS8(tmpb, src, dest)
};

INSTRUCTION "SBB.rm16.imm8" (dest, src) {
    *16* tmph := dest
    *16* dest := dest - sgnex(8, 16, src) - %CF
    SUBFLAGS16(tmph, src, dest)
};

INSTRUCTION "SBB.rm16.imm16" (dest, src) {
    *16* tmph := dest
    *16* dest := dest - src - %CF
    SUBFLAGS16(tmph, src, dest)
};

INSTRUCTION "SBB.rm16.reg16" (dest, src) {
    *16* tmph := dest
    *16* dest := dest - src - %CF
    SUBFLAGS16(tmph, src, dest)
};

INSTRUCTION "SBB.rm32.imm8" (dest, src) {
    *32* tmp1 := dest
    *32* dest := dest - sgnex(8, 32, src) - %CF
    SUBFLAGS32(tmp1, src, dest)
};

INSTRUCTION "SBB.rm32.imm32" (dest, src) {
    *32* tmp1 := dest
    *32* dest := dest - src - %CF
    SUBFLAGS32(tmp1, src, dest)
};

INSTRUCTION "SBB.rm32.reg32" (dest, src) {
    *32* tmp1 := dest
    *32* dest := dest - src - %CF
    SUBFLAGS32(tmp1, src, dest)
};

INSTRUCTION "SBB.rm64.imm8" (dest, src) {
    *64* tmp1 := dest
    *32* dest := dest - sgnex(8, 64, src) - %CF
    SUBFLAGS64(tmp1, src, dest)
};

INSTRUCTION "SBB.rm64.imm32" (dest, src) {
    *64* tmp1 := dest
    *64* dest := dest - sgnex(32, 64, src) - %CF
    SUBFLAGS64(tmp1, src, dest)
};

INSTRUCTION "SBB.rm64.reg64" (dest, src) {
    *64* tmp1 := dest
    *64* dest := dest - src - %CF
    SUBFLAGS64(tmp1, src, dest)
};


# SETcc
INSTRUCTION "SETA.reg8"  (dest) { *8* dest := ~%CF & ~%ZF         };
INSTRUCTION "SETA.rm8"   (dest) { *8* dest := ~%CF & ~%ZF         };
INSTRUCTION "SETAE.reg8" (dest) { *8* dest := ~%CF                };
INSTRUCTION "SETAE.rm8"  (dest) { *8* dest := ~%CF                };
INSTRUCTION "SETB.reg8"  (dest) { *8* dest := %CF                 };
INSTRUCTION "SETB.rm8"   (dest) { *8* dest := %CF                 };
INSTRUCTION "SETBE.reg8" (dest) { *8* dest := %CF | %ZF           };
INSTRUCTION "SETBE.rm8"  (dest) { *8* dest := %CF | %ZF           };
INSTRUCTION "SETE.reg8"  (dest) { *8* dest := %ZF                 };
INSTRUCTION "SETE.rm8"   (dest) { *8* dest := %ZF                 };
INSTRUCTION "SETG.reg8"  (dest) { *8* dest := ~%ZF & ~(%SF ^ %OF) };
INSTRUCTION "SETG.rm8"   (dest) { *8* dest := ~%ZF & ~(%SF ^ %OF) };
INSTRUCTION "SETGE.reg8" (dest) { *8* dest := ~(%SF ^ %OF)        };
INSTRUCTION "SETGE.rm8"  (dest) { *8* dest := ~(%SF ^ %OF)        };
INSTRUCTION "SETL.reg8"  (dest) { *8* dest := %SF ^ %OF           };
INSTRUCTION "SETL.rm8"   (dest) { *8* dest := %SF ^ %OF           };
INSTRUCTION "SETLE.reg8" (dest) { *8* dest := %ZF | (%SF ^ %OF)   };
INSTRUCTION "SETLE.rm8"  (dest) { *8* dest := %ZF | (%SF ^ %OF)   };
INSTRUCTION "SETNE.reg8" (dest) { *8* dest := ~%ZF                };
INSTRUCTION "SETNE.rm8"  (dest) { *8* dest := ~%ZF                };
INSTRUCTION "SETNO.reg8" (dest) { *8* dest := ~%OF                };
INSTRUCTION "SETNO.rm8"  (dest) { *8* dest := ~%OF                };
INSTRUCTION "SETNS.reg8" (dest) { *8* dest := ~%SF                };
INSTRUCTION "SETNS.rm8"  (dest) { *8* dest := ~%SF                };
INSTRUCTION "SETNP.reg8" (dest) { *8* dest := ~%PF                };
INSTRUCTION "SETNP.rm8"  (dest) { *8* dest := ~%PF                };
INSTRUCTION "SETP.reg8"  (dest) { *8* dest := %PF                 };
INSTRUCTION "SETP.rm8"   (dest) { *8* dest := %PF                 };
INSTRUCTION "SETS.reg8"  (dest) { *8* dest := %SF                 };
INSTRUCTION "SETS.rm8"   (dest) { *8* dest := %SF                 };
INSTRUCTION "SETO.reg8"  (dest) { *8* dest := %OF                 };
INSTRUCTION "SETO.rm8"   (dest) { *8* dest := %OF                 };


# SHL
INSTRUCTION "SHL.reg8.imm8" (dest, src) {
    *8* tmpb := dest
    *8* dest := dest << (src & 0x1F)
    SALFLAGS8(dest, tmpb, src)
};

INSTRUCTION "SHL.reg8.reg8" (dest, src) {
    *8* tmpb := dest
    *8* dest := dest << (src & 0x1F)
    SALFLAGS8(dest, tmpb, src)
};

INSTRUCTION "SHL.reg16.imm8" (dest, src) {
    *16* tmph := dest
    *16* dest := dest << (src & 0x1F)
    SALFLAGS16(dest, tmph, src)
};

INSTRUCTION "SHL.reg16.reg8" (dest, src) {
    *16* tmph := dest
    *16* dest := dest << (src & 0x1F)
    SALFLAGS16(dest, tmph, src)
};

INSTRUCTION "SHL.reg16.imm16" (dest, src) {
    *16* tmph := dest
    *16* dest := dest << (src & 0x1F)
    SALFLAGS16(dest, tmph, src)
};

INSTRUCTION "SHL.reg32.imm8" (dest, src) {
    *32* tmp1 := dest
    *32* dest := dest << (src & 0x1F)
    SALFLAGS32(dest, tmp1, src)
};

INSTRUCTION "SHL.reg32.imm32" (dest, src) {
    *32* tmp1 := dest
    *32* dest := dest << (src & 0x1F)
    SALFLAGS32(dest, tmp1, src)
};

INSTRUCTION "SHL.reg32.reg8" (dest, src) {
    *32* tmp1 := dest
    *32* dest := dest << (src & 0x1F)
    SALFLAGS32(dest, tmp1, src)
};

INSTRUCTION "SHL.rm8.imm8" (dest, src) {
    *8* tmpb := dest
    *8* dest := dest << (src & 0x1F)
    SALFLAGS8(dest, tmpb, src)
};

INSTRUCTION "SHL.rm8.reg8" (dest, src) {
    *8* tmpb := dest
    *8* dest := dest << (src & 0x1F)
    SALFLAGS8(dest, tmpb, src)
};

INSTRUCTION "SHL.rm16.reg8" (dest, src) {
    *16* tmph := dest
    *16* dest := dest << (src & 0x1F)
    SALFLAGS16(dest, tmph, src)
};

INSTRUCTION "SHL.rm16.imm16" (dest, src) {
    *16* tmph := dest
    *16* dest := dest << (src & 0x1F)
    SALFLAGS16(dest, tmph, src)
};

INSTRUCTION "SHL.rm32.reg8" (dest, src) {
    *32* tmp1 := dest
    *32* dest := dest << (src & 0x1F)
    SALFLAGS32(dest, tmp1, src)
};

INSTRUCTION "SHL.rm32.imm32" (dest, src) {
    *32* tmp1 := dest
    *32* dest := dest << (src & 0x1F)
    SALFLAGS32(dest, tmp1, src)
};


# SHLD
INSTRUCTION "SHLD.reg16.reg16.imm8" (dest, src, count) {
    *32* tmp1 := dest << 32 | src
    *16* dest := (tmp1 << count) >> 16
    SHLDFLAGS16(dest, tmp1, count)
};

INSTRUCTION "SHLD.reg16.reg16.imm16" (dest, src, count) {
    *32* tmp1 := dest << 32 | src
    *16* dest := (tmp1 << count) >> 16
    SHLDFLAGS16(dest, tmp1, count)
};

INSTRUCTION "SHLD.reg16.reg16.reg8" (dest, src, count) {
    *32* tmp1 := dest << 32 | src
    *16* dest := (tmp1 << count) >> 16
    SHLDFLAGS16(dest, tmp1, count)
};

INSTRUCTION "SHLD.reg32.reg32.imm8" (dest, src, count) {
    *64* tmp1 := dest << 32 | src
    *32* dest := (tmp1 << count) >> 32
    SHLDFLAGS32(dest, tmp1, count)
};

INSTRUCTION "SHLD.reg32.reg32.imm32" (dest, src, count) {
    *64* tmp1 := dest << 32 | src
    *32* dest := (tmp1 << count) >> 32
    SHLDFLAGS32(dest, tmp1, count)
};

INSTRUCTION "SHLD.reg32.reg32.reg8" (dest, src, count) {
    *64* tmp1 := dest << 32 | src
    *32* dest := (tmp1 << count) >> 32
    SHLDFLAGS32(dest, tmp1, count)
};


# SHR
INSTRUCTION "SHR.reg8.imm8" (dest, src) {
    *8* tmpb := dest
    *8* dest := dest >> (src & 0x1F)
    SHRFLAGS8(dest, tmpb, src)
};

INSTRUCTION "SHR.reg8.reg8" (dest, src) {
    *8* tmpb := dest
    *8* dest := dest >> (src & 0x1F)
    SHRFLAGS8(dest, tmpb, src)
};

INSTRUCTION "SHR.reg16.imm8" (dest, src) {
    *16* tmph := dest
    *16* dest := dest >> (src & 0x1F)
    SHRFLAGS16(dest, tmph, src)
};

INSTRUCTION "SHR.reg16.imm16" (dest, src) {
    *16* tmph := dest
    *16* dest := dest >> (src & 0x1F)
    SHRFLAGS16(dest, tmph, src)
};

INSTRUCTION "SHR.reg16.reg8" (dest, src) {
    *16* tmph := dest
    *16* dest := dest >> (src & 0x1F)
    SHRFLAGS16(dest, tmph, src)
};

INSTRUCTION "SHR.reg32.imm8" (dest, src) {
    *32* tmp1 := dest
    *32* dest := dest >> (src & 0x1F)
    SHRFLAGS32(dest, tmp1, src)
};

INSTRUCTION "SHR.reg32.imm32" (dest, src) {
    *32* tmp1 := dest
    *32* dest := dest >> (src & 0x1F)
    SHRFLAGS32(dest, tmp1, src)
};

INSTRUCTION "SHR.reg32.reg8" (dest, src) {
    *32* tmp1 := dest
    *32* dest := dest >> (src & 0x1F)
    SHRFLAGS32(dest, tmp1, src)
};

INSTRUCTION "SHR.rm8.imm8" (dest, src) {
    *8* tmpb := dest
    *8* dest := dest >> (src & 0x1F)
    SHRFLAGS8(dest, tmpb, src)
};

INSTRUCTION "SHR.rm8.reg8" (dest, src) {
    *8* tmpb := dest
    *8* dest := dest >> (src & 0x1F)
    SHRFLAGS8(dest, tmpb, src)
};

INSTRUCTION "SHR.rm16.imm16" (dest, src) {
    *8* tmph := dest
    *8* dest := dest >> (src & 0x1F)
    SHRFLAGS16(dest, tmph, src)
};

INSTRUCTION "SHR.rm32.reg8" (dest, src) {
    *32* tmp1 := dest
    *32* dest := dest >> (src & 0x1F)
    SHRFLAGS32(dest, tmp1, src)
};

INSTRUCTION "SHR.rm32.imm32" (dest, src) {
    *32* tmp1 := dest
    *32* dest := dest >> (src & 0x1F)
    SHRFLAGS32(dest, tmp1, src)
};


# SHRD
INSTRUCTION "SHRD.reg16.reg16.imm8" (dest, src, count) {
    *32* tmp1 := src << 16 | dest
    *16* dest := tmp1 >> count
    SHRDFLAGS16(dest, tmp1, count)
};

INSTRUCTION "SHRD.reg16.reg16.imm16" (dest, src, count) {
    *32* tmp1 := src << 16 | dest
    *16* dest := tmp1 >> count
    SHRDFLAGS16(dest, tmp1, count)
};

INSTRUCTION "SHRD.reg16.reg16.reg8" (dest, src, count) {
    *32* tmp1 := src << 16 | dest
    *16* dest := tmp1 >> count
    SHRDFLAGS16(dest, tmp1, count)
};

INSTRUCTION "SHRD.reg32.reg32.imm8" (dest, src, count) {
    *64* tmp1 := (src << 32) | dest
    *32* dest := tmp1 >> count
    SHRDFLAGS32(dest, tmp1, count)
};

INSTRUCTION "SHRD.reg32.reg32.imm32" (dest, src, count) {
    *64* tmp1 := (src << 32) | dest
    *32* dest := tmp1 >> count
    SHRDFLAGS32(dest, tmp1, count)
};

INSTRUCTION "SHRD.reg32.reg32.reg8" (dest, src, count) {
    *64* tmp1 := (src << 32) | dest
    *32* dest := tmp1 >> count
    SHRDFLAGS32(dest, tmp1, count)
};


# STC
INSTRUCTION "STC" () {
    *1* %CF := 1
};


# STD
INSTRUCTION "STD" () {
    *1* %DF := 1
};


# STI
INSTRUCTION "STI" () {
    *1* %IF := 1
};


# SUB
INSTRUCTION "SUB.reg8.imm8" (dest, src) {
    *8* tmp1 := dest
    *8* dest := dest - src
    SUBFLAGS8(tmp1, src, dest)
};

INSTRUCTION "SUB.reg8.reg8" (dest, src) {
    *8* tmp1 := dest
    *8* dest := dest - src
    SUBFLAGS8(tmp1, src, dest)
};

INSTRUCTION "SUB.reg8.rm8" (dest, src) {
    *8* tmp1 := dest
    *8* dest := dest - src
    SUBFLAGS8(tmp1, src, dest)
};

INSTRUCTION "SUB.reg16.imm16" (dest, src) {
    *16* tmp1 := dest
    *16* dest := dest - src
    SUBFLAGS16(tmp1, src, dest)
};

INSTRUCTION "SUB.reg16.reg16" (dest, src) {
    *16* tmp1 := dest
    *16* dest := dest - src
    SUBFLAGS16(tmp1, src, dest)
};

INSTRUCTION "SUB.reg16.rm16" (dest, src) {
    *16* tmp1 := dest
    *16* dest := dest - src
    SUBFLAGS16(tmp1, src, dest)
};

INSTRUCTION "SUB.reg32.imm32" (dest, src) {
    *32* tmp1 := dest
    *32* dest := dest - src
    SUBFLAGS32(tmp1, src, dest)
};

INSTRUCTION "SUB.reg32.reg32" (dest, src) {
    *32* tmp1 := dest
    *32* dest := dest - src
    SUBFLAGS32(tmp1, src, dest)
};

INSTRUCTION "SUB.reg32.rm32" (dest, src) {
    *32* tmp1 := dest
    *32* dest := dest - src
    SUBFLAGS32(tmp1, src, dest)
};

INSTRUCTION "SUB.rm8.imm8" (dest, src) {
    *8* tmp1 := dest
    *8* dest := dest - src
    SUBFLAGS8(tmp1, src, dest)
};

INSTRUCTION "SUB.rm8.reg8" (dest, src) {
    *8* tmp1 := dest
    *8* dest := dest - src
    SUBFLAGS8(tmp1, src, dest)
};

INSTRUCTION "SUB.rm16.imm16" (dest, src) {
    *16* tmp1 := dest
    *16* dest := dest - src
    SUBFLAGS16(tmp1, src, dest)
};

INSTRUCTION "SUB.rm16.reg16" (dest, src) {
    *16* tmp1 := dest
    *16* dest := dest - src
    SUBFLAGS16(tmp1, src, dest)
};

INSTRUCTION "SUB.rm32.imm32" (dest, src) {
    *32* tmp1 := dest
    *32* dest := dest - src
    SUBFLAGS32(tmp1, src, dest)
};

INSTRUCTION "SUB.rm32.reg32" (dest, src) {
    *32* tmp1 := dest
    *32* dest := dest - src
    SUBFLAGS32(tmp1, src, dest)
};


# TEST
INSTRUCTION "TEST.reg8.imm8" (lhs, rhs) {
    *8* tmpb := lhs & rhs
    LOGICALFLAGS8(tmpb)
};

INSTRUCTION "TEST.reg8.reg8" (lhs, rhs) {
    *8* tmpb := lhs & rhs
    LOGICALFLAGS8(tmpb)
};

INSTRUCTION "TEST.reg16.imm16" (lhs, rhs) {
    *16* tmph := lhs & rhs
    LOGICALFLAGS16(tmph)
};

INSTRUCTION "TEST.reg16.reg16" (lhs, rhs) {
    *16* tmph := lhs & rhs
    LOGICALFLAGS16(tmph)
};

INSTRUCTION "TEST.reg32.imm32" (lhs, rhs) {
    *32* tmp1 := lhs & rhs
    LOGICALFLAGS32(tmp1)
};

INSTRUCTION "TEST.reg32.reg32" (lhs, rhs) {
    *32* tmp1 := lhs & rhs
    LOGICALFLAGS32(tmp1)
};

INSTRUCTION "TEST.rm8.imm8" (lhs, rhs) {
    *8* tmpb := lhs & rhs
    LOGICALFLAGS8(tmpb)
};

INSTRUCTION "TEST.rm8.reg8" (lhs, rhs) {
    *8* tmpb := lhs & rhs
    LOGICALFLAGS8(tmpb)
};

INSTRUCTION "TEST.rm16.imm16" (lhs, rhs) {
    *16* tmph := lhs & rhs
    LOGICALFLAGS16(tmph)
};

INSTRUCTION "TEST.rm16.reg16" (lhs, rhs) {
    *16* tmph := lhs & rhs
    LOGICALFLAGS16(tmph)
};

INSTRUCTION "TEST.rm32.imm32" (lhs, rhs) {
    *32* tmp1 := lhs & rhs
    LOGICALFLAGS32(tmp1)
};

INSTRUCTION "TEST.rm32.reg32" (lhs, rhs) {
    *32* tmp1 := lhs & rhs
    LOGICALFLAGS32(tmp1)
};


# UD2
INSTRUCTION "UD2" () {
    _
};


# WAIT
INSTRUCTION "WAIT" () {
    _
};


# XADD
INSTRUCTION "XADD.reg8.reg8" (dest, src) {
    *8* tmp_src := src
    *8* tmpb := src + dest
    *8* src := dest
    *8* dest := tmpb
    ADDFLAGS8(tmp_src, src, dest)
};

INSTRUCTION "XADD.rm8.reg8" (dest, src) {
    *8* tmp_src := src
    *8* tmpb := src + dest
    *8* src := dest
    *8* dest := tmpb
    ADDFLAGS8(tmp_src, src, dest)
};

INSTRUCTION "XADD.reg16.reg16" (dest, src) {
    *16* tmp_src := src
    *16* tmph := src + dest
    *16* src := dest
    *16* dest := tmph
    ADDFLAGS16(tmp_src, src, dest)
};

INSTRUCTION "XADD.rm16.reg16" (dest, src) {
    *16* tmp_src := src
    *16* tmph := src + dest
    *16* src := dest
    *16* dest := tmph
    ADDFLAGS16(tmp_src, src, dest)
};

INSTRUCTION "XADD.reg32.reg32" (dest, src) {
    *32* tmp_src := src
    *32* tmp1 := src + dest
    *32* src := dest
    *32* dest := tmp1
    ADDFLAGS32(tmp_src, src, dest)
};

INSTRUCTION "XADD.rm32.reg32" (dest, src) {
    *32* tmp_src := src
    *32* tmp1 := src + dest
    *32* src := dest
    *32* dest := tmp1
    ADDFLAGS32(tmp_src, src, dest)
};

INSTRUCTION "XADD.rm64.reg64" (dest, src) {
    *64* tmp_src := src
    *64* tmp1 := src + dest
    *64* src := dest
    *64* dest := tmp1
    ADDFLAGS64(tmp_src, src, dest)
};


# XCHG
INSTRUCTION "XCHG.reg8.reg8" (reg1, reg2) {
    *8* tmpreg := reg1
    *8* reg1 := reg2
    *8* reg2 := tmpreg
};

INSTRUCTION "XCHG.reg16.reg16" (reg1, reg2) {
    *16* tmpreg := reg1
    *16* reg1 := reg2
    *16* reg2 := tmpreg
};

INSTRUCTION "XCHG.reg32.reg32" (reg1, reg2) {
    *32* tmpreg := reg1
    *32* reg1 := reg2
    *32* reg2 := tmpreg
};

INSTRUCTION "XCHG.rm8.reg8" (reg1, reg2) {
    *8* tmpreg := reg1
    *8* reg1 := reg2
    *8* reg2 := tmpreg
};

INSTRUCTION "XCHG.rm16.reg16" (reg1, reg2) {
    *16* tmpreg := reg1
    *16* reg1 := reg2
    *16* reg2 := tmpreg
};

INSTRUCTION "XCHG.rm32.reg32" (reg1, reg2) {
    *32* tmpreg := reg1
    *32* reg1 := reg2
    *32* reg2 := tmpreg
};


# XLATB
INSTRUCTION "XLATB" () {
    *8* %al := m[%ebx + %al]
};


# XOR
INSTRUCTION "XOR.reg8.imm8" (dest, src) {
    *8* dest := dest ^ src
    LOGICALFLAGS8(dest)
};

INSTRUCTION "XOR.reg8.reg8" (dest, src) {
    *8* dest := (dest ^ src)
    LOGICALFLAGS8(dest)
};

INSTRUCTION "XOR.reg8.rm8" (dest, src) {
    *8* dest := (dest ^ src)
    LOGICALFLAGS8(dest)
};

INSTRUCTION "XOR.reg16.imm16" (dest, src) {
    *16* dest := dest ^ src
    LOGICALFLAGS16(dest)
};

INSTRUCTION "XOR.reg16.reg16" (dest, src) {
    *16* dest := dest ^ src
    LOGICALFLAGS16(dest)
};

INSTRUCTION "XOR.reg16.rm16" (dest, src) {
    *16* dest := dest ^ src
    LOGICALFLAGS16(dest)
};

INSTRUCTION "XOR.reg32.imm32" (dest, src) {
    *32* dest := dest ^ src
    LOGICALFLAGS32(dest)
};

INSTRUCTION "XOR.reg32.reg32" (dest, src) {
    *32* dest := dest ^ src
    LOGICALFLAGS32(dest)
};

INSTRUCTION "XOR.reg32.rm32" (dest, src) {
    *32* dest := dest ^ src
    LOGICALFLAGS32(dest)
};

INSTRUCTION "XOR.rm8.imm8" (dest, src) {
    *8* dest := dest ^ src
    LOGICALFLAGS8(dest)
};

INSTRUCTION "XOR.rm8.reg8" (dest, src) {
    *8* dest := dest ^ src
    LOGICALFLAGS8(dest)
};

INSTRUCTION "XOR.rm16.imm16" (dest, src) {
    *16* dest := dest ^ src
    LOGICALFLAGS16(dest)
};

INSTRUCTION "XOR.rm16.reg16" (dest, src) {
    *16* dest := dest ^ src
    LOGICALFLAGS16(dest)
};

INSTRUCTION "XOR.rm32.imm32" (dest, src) {
    *32* dest := dest ^ src
    LOGICALFLAGS32(dest)
};

INSTRUCTION "XOR.rm32.reg32" (dest, src) {
    *32* dest := dest ^ src
    LOGICALFLAGS32(dest)
};
