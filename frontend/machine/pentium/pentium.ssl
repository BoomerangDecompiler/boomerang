#
# Copyright (C) 1998-2001, The University of Queensland
# Copyright (C) 2001, Sun Microsystems, Inc
#
# See the file "LICENSE.TERMS" for information on usage and
# redistribution of this file, and for a DISCLAIMER OF ALL
# WARRANTIES.
#

# File: pentium.ssl
# Desc: This file contains a semantic description of the 80386 and 387
#       processors. 
#

# $Revision$		// 1.28.2.1
# 16 Oct 98 - Mike: lower case register names to be consistent with sparc
# 20 Nov 02 - Mike: Fixed MOV.ED.IVOD and MOV.EW.IVOW
# 20 Jul 04 - Mike: Fixed FISUB, FISUBR
# 01 Jul 05 - Mike: FIMUL, FIADD.i64 -> .i16

# Constants defined in hexadecimal (modelling manual) 
MAX8BITS  := 0xFF;
MAX16BITS := 0xFFFF;
MAX32BITS := 0xFFFFFFFF;
MAX64BITS := 0xFFFFFFFFFFFFFFFF;
MAX8POS   := 0x7F;
MAX8NEG   := 0x80;
MAX16POS  := 0x7FFF;
MAX16NEG  := 0x8000;
MAX32POS  := 0x7FFFFFFF;
MAX32NEG  := 0x80000000;

INTEGER
[ %eax, %ecx, %edx, %ebx,
  %esp, %ebp, %esi, %edi ][32] -> 24..31,
%ax[16] -> 0 SHARES %eax@[0..15],
%cx[16] -> 1 SHARES %ecx@[0..15],
%dx[16] -> 2 SHARES %edx@[0..15],
%bx[16] -> 3 SHARES %ebx@[0..15],
%sp[16] -> 4 SHARES %esp@[0..15],
%bp[16] -> 5 SHARES %ebp@[0..15],
%si[16] -> 6 SHARES %esi@[0..15],
%di[16] -> 7 SHARES %edi@[0..15],
%al[8]  -> 8 SHARES %ax@[0..7],
%cl[8]  -> 9 SHARES %cx@[0..7],
%dl[8]  -> 10 SHARES %dx@[0..7],
%bl[8]  -> 11 SHARES %bx@[0..7],
%ah[8]  -> 12 SHARES %ax@[8..15],
%ch[8]  -> 13 SHARES %cx@[8..15],
%dh[8]  -> 14 SHARES %dx@[8..15],
%bh[8]  -> 15 SHARES %bx@[8..15],
%es[8]  -> 16,
%cs[8]  -> 17,
%ss[8]  -> 18,
%ds[8]  -> 19,
%pc[32] -> -1,
[ %NF, %ZF, %AF, %PF,
  %CF, %OF, %DF, %IF,
  %FP, %SKIP, %RPT, %FLF,
  %C1, %C2, %FZF ][1] -> -1;

FLOAT
[ %st, %st1,        # stack head, stack neck
  %st2, %st3, %st4, %st5, %st6, %st7 ][80] -> 32..39;

INTEGER
# Note: for boomerang, we use the abstract floating point flags %fflags now
%fsw[16] -> 40, #Float status word(16 Bit register Containing information about
                #The state of the FPU.  stores the top of stack pointer
                #information aswell as the exception flags and stack fault
                #information)

%fstp[8] -> 41, #Floating point stack pointer.  Holds the top of stack pointer.
                #NB is bits 11->13 inclusive of the fsw(defined above).

%fcw[16] -> 42; #Floating point Control Word (16 bit register holding
                #information such as the infinity control, rounding control,
                #precision control and exception masks.


ADDFLAGS8(op1, op2, result)  {
            *1* %CF := ((op1@[7:7]) & (op2@[7:7]))
                        | (~(result@[7:7]) & ((op1@[7:7]) | (op2@[7:7])))
            *1* %OF := ((op1@[7:7]) & (op2@[7:7]) & ~(result@[7:7]))
                        | (~(op1@[7:7]) & ~(op2@[7:7]) & (result@[7:7]))
            *1* %NF := result@[7:7]
            *1* %ZF := [result = 0?1:0]
#           *1*  %PF := ??
#           *1*  %AF := ??                  # unpacked BCD
};

ADDFLAGS16(op1, op2, result)  {
            *1* %CF := ((op1@[15:15]) & (op2@[15:15]))
                        | (~(result@[15:15]) & ((op1@[15:15]) | (op2@[15:15])))
            *1* %OF := ((op1@[15:15]) & (op2@[15:15]) & ~(result@[15:15]))
                        | (~(op1@[15:15]) & ~(op2@[15:15]) & (result@[15:15]))
            *1* %NF := result@[15:15]
            *1* %ZF := [result = 0?1:0]
#           *1*  %PF := ??
#           *1*  %AF := ??                  # unpacked BCD
};

ADDFLAGS32(op1, op2, result)  {
            *1* %CF := ((op1@[31:31]) & (op2@[31:31]))
                        | (~(result@[31:31]) & ((op1@[31:31]) | (op2@[31:31])))
            *1* %OF := ((op1@[31:31]) & (op2@[31:31]) & ~(result@[31:31]))
                        | (~(op1@[31:31]) & ~(op2@[31:31]) & (result@[31:31]))
            *1* %NF := result@[31:31]
            *1* %ZF := [result = 0?1:0]
#           *1*  %PF := ??
#           *1*  %AF := ??                  # unpacked BCD
};

SUBFLAGS8(op1, op2, result)  {
            *1* %CF := (~(op1@[7:7]) & (op2@[7:7]))
                        | ((result@[7:7]) & (~(op1@[7:7]) | (op2@[7:7])))
            *1* %OF := ((op1@[7:7]) & ~(op2@[7:7]) & ~(result@[7:7]))
                        | (~(op1@[7:7]) & (op2@[7:7]) & (result@[7:7]))
            *1* %NF := result@[7:7]
            *1* %ZF := [result = 0?1:0]
#           *1*  %PF := ??
#           *1*  %AF := ??                  # unpacked BCD
};

SUBFLAGS16(op1, op2, result)  {
            *1* %CF := (~(op1@[15:15]) & (op2@[15:15]))
                        | ((result@[15:15]) & (~(op1@[15:15]) | (op2@[15:15])))
            *1* %OF := ((op1@[15:15]) & ~(op2@[15:15]) & ~(result@[15:15]))
                        | (~(op1@[15:15]) & (op2@[15:15]) & (result@[15:15]))
            *1* %NF := result@[15:15]
            *1* %ZF := [result = 0?1:0]
#       *1*  %PF := ??
#       *1*  %AF := ??                  # unpacked BCD
};

SUBFLAGS32(op1, op2, result)  {
            *1* %CF := (~(op1@[31:31]) & (op2@[31:31]))
                        | ((result@[31:31]) & (~(op1@[31:31]) | (op2@[31:31])))
            *1* %OF := ((op1@[31:31]) & ~(op2@[31:31]) & ~(result@[31:31]))
                        | (~(op1@[31:31]) & (op2@[31:31]) & (result@[31:31]))
            *1* %NF := result@[31:31]
            *1* %ZF := [result = 0?1:0]
#           *1*  %PF := ??
#           *1*  %AF := ??                  # unpacked BCD
};

SUBFLAGSFL(op1, op2) {
			*1* %CF := op1 < op2
			*1* %ZF := op1 = op2
};

LOGICALFLAGS8(result)  {
            *1* %CF := 0
            *1* %OF := 0
            *1* %ZF := [result = 0?1:0]
            *1* %NF := result@[7:7]
#           *1*  %PF := ??
#           *1*  %AF := ??
};

LOGICALFLAGS16(result)  {
            *1* %CF := 0
            *1* %OF := 0
            *1* %ZF := [result = 0?1:0]
            *1* %NF := result@[15:15]
#           *1*  %PF := ??
#           *1*  %AF := ??
};

LOGICALFLAGS32(result)  {
            *1* %CF := 0
            *1* %OF := 0
            *1* %ZF := [result = 0?1:0]
            *1* %NF := result@[31:31]
#           *1*  %PF := ??
#           *1*  %AF := ??
};

IMULTFLAGS8(result)  {
            *1* %CF := [(result@[7:15] = 0) or (result@[7:15] = 1)?1:0]
            *1* %OF := [(result@[7:15] = 0) or (result@[7:15] = 1)?1:0]
};

IMULTFLAGS16(result)  {
            *1* %CF := [(result@[15:31] = 0) or (result@[15:31] = 1)?1:0]
            *1* %OF := [(result@[15:31] = 0) or (result@[15:31] = 1)?1:0]
};

IMULTFLAGS32(result)  {
            *1* %CF := [(result@[31:63] = 0) or (result@[31:63] = 1)?1:0]
            *1* %OF := [(result@[31:63] = 0) or (result@[31:63] = 1)?1:0]
};

MULTFLAGS8(result)  {
            *1* %CF := [result@[8:15]?1:0]
            *1* %OF := [result@[8:15]?1:0]
};

MULTFLAGS16(result)  {
            *1* %CF := [result@[16:31]?1:0]
            *1* %OF := [result@[16:31]?1:0]
};

MULTFLAGS32(result)  {
            *1* %CF := [result@[32:63]?1:0]
            *1* %OF := [result@[32:63]?1:0]
};

ROLFLAGS8(result, op1, count)  {
            *1* %OF := [count = 1?(op1@[7:7])! = %CF:-1]
            *1* %CF := result@[7:7]
};

ROLFLAGS16(result, op1, count)  {
            *1* %OF := [count = 1?(op1@[15:15])! = %CF:-1]
            *1* %CF := result@[15:15]
};

ROLFLAGS32(result, op1, count)  {
            *1* %OF := [count = 1?(op1@[31:31])! = %CF:-1]
            *1* %CF := result@[31:31]
};

RORFLAGS8(result, op1, count)  {
            *1* %CF := result@[7:7]
            *1* %OF := [count = 1?(op1@[7:7])! = (op1@[6:6]):-1]
};

RORFLAGS16(result, op1, count)  {
            *1* %CF := result@[15:15]
            *1* %OF := [count = 1?(op1@[15:15])! = (op1@[14:14]):-1]
};

RORFLAGS32(result, op1, count)  {
            *1* %CF := result@[31:31]
            *1* %OF := [count = 1?(op1@[31:31])! = (op1@[30:30]):-1]
};

SALFLAGS8(result, op1, count)  {
            *1* %CF := op1@[(8 - count):(9 - count)]
            *1* %OF := [count = 1?(result@[7:7])! = %CF:-1]
};

SALFLAGS16(result, op1, count)  {
            *1* %CF := op1@[(16 - count):(17 - count)]
            *1* %OF := [count = 1?(result@[15:15])! = %CF:-1]
};

SALFLAGS32(result, op1, count)  {
            *1* %CF := op1@[(32 - count):(33 - count)]
            *1* %OF := [count = 1?(result@[31:31])! = %CF:-1]
};

SARFLAGS(result, op1, count)  {
            *1* %CF := op1@[(count - 1):count]
            *1* %OF := [count = 1?0:-1]
};

SHRFLAGS8(result, op1, count)  {
            *1* %CF := op1@[(count - 1):count]
            *1* %OF := [count = 1?(result@[7:7])! = %CF:-1]
};

SHRFLAGS16(result, op1, count)  {
            *1* %CF := op1@[(count - 1):count]
            *1* %OF := [count = 1?(result@[15:15])! = %CF:-1]
};

SHRFLAGS32(result, op1, count)  {
            *1* %CF := op1@[(count - 1):count]
            *1* %OF := [count = 1?(result@[31:31])! = %CF:-1]
};

SHLDFLAGS32(result, combine, count)  {
            *1* %CF := combine@[(32 - count):(33 - count)]
            *1* %OF := [count = 1?(result@[31:31])! = %CF:-1]
};

SHLDFLAGS64(result, combine, count)  {
            *1* %CF := combine@[(64 - count):(65 - count)]
            *1* %OF := [count = 1?(result@[63:64])! = %CF:-1]
};

SHRDFLAGS32(result, combine, count)  {
            *1* %CF := combine@[(count - 1):count]
            *1* %OF := [count = 1?(result@[31:31])! = %CF:-1]
};

SHRDFLAGS64(result, combine, count)  {
            *1* %CF := combine@[(count - 1):count]
            *1* %OF := [count = 1?(result@[63:64])! = %CF:-1]
};

SETFFLAGS(op1, op2)  {
            *1* %FZF := [(op1 = op2) ? 1 : 0]
            *1* %FLF := [(op1 < op2) ? 1 : 0]
            *1* %C2 := 0 # [ (op1 > op2) ? 1 : 0]
};

OP1 := { "+", "-" };
ARIT := { "ADD", "SUB" };

ARIT[IDX]^"IAL" i8 
            *8* tmpb := %al
            *8* %al := %al OP1[IDX] i8;
ADD.IAL   i8 ADDFLAGS8(tmpb, i8, %al);
SUB.IAL   i8 SUBFLAGS8(tmpb, i8, %al);

ARIT[IDX]^"IAX" i16 
            *16* tmph := %ax
            *16* %ax := %ax OP1[IDX] i16;
ADD.IAX   i16 ADDFLAGS16(tmph, i16, %ax);
SUB.IAX   i16 SUBFLAGS16(tmph, i16, %ax);

ARIT[IDX]^"IEAX" i32 
            *32* tmp1 := %eax
            *32* %eax := %eax OP1[IDX] i32;
ADD.IEAX   i32 ADDFLAGS32(tmp1, i32, %eax);
SUB.IEAX   i32 SUBFLAGS32(tmp1, i32, %eax);

ARIT[IDX]^"ID" modrm, i32 
            *32* tmp1 := modrm
            *32* modrm := modrm OP1[IDX] i32;
ADD.ID   modrm, i32 ADDFLAGS32(tmp1, i32, modrm);
SUB.ID   modrm, i32 SUBFLAGS32(tmp1, i32, modrm);

ARIT[IDX]^"IW" modrm, i16 
            *16* tmph := modrm
            *16* modrm := modrm OP1[IDX] i16;
ADD.IW   modrm, i16 ADDFLAGS16(tmph, i16, modrm);
SUB.IW   modrm, i16 SUBFLAGS16(tmph, i16, modrm);

ARIT[IDX]^"IB" modrm, i8 
            *8* tmpb := modrm
            *8* modrm := modrm OP1[IDX] i8;
ADD.IB   modrm, i8 ADDFLAGS8(tmpb, i8, modrm);
SUB.IB   modrm, i8 SUBFLAGS8(tmpb, i8, modrm);

ARIT[IDX]^"IOWB" modrm, i8 
            *16* tmph := modrm
            *16* modrm := modrm OP1[IDX] i8;
ADD.IOWB   modrm, i8 ADDFLAGS16(tmph, i8, modrm);
SUB.IOWB   modrm, i8 SUBFLAGS16(tmph, i8, modrm);

ARIT[IDX]^"IODB" modrm, i8 
            *32* tmp1 := modrm
            *32* modrm := modrm OP1[IDX] i8;
ADD.IODB   modrm, i8 ADDFLAGS32(tmp1, i8, modrm);
SUB.IODB   modrm, i8 SUBFLAGS32(tmp1, i8, modrm);

ARIT[IDX]^"MRB" modrm, reg8 
            *8* tmpb := modrm
            *8* modrm := tmp1 OP1[IDX] reg8;
ADD.MRB   modrm, reg8 ADDFLAGS8(tmpb, reg8, modrm);
SUB.MRB   modrm, reg8 SUBFLAGS8(tmpb, reg8, modrm);

ARIT[IDX]^"MROW" modrm, reg16 
            *16* tmph := modrm
            *16* modrm := tmp1 OP1[IDX] reg16;
ADD.MROW   modrm, reg16 ADDFLAGS16(tmph, reg16, modrm);
SUB.MROW   modrm, reg16 SUBFLAGS16(tmph, reg16, modrm);

ARIT[IDX]^"MROD" modrm, reg32 
            *32* tmp1 := modrm
            *32* modrm := modrm OP1[IDX] reg32;
ADD.MROD   modrm, reg32 ADDFLAGS32(tmp1, reg32, modrm);
SUB.MROD   modrm, reg32 SUBFLAGS32(tmp1, reg32, modrm);

ARIT[IDX]^"RMB" reg8, modrm 
            *8* tmpb := reg8
            *8* reg8 := reg8 OP1[IDX] modrm{8};
ADD.RMB   reg8, modrm ADDFLAGS8(tmpb, modrm{8}, reg8);
SUB.RMB   reg8, modrm SUBFLAGS8(tmpb, modrm{8}, reg8);

ARIT[IDX]^"RMOW" reg16, modrm 
            *16* tmph := reg16
            *16* reg16 := reg16 OP1[IDX] modrm{16};
ADD.RMOW   reg16, modrm ADDFLAGS16(tmph, modrm{16}, reg16);
SUB.RMOW   reg16, modrm SUBFLAGS16(tmph, modrm{16}, reg16);

ARIT[IDX]^"RMOD" reg32, modrm 
            *32* tmp1 := reg32
            *32* reg32 := reg32 OP1[IDX] modrm;
ADD.RMOD   reg32, modrm ADDFLAGS32(tmp1, modrm, reg32);
SUB.RMOD   reg32, modrm SUBFLAGS32(tmp1, modrm, reg32);

BSWAP       reg32
            *32* tmp1 := zfill(8, 32, reg32@[31:24])
            *32* tmp2 := zfill(8, 32, reg32@[23:16])
            *32* tmp3 := zfill(8, 32, reg32@[15: 8])
            *32* tmp4 := reg32 & 0xFF
            *32* reg32 := (tmp4 << 24) + (tmp3 << 16) + (tmp2 << 8) + tmp1;

CMP.IAL   i8 
            *8* tmpb := %al - i8
            SUBFLAGS8(%al, i8, tmpb);

CMP.IAX   i16 
            *16* tmph := %ax - i16
            SUBFLAGS16(%ax, i16, tmph);

CMP.IEAX   i32 
            *32* tmp1 := %eax - i32
            SUBFLAGS32(%eax, i32, tmp1);

CMP.ID   modrm, i32 
            *32* tmp1 := modrm{32} - i32
            SUBFLAGS32(modrm, i32, tmp1);

CMP.IW   modrm, i16 
            *16* tmph := modrm{16} - i16
            SUBFLAGS16(modrm{16}, i16, tmph);

CMP.IB   modrm, i8 
            *8* tmpb := modrm{8} - i8
            SUBFLAGS8(modrm{8}, i8, tmpb);

CMP.MRB   modrm, reg8 
            *8* tmpb := modrm{8} - reg8
            SUBFLAGS8(modrm{8}, reg8, tmpb);

CMP.RMB   reg8, modrm 
            *8* tmpb := reg8 - modrm{8}
            SUBFLAGS8(reg8, modrm{8}, tmpb);

CMP.IODB   modrm, i8 
            *32* tmp1 := modrm{32} - i8
            SUBFLAGS32(modrm{32}, i8, tmp1);

CMP.IOWB   modrm, i8 
            *16* tmph := modrm{16} - i8
            SUBFLAGS16(modrm{16}, i8, tmph);

CMP.MROW   modrm, reg16 
            *16* tmph := modrm{16} - reg16
            SUBFLAGS16(modrm{16}, reg16, tmph);

CMP.MROD   modrm, reg32 
            *32* tmp1 := modrm{32} - reg32
            SUBFLAGS32(modrm{32}, reg32, tmp1);

CMP.RMOW   reg16, modrm 
            *16* tmph := reg16 - modrm{16}
            SUBFLAGS16(reg16, modrm{16}, tmph);

CMP.RMOD   reg32, modrm 
            *32* tmp1 := reg32 - modrm{32}
            SUBFLAGS32(reg32, modrm{32}, tmp1);

OP1 := { "&", "|", "^" };
LOG := { "AND", "OR", "XOR" };

LOG[IDX]^"IAL" i8 
            *8* %al := %al OP1[IDX] i8
            LOGICALFLAGS8(%al);

LOG[IDX]^"IAX" i16 
            *16* %ax := %ax OP1[IDX] i16
            LOGICALFLAGS16(%ax);

LOG[IDX]^"IEAX" i32 
            *32* %eax := %eax OP1[IDX] i32
            LOGICALFLAGS32(%eax);

LOG[IDX]^"ID" modrm, i32 
            *32* modrm := modrm{32} OP1[IDX] i32
            LOGICALFLAGS32(modrm);

LOG[IDX]^"IW" modrm, i16 
            *16* modrm := modrm{16} OP1[IDX] i16
            LOGICALFLAGS16(modrm);

LOG[IDX]^"IB" modrm, i8 
            *8* modrm := modrm{8} OP1[IDX] i8
            LOGICALFLAGS8(modrm);

LOG[IDX]^"IOWB" modrm, i8 
            *16* modrm := modrm OP1[IDX] sgnex(8, 16, i8)
            LOGICALFLAGS16(modrm);

LOG[IDX]^"IODB" modrm, i8 
            *32* modrm := modrm OP1[IDX] sgnex(8, 32, i8)
            LOGICALFLAGS32(modrm);

LOG[IDX]^"MRB" modrm, reg8 
            *8* modrm := modrm{8} OP1[IDX] reg8
            LOGICALFLAGS8(modrm);

LOG[IDX]^"MROW" modrm, reg16 
            *16* modrm := modrm{16} OP1[IDX] reg16
            LOGICALFLAGS16(modrm);

LOG[IDX]^"MROD" modrm, reg32 
            *32* modrm := modrm{32} OP1[IDX] reg32
            LOGICALFLAGS32(modrm);

LOG[IDX]^"RMB" reg8, modrm 
            *8* reg8 := reg8 OP1[IDX] modrm{8}
            LOGICALFLAGS8(reg8);

LOG[IDX]^"RMOW" reg16, modrm 
            *16* reg16 := reg16 OP1[IDX] modrm{16}
            LOGICALFLAGS16(reg16);

LOG[IDX]^"RMOD" reg32, modrm 
            *32* reg32 := reg32 OP1[IDX] modrm{32}
            LOGICALFLAGS32(reg32);

OP2 := { "+", "-" };
ARITH_C := { "ADC", "SBB" };

ARITH_C[IDX]^"IAL" i8 
            *8* tmp1 := %al
            *8* %al := %al OP2[IDX] i8 OP2[IDX] %CF;
ADC.IAL   i8 ADDFLAGS8(tmp1, i8, %al);
SBB.IAL   i8 SUBFLAGS8(tmp1, i8, %al);
ARITH_C[IDX]^"IAL"   i8 _;

ARITH_C[IDX]^"IAX" i16 
            *16* tmp1 := %ax
            *16* %ax := %ax OP2[IDX] i16 OP2[IDX] %CF;
ADCIAX   i16 ADDFLAGS16(tmp1, i16, %ax);
SBBIAX   i16 SUBFLAGS16(tmp1, i16, %ax);

ARITH_C[IDX]^"IEAX" i32 
            *32* tmp1 := %eax
            *32* %eax := %eax OP2[IDX] i32 OP2[IDX] %CF;
ADC.IEAX   i32 ADDFLAGS32(tmp1, i32, %eax);
SBB.IEAX   i32 SUBFLAGS32(tmp1, i32, %eax);

ARITH_C[IDX]^"ID" reg32, i32 
            *32* tmp1 := reg32
            *32* reg32 := reg32 OP2[IDX] i32 OP2[IDX] %CF;
ADC.ID   reg32, i32 ADDFLAGS32(tmp1, i32, reg32);
SBB.ID   reg32, i32 SUBFLAGS32(tmp1, i32, reg32);

ARITH_C[IDX]^"IW" reg16, i16 
            *16* tmp1 := reg16
            *16* reg16 := reg16 OP2[IDX] i16 OP2[IDX] %CF;
ADC.IW   reg16, i16 ADDFLAGS16(tmp1, i16, reg16);
SBB.IW   reg16, i16 SUBFLAGS16(tmp1, i16, reg16);

ARITH_C[IDX]^"IB" reg8, i8 
            *8* tmp1 := reg8
            *8* reg8 := reg8 OP2[IDX] i8 OP2[IDX] %CF;
ADC.IB   reg8, i8 ADDFLAGS8(tmp1, i8, reg8);
SBB.IB   reg8, i8 SUBFLAGS8(tmp1, i8, reg8);

ARITH_C[IDX]^"IODB" reg32, i8 
            *32* tmp1 := reg32
            *32* reg32 := reg32 OP2[IDX] i8 OP2[IDX] %CF;
ADC.IODB   reg32, i8 ADDFLAGS32(tmp1, i8, reg32);
SBB.IODB   reg32, i8 SUBFLAGS32(tmp1, i8, reg32);

ARITH_C[IDX]^"MRB" modrm, reg8 
            *8* tmp1 := modrm
            *8* modrm := tmp1 OP2[IDX] reg8 OP2[IDX] %CF;
ADC.MRB   modrm, reg8 ADDFLAGS8(tmp1, reg8, modrm);
SBB.MRB   modrm, reg8 SUBFLAGS8(tmp1, reg8, modrm);

ARITH_C[IDX]^"MROW" modrm, reg16 
            *16* tmp1 := modrm{16}
            *16* modrm := tmp1 OP2[IDX] reg16 OP2[IDX] %CF;
ADC.MROW   modrm, reg16 ADDFLAGS16(tmp1, reg16, modrm{16});
SBB.MROW   modrm, reg16 SUBFLAGS16(tmp1, reg16, modrm{16});

ARITH_C[IDX]^"MROD" modrm, reg32 
            *32* tmp1 := modrm
            *32* modrm := modrm OP2[IDX] reg32 OP2[IDX] %CF;
ADC.MROD   modrm, reg32 ADDFLAGS32(tmp1, reg32, modrm);
SBB.MROD   modrm, reg32 SUBFLAGS32(tmp1, reg32, modrm);

ARITH_C[IDX]^"RMB" reg8, modrm 
            *8* tmpb := reg8
            *8* reg8 := reg8 OP2[IDX] modrm{8} OP2[IDX] %CF;
ADC.RMB   reg8, modrm ADDFLAGS8(tmpb, modrm{8}, reg8);
SBB.RMB   reg8, modrm SUBFLAGS8(tmpb, modrm{8}, reg8);

ARITH_C[IDX]^"RMOW" reg16, modrm 
            *16* tmph := reg16
            *16* reg16 := reg16 OP2[IDX] modrm{16} OP2[IDX] %CF;
ADC.RMOW   reg16, modrm ADDFLAGS16(tmph, modrm{16}, reg16);
SBB.RMOW   reg16, modrm SUBFLAGS16(tmph, modrm{16}, reg16);

ARITH_C[IDX]^"RMOD" reg32, modrm 
            *32* tmp1 := reg32
            *32* reg32 := reg32 OP2[IDX] modrm OP2[IDX] %CF;
ADC.RMOD   reg32, modrm ADDFLAGS32(tmp1, modrm, reg32);
SBB.RMOD   reg32, modrm SUBFLAGS32(tmp1, modrm, reg32);

BT.od   modrm, reg32 
            *1* %CF := modrm@[reg32:reg32];

BTR.od   modrm, reg32 
            *32* tmp1 := 1 << reg32
            *1* %CF := modrm@[reg32:reg32]
            *32* modrm := modrm & ~(tmp1);

BTC.od   modrm, reg32 
            *32* tmp1 := 1 << reg32
            *1* %CF := modrm@[reg32:reg32]
            *32* modrm := modrm ^ tmp1;

BTS.od   modrm, reg32 
            *32* tmp1 := 1 << reg32
            *1* %CF := modrm@[reg32:reg32]
            *32* modrm := modrm | tmp1;

CALL.JVOW   reloc16 
            *32* %esp := %esp - 2
            *16* m[%esp] := truncs(32,16,%pc)
            *32* %pc := %pc + 3 + reloc16;

# Note: the last assignment is not correct. reloc[16 32] is the *host*
# *destination*, not the offset (the offset is not avialable to the SSL, nor
# is the "delta" required to convert from host to native.
# Corrected in the matcher file
CALL.Jvod   reloc32 
            *32* %esp := %esp - 4
            *32* m[%esp] := %pc
            *32* %pc := %pc + 5 + reloc32;

CALL.APOD   seg, off 
            *32* %esp := %esp - 2
            *32* m[%esp] := %cs
            *32* %cs := seg
            *32* %esp := %esp - 4
            *16* m[%esp] := %pc
            *16* %pc := off;

CALL.EVOW   modrm 
            *32* %esp := %esp - 2
            *16* m[%esp] := truncs(32,16,%pc)
            *32* %pc := modrm{16};

CALL.EVOD   modrm 
            *32* %esp := %esp - 4
            *32* m[%esp] := %pc
            *32* %pc := modrm;

CBW    
            *16* %ax := sgnex(8, 16, %al);

CWDE    
            *32* %eax := sgnex(16,32,%ax);

CLC    
            *1* %CF := 0;

CLD    
            *1* %DF := 0;

CLI    
            *1* %IF := 0;

CMC    
            *1* %CF := ~(%CF);

CMPXCHG.EV.GB   modrm, reg8 
            *8* tmpb := modrm{8}
            *8* modrm := [%al = tmpb?reg8:tmpb]
            *8* %al := [%al = tmpb?%al:tmpb]
            *1* %ZF := [%al = tmpb?1:0];

CMPXCHG.EV.GVOW   modrm, reg16 
            *16* tmph := modrm{16}
            *16* modrm := [%ax = tmph?reg16:tmph]
            *16* %ax := [%ax = tmph?%ax:tmph]
            *1* %ZF := [%ax = tmph?1:0];

CMPXCHG.EV.GVOD   modrm, reg32 
            *32* tmp1 := modrm
            *32* modrm := [%eax = tmp1?reg32:tmp1]
            *32* %eax := [%eax = tmp1?%eax:tmp1]
            *1* %ZF := [%eax = tmp1?1:0];

CWD    
            *16* %dx := [%ax < 0?-1:0];

CDQ    
            *32* %edx := [%eax < 0?-1:0];

# Note that decrement doesn't set the carry flag, so none of the carry related compares, which need SUBFLAGS, should
# ever be needed. If the carry flag IS used, then it will depend on earlier SUBFLAGS, and Boomerang won't handle that
# yet. Use LOGICALFLAGS below to help reduce the problem of etraneous variables caused by reference to the operands of
# the decrement, since these will cause liveness overlaps.
OP4 := { "-", "+" };
DEC_INC := { "DEC", "INC" };

DEC_INC[IDX].EB modrm 
            *8* tmpb := modrm{8}
            *8* modrm := modrm{8} OP4[IDX] 1;
#DEC.EB   modrm SUBFLAGS8(tmpb, 1, modrm{8});
#INC.EB   modrm ADDFLAGS8(tmpb, 1, modrm{8});
DEC.EB   modrm LOGICALFLAGS8(modrm{8});
INC.EB   modrm LOGICALFLAGS8(modrm{8});

DEC_INC[IDX].EVOW modrm 
            *16* tmph := modrm{16}
            *16* modrm := modrm{16} OP4[IDX] 1;
#DEC.EVOW   modrm SUBFLAGS16(tmph, 1, modrm{16});
#INC.EVOW   modrm ADDFLAGS16(tmph, 1, modrm{16});
DEC.EVOW   modrm LOGICALFLAGS16(modrm{16});
INC.EVOW   modrm LOGICALFLAGS16(modrm{16});

DEC_INC[IDX].EVOD modrm 
            *32* tmp1 := modrm
            *32* modrm := modrm OP4[IDX] 1;
#DEC.EVOD   modrm SUBFLAGS32(tmp1, 1, modrm);
#INC.EVOD   modrm ADDFLAGS32(tmp1, 1, modrm);
DEC.EVOD   modrm LOGICALFLAGS32(modrm);
INC.EVOD   modrm LOGICALFLAGS32(modrm);

DEC_INC[IDX].OW reg16 
            *16* tmph := reg16
            *16* reg16 := reg16 OP4[IDX] 1;
#DEC.OW   reg16 SUBFLAGS16(tmph, 1, reg16);
#INC.OW   reg16 ADDFLAGS16(tmph, 1, reg16);
DEC.OW   reg16 LOGICALFLAGS16(tmph, 1, reg16);
INC.OW   reg16 LOGICALFLAGS16(tmph, 1, reg16);

DEC_INC[IDX].OD reg32 
            *32* tmp1 := reg32
            *32* reg32 := reg32 OP4[IDX] 1;
#DEC.OD   reg32 SUBFLAGS32(tmp1, 1, reg32);
#INC.OD   reg32 ADDFLAGS32(tmp1, 1, reg32);
DEC.OD   reg32 LOGICALFLAGS32(reg32);
INC.OD   reg32 LOGICALFLAGS32(reg32);

DIV.AL   modrm 
            *16* tmph := %ax
            *8* %al := tmph / modrm{8}
            *8* %ah := tmph % modrm{8}
            undefineflags( );

DIV.AX   modrm 
            *32* tmp1 := (zfill(16,32,%dx) << 16) | zfill(16,32,%ax)
            *16* tmph := modrm{16}
            *16* %ax := tmp1 / tmph
            *16* %dx := tmp1 % tmph
            undefineflags( );

DIV.EAX   modrm 
            *64* tmpl := (zfill(32,64,%edx) << 32) | zfill(32,64,%eax)
            *32* tmp2 := modrm
            *32* %eax := tmpl / tmp2
            *32* %edx := tmpl % tmp2
            undefineflags( );

ENTER   i16, i8 
            *32* tmpb := i8
            *32* %esp := %esp - 4
            *32* m[%esp] := %ebp
            *32* %FP := %esp
            *32* %ebp := %FP
            *32* %esp := %esp - i16;

IDIV   modrm 
            *16* tmph := %ax
            *8* %al := tmph /! modrm{8}
            *8* %ah := tmph %! modrm{8}
            undefineflags( );

IDIV.AX   modrm 
            *32* tmp1 := (%dx << 16) | %ax
            *16* tmph := modrm{16}
            *16* %ax := tmp1 /! tmph
            *16* %dx := tmp1 %! tmph
            undefineflags( );

IDIV.EAX   modrm 
            *64* tmpl := (%edx << 32) | %eax
            *32* tmp2 := modrm
            *32* %eax := tmpl /! tmp2
            *32* %edx := tmpl %! tmp2
            undefineflags( );

IMUL.B   modrm 
            *16* tmph := %al *! modrm{8}
            *16* %ax := tmph
            IMULTFLAGS8(tmph);

IMUL.OW   modrm 
            *32* tmp2 := %ax *! modrm
            *16* %ax := truncu(32,16,tmp2)
            *16* %dx := truncu(32,16,tmp2 >> 16)
            IMULTFLAGS16(tmp2);

IMUL.OD   modrm 
            *64* tmpl := %eax *! modrm
            *32* %eax := truncu(64,32,tmpl)
            *32* %edx := truncu(64,32,tmpl >> 32)
            IMULTFLAGS32(tmpl);

IMUL.RMOW   reg16, modrm 
            *16* reg16 := modrm{16} *! reg16
            IMULTFLAGS16(reg16);

IMUL.RMOD   reg32, modrm 
            *32* reg32 := modrm{32} *! reg32
            IMULTFLAGS32(reg32);

IMUL.IVW   reg16, modrm, i16 
            *16* reg16 := modrm{16} *! i16
            IMULTFLAGS16(reg16);

IMUL.IVD   reg32, modrm, i32 
            *32* reg32 := modrm{32} *! i32
            IMULTFLAGS32(reg32);

IMUL.Ibow   reg16, modrm, i8 
            *16* reg16 := modrm{8} *! sgnex(8,16,i8)
            IMULTFLAGS32(reg16);

IMUL.Ibod   reg32, modrm, i8 
            *32* reg32 := modrm{32} *! sgnex(8,32,i8)
            IMULTFLAGS32(reg32);

INT3
			_ ;			# Not expected to be seen in correct code, but decode anyway

COND1 := { "~%CF & ~%ZF", "~%CF & ~%ZF", "~%CF", "~%CF", "%CF",
            "%CF", "%CF | %ZF", "%CF | %ZF", "%CF", "~%cx", "%ZF",
            "%ZF", "~(%NF ^ %OF) & ~%ZF", "~(%NF ^ %OF) & ~%ZF",
            "~(%NF ^ %OF)", "~(%NF ^ %OF)", "%NF ^ %OF", "%NF ^ %OF",
            "(%NF ^ %OF) | %ZF", "(%NF ^ %ZF) | %ZF", "~%CF", "~%ZF",
            "~%ZF", "~%OF", "~%PF", "~%PF", "~%NF", "%OF", "%PF", "%PF", "%NF" };
JMP32S := { "JVA", "JVNBE", "JVAE", "JVNB", "JVB", "JVNAE", "JVBE",
            "JVNA", "JVC", "JVCXZ", "JVE", "JVZ", "JVG", "JVNLE", "JVGE",
            "JVNL", "JVL", "JVNGE", "JVLE", "JVNG", "JVNC", "JVNE", "JVNZ",
            "JVNO", "JVNP", "JVPO", "JVNS", "JVO", "JVP", "JVPE", "JVS" };

JMP32S[IDX]   reloc32 
            *32* %pc := [(COND1[IDX] = 1)?%pc + 6 + reloc32:%pc];

COND2 := { "~%CF & ~%ZF", "~%CF & ~%ZF", "~%CF", "~%CF", "%CF",
           "%CF", "%CF | %ZF", "%CF | %ZF", "%CF", "~%cx", "%ZF",
           "%ZF", "~(%NF ^ %OF) & ~%ZF", "~(%NF ^ %OF) & ~%ZF", "~(%NF ^ %OF)",
           "~(%NF ^ %OF)", "%NF ^ %OF", "%NF ^ %OF", "(%NF ^ %OF) | %ZF",
           "(%NF ^ %ZF) | %ZF", "~%CF", "~%ZF", "~%ZF", "~%OF", "~%PF",
           "~%PF", "~%NF", "%OF", "%PF", "%PF", "%NF" };
JMP16S := { "JWA", "JWNBE", "JWAE", "JWNB", "JWB", "JWNAE", "JWBE",
            "JWNA", "JWC", "JWCXZ", "JWE", "JWZ", "JWG", "JWNLE", "JWGE",
            "JWNL", "JWL", "JWNGE", "JWLE", "JWNG", "JWNC", "JWNE", "JWNZ",
            "JWNO", "JWNP", "JWPO", "JWNS", "JWO", "JWP", "JWPE", "JWS" };

JMP16S[IDX]   reloc16 
            *32* %pc := [(COND2[IDX] = 1)?%pc + 4 + reloc16:%pc];

COND3 := { "~%CF & ~%ZF", "~%CF & ~%ZF", "~%CF", "~%CF", "%CF",
           "%CF", "%CF | %ZF", "%CF | %ZF", "%CF", "~%cx", "%ZF",
           "%ZF", "~(%NF ^ %OF) & ~%ZF", "~(%NF ^ %OF) & ~%ZF", "~(%NF ^ %OF)",
           "~(%NF ^ %OF)", "%NF ^ %OF", "%NF ^ %OF", "(%NF ^ %OF) | %ZF",
           "(%NF ^ %ZF) | %ZF", "~%CF", "~%ZF", "~%ZF", "~%OF", "~%PF",
           "~%PF", "~%NF", "%OF", "%PF", "%PF", "%NF" };
JMP8S := { "JBA", "JBNBE", "JBAE", "JBNB", "JBB", "JBNAE", "JBBE", "JBNA",
           "JBC", "JBCXZ", "JBE", "JBZ", "JBG", "JBNLE", "JBGE", "JBNL",
           "JBL", "JBNGE", "JBLE", "JBNG", "JBNC", "JBNE", "JBNZ", "JBNO",
           "JBNP", "JBPO", "JBNS", "JBO", "JBP", "JBPE", "JBS" };

JMP8S[IDX]   reloc8 
            *32* %pc := [(COND3[IDX] = 1)?%pc + 2 + reloc8:%pc];

JMP.JB   reloc8 
            *32* %pc := %pc + 2 + reloc8;

JMP.JVOW   reloc16 
            *32* %pc := %pc + 3 + reloc16;

JMP.JVOD   reloc32 
            *32* %pc := %pc + 5 + reloc32;

JMP.EVOW   modrm 
            *16* %pc := modrm;

JMP.EVOD   modrm 
            *32* %pc := modrm;

LAHF
			*8*  %ah := %CF + (%ZF << 6) + (%NF << 7);

LEA.OD   reg32, mem 
            *32* reg32 := addr(mem);

LEA.OW   reg16, mem 
            *16* reg16 := addr(mem);

LEAVE    
            *32* %esp := %ebp
            *32* %ebp := m[%esp]
            *32* %esp := %esp + 4;

COND4 := { "%ecx ~= 0", "%ecx ~= 0 & %ZF", "%ecx ~= 0 & %ZF",
           "%ecx ~= 0 & ~%ZF", "%ecx ~= 0 & ~%ZF" };
LOOPS := { "LOOP", "LOOPE", "LOOPZ", "LOOPNE", "LOOPNZ" };

LOOPS[IDX]   reloc 
            *32* %ecx := %ecx - 1
            *32* %pc := [COND4[IDX]?%pc + reloc:%pc];

MOV.EB.IB   modrm, i8 
            *8* modrm := i8;

MOV.EW.IVOW   modrm, i16 
            *16* modrm := i16;

MOV.ED.IVOD   modrm, i32 
            *32* modrm := i32;

MOV.IB   reg8, i8 
            *8* reg8 := i8;

MOV.IW   reg16, i16 
            *16* reg16 := i16;

MOV.ID   reg32, i32 
            *32* reg32 := i32;

MOV.MRB   modrm, reg8 
            *8* modrm := reg8;

MOV.MROW   modrm, reg16 
            *16* modrm := reg16;

MOV.MROD   modrm, reg32 
            *32* modrm := reg32;

MOV.OB.AL   off 
            *8* m[off] := %al;

MOV.OV.EAXOW   off 
            *16* m[off] := %ax;

MOV.OV.EAXOD   off 
            *32* m[off] := %eax;

MOV.AL.OB   off 
            *8* %al := m[off]{8};

MOV.EAX.OVOW   off 
            *16* %ax := m[off]{16};

MOV.EAX.OVOD   off 
            *32* %eax := m[off]{32};

MOV.RMB   reg8, modrm 
            *8* reg8 := modrm{8};

MOV.RMOW   reg16, modrm 
            *16* reg16 := modrm{16};

MOV.RMOD   reg32, modrm 
            *32* reg32 := modrm{32};

MOVSX.GV.EBOW   reg16, modrm 
            *16* reg16 := sgnex(8, 16, modrm{8});

MOVSX.GV.EBOD   reg32, modrm 
            *32* reg32 := sgnex(8, 32, modrm{8});

MOVSX.GV.EW   reg32, modrm 
            *32* reg32 := sgnex(16, 32, modrm{16});

MOVZX.GV.EBOW   reg16, modrm 
            *16* reg16 := zfill(8, 16, modrm{8});

MOVZX.GV.EBOD   reg32, modrm 
            *32* reg32 := zfill(8, 32, modrm{8});

MOVZX.GV.EW   reg32, modrm 
            *32* reg32 := zfill(16, 32, modrm{16});

MUL^"AL"   modrm 
            *8* tmpb := modrm{8}
            *16* %ax := %al * tmpb
            MULTFLAGS8(%ax);

MUL.AXOW   modrm 
            *32* tmp2 := %eax * modrm{16}
            *16* %ax := tmp2
            *16* %dx := tmp2 >> 16
            MULTFLAGS16(tmp2);

MUL.AXOD   modrm 
            *32* tmp1 := modrm{32}
            *64* tmpl := zfill(32,64,%eax) * zfill(32,64,tmp1)
            *32* %eax := tmpl
            *32* %edx := tmpl >> 32
            MULTFLAGS32(tmpl);

NEG.B   modrm 
            *8* tmpb := modrm{8}
            *8* modrm := 0 - modrm{8}
            SUBFLAGS8(0, tmpb, modrm{8});

NEG.OW   modrm 
            *16* tmph := modrm{16}
            *16* modrm := 0 - modrm{16}
            SUBFLAGS16(0, tmph, modrm);

NEG.OD   modrm 
            *32* tmp1 := modrm{32}
            *32* modrm := 0 - modrm{32}
            SUBFLAGS32(0, tmp1, modrm);

NOP    
            _ ;

NOT.B   modrm 
            *8* modrm := ~modrm{8};

NOT.OW   modrm 
            *16* modrm := ~modrm{16};

NOT.OD   modrm 
            *32* modrm := ~modrm{32};

POP.EVOW   modrm 
            *16* modrm := m[%esp]
            *32* %esp := %esp + 2;

POP.EVOD   modrm 
            *32* modrm := m[%esp]
            *32* %esp := %esp + 4;

POP.OW   reg16 
            *16* reg16 := m[%esp]{16}
            *32* %esp := %esp + 2;

POP.OD   reg32 
            *32* reg32 := m[%esp]{32}
            *32* %esp := %esp + 4;

PUSH.EVOW   modrm 
            *16* m[%esp - 2] := modrm{16}
            *32* %esp := %esp - 2;

PUSH.EVOD   modrm 
            *32* m[%esp - 4] := modrm{32}
            *32* %esp := %esp - 4;

PUSH.IXOB   i8 
            *32* m[%esp - 4] := sgnex(8, 32, i8)
            *32* %esp := %esp - 4;

# Note: 66 6A nn: 8 bit immediate operand (nn), but 16 bit push!
PUSH.IXOW   i8
            *16* m[%esp - 2] := sgnex(8, 16, i8)
            *16* %esp := %esp - 2;

PUSH.IVOW   i16 
            *16* m[%esp - 2] := i16
            *32* %esp := %esp - 2;

PUSH.IVOD   i32 
            *32* m[%esp - 4] := i32
            *32* %esp := %esp - 4;

PUSH.OW   reg16 
            *16* m[%esp - 2] := reg16
            *32* %esp := %esp - 2;

PUSH.OD   reg32 
            *32* m[%esp - 4] := reg32
            *32* %esp := %esp - 4;

# Just fix up the stack for selector pushes.
PUSH.CS
            *32* %esp := %esp - 4;
	    
PUSH.DS
            *32* %esp := %esp - 4;

PUSH.ES
            *32* %esp := %esp - 4;

OP4 := { "rlc", "rrc", "rl", "rr" };
ROT := { "RCL", "RCR", "ROL", "ROR" };

ROLS := { "RCL","ROL" };
RORS := { "RCR","ROR" };
ROT[IDX].B.EV.1 modrm 
            *8* tmpb1 := modrm{8}
            *8* tmpb2 := tmpb OP4[IDX] 1
            *8* modrm := tmpb2;
ROLS[IDX].B.EV.1 modrm   ROLFLAGS8(tmpb2, tmpb1, 1);
RORS[IDX].B.EV.1 modrm   RORFLAGS8(tmpb2, tmpb1, 1);

ROT[IDX].B.EV.1OW modrm 
            *16* tmph1 := modrm{16}
            *16* tmph2 := tmph1 OP4[IDX] 1
            *16* modrm := tmph2;
ROLS[IDX].B.EV.1OW modrm   ROLFLAGS16(tmph2, tmph1, 1);
RORS[IDX].B.EV.1OW modrm   RORFLAGS16(tmph2, tmph1, 1);

ROT[IDX].B.EV.1OD modrm 
            *32* tmp1 := modrm{32}
            *32* tmp2 := tmp1 OP4[IDX] 1
            *32* modrm := tmp2;
ROLS[IDX].B.EV.1OD modrm   ROLFLAGS32(tmp2, tmp1, 1);
RORS[IDX].B.EV.1OD modrm   RORFLAGS32(tmp2, tmp1, 1);

ROT[IDX].B.EV.CL modrm 
            *8* tmpb1 := modrm{8}
            *8* tmpb2 := tmpb1 OP4[IDX] %ecx
            *8* modrm := tmpb2;
ROLS[IDX].B.EV.CL   modrm  ROLFLAGS8(tmpb2, tmpb1, %ecx);
RORS[IDX].B.EV.CL   modrm  RORFLAGS8(tmpb2, tmpb1, %ecx);

ROT[IDX].B.EV.CLOW modrm 
            *16* tmph1 := modrm{16}
            *16* tmph2 := tmph1 OP4[IDX] %ecx
            *16* modrm := tmph2;
ROLS[IDX].B.EV.CLOW   modrm  ROLFLAGS16(tmph2, tmph1, %ecx);
RORS[IDX].B.EV.CLOW   modrm  RORFLAGS16(tmph2, tmph1, %ecx);

ROT[IDX].B.EV.CLOD modrm 
            *32* tmp1 := modrm{32}
            *32* tmp2 := tmp1 OP4[IDX] %ecx
            *32* modrm := tmp2;
ROLS[IDX].B.EV.CLOD   modrm  ROLFLAGS32(tmp2, tmp1, %ecx);
RORS[IDX].B.EV.CLOD   modrm  RORFLAGS32(tmp2, tmp1, %ecx);

ROT[IDX].B.EB.IB modrm, i8 
            *8* tmpb1 := modrm{8}
            *8* tmpb2 := tmpb1 OP4[IDX] i8
            *8* modrm := tmpb2;
ROLS[IDX].B.EB.IB   modrm, i8  ROLFLAGS8(tmpb2, tmpb1, i8);
RORS[IDX].B.EB.IB   modrm, i8  RORFLAGS8(tmpb2, tmpb1, i8);

ROT[IDX].B.EV.IBOW modrm, i8 
            *16* tmph1 := modrm{16}
            *16* tmph2 := tmph1 OP4[IDX] sgnex(8, 16, i8)
            *16* modrm := tmph2;
ROLS[IDX].B.EV.IBOW   modrm, i8  
            ROLFLAGS16(tmph2, tmph1, i8);
RORS[IDX].B.EV.IBOW   modrm, i8  
            RORFLAGS16(tmph2, tmph1, i8);

ROT[IDX].B.EV.IBOD modrm, i8 
            *32* tmp1 := modrm{8}
            *32* tmp2 := tmp1 OP4[IDX] i8
            *32* modrm := tmp2;
ROLS[IDX].B.EV.IBOD   modrm, i8  ROLFLAGS32(tmp2, tmp1, i8);
RORS[IDX].B.EV.IBOD   modrm, i8  RORFLAGS32(tmp2, tmp1, i8);

RET    
            *32* %pc := m[%esp]{32}
            *32* %esp := %esp + 4;

RET.IW   i16 
            *32* %pc := m[%esp]{32}
            *32* %esp := %esp + 4 + i16;

SAHF    
            *1* %NF := %ah@[7:7]
            *1* %ZF := %ah@[6:6]
            *1* %PF := %ah@[2:2]
            *1* %CF := %ah@[0:0];

SEG.CS      _;          # Sometimes used for extended NOP
SEG.DS      _;
SEG.ES      _;
SEG.SS      _;

SETB.B   modrm 
            *8* modrm := [%CF?1:0];

SETB.NB   modrm 
            *8* modrm := [~%CF?1:0];

SETB.BE   modrm 
            *8* modrm := [%CF | %ZF?1:0];

SETB.NBE   modrm 
            *8* modrm := [~%CF & ~%ZF?1:0];

SETB.L   modrm 
            *8* modrm := [%NF! = %OF?1:0];

SETB.NL   modrm 
            *8* modrm := [%NF = %OF?1:0];

SETB.O   modrm 
            *8* modrm := [%OF?1:0];

SETB.NO   modrm 
            *8* modrm := [~%OF?1:0];

SETB.P   modrm 
            *8* modrm := [%PF?1:0];

SETB.NP   modrm 
            *8* modrm := [~%PF = 0?1:0];

SETB.S   modrm 
            *8* modrm := [%NF?1:0];

SETB.NS   modrm 
            *8* modrm := [~%NF?1:0];

SETB.Z   modrm 
            *8*  modrm := [%ZF?1:0];

SETB.NZ   modrm 
            *8* modrm := [~%ZF?1:0];

SETB.LE   modrm 
            *8* modrm := [%ZF | (%NF ~= %OF) ?1:0];

SETB.NLE   modrm 
            *8* modrm := [~%ZF & (%NF = %OF) ?1:0];

OP5 := { "<<", ">>A", ">>" };
SHT := { "SHLSAL", "SAR", "SHR" };

SHT[IDX].B.EB.1 modrm 
            *8* tmpb := modrm{8}
            *8* modrm := modrm{8} OP5[IDX] 1;
SHLSAL.B.EB.1   modrm  SALFLAGS8(modrm{8}, tmpb, 1);
SAR.B.EB.1   modrm  SARFLAGS(modrm{8}, tmpb, 1);
SHR.B.EB.1   modrm  SHRFLAGS8(modrm{8}, tmpb, 1);

SHT[IDX].B.EV.1OW modrm 
            *16* tmph := modrm{16}
            *16* modrm := modrm{16} OP5[IDX] 1;
SHLSAL.B.EV.1OW   modrm  SALFLAGS16(modrm{16}, modrm{16}, 1);
SAR.B.EV.1OW   modrm  SARFLAGS(modrm{16}, tmph, 1);
SHR.B.EV.1OW   modrm  SHRFLAGS16(modrm{16}, tmph, 1);

SHT[IDX].B.EV.1OD modrm 
            *32* tmp1 := modrm{32}
            *32* modrm := modrm{32} OP5[IDX] 1;
SHLSAL.B.EV.1OD   modrm  SALFLAGS32(modrm, tmp1, 1);
SAR.B.EV.1OD   modrm  SARFLAGS(modrm, tmp1, 1);
SHR.B.EV.1OD   modrm  SHRFLAGS32(modrm, tmp1, 1);

SHT[IDX].B.EB.CL modrm 
            *8* tmpb := modrm{8}
            *8* modrm := modrm{8} OP5[IDX] %ecx;
SHLSAL.B.EB.CL   modrm  SALFLAGS8(modrm{8}, tmpb, %ecx);
SAR.B.EB.CL   modrm  SARFLAGS(modrm{8}, tmpb, %ecx);
SHR.B.EB.CL   modrm  SHRFLAGS8(modrm{8}, tmpb, %ecx);

SHT[IDX].B.EV.CLOW modrm 
            *16* tmph := modrm{16}
            *16* modrm := modrm{16} OP5[IDX] %ecx;
SHLSAL.B.EV.CLOW   modrm   SALFLAGS16(modrm{16}, tmph, %ecx);
SAR.B.EV.CLOW   modrm   SARFLAGS(modrm{16}, tmph, %ecx);
SHR.B.EV.CLOW   modrm   SHRFLAGS16(modrm{16}, tmph, %ecx);

SHT[IDX].B.EV.CLOD modrm 
            *32* tmp1 := modrm{32}
            *32* modrm := modrm{32} OP5[IDX] %ecx;
SHLSAL.B.EV.CLOD   modrm   SALFLAGS32(modrm, tmp1, %ecx);
SAR.B.EV.CLOD   modrm   SARFLAGS(modrm, tmp1, %ecx);
SHR.B.EV.CLOD   modrm   SHRFLAGS32(modrm, tmp1, %ecx);

SHT[IDX].B.EB.IB modrm, i8 
            *8* tmpb := modrm{8}
            *8* modrm := modrm{8} OP5[IDX] i8;
SHLSAL.B.EB.IB   modrm, i8   SALFLAGS8(modrm{8}, tmpb, i8);
SAR.B.EB.IB   modrm, i8   SARFLAGS(modrm{8}, tmpb, i8);
SHR.B.EB.IB   modrm, i8   SHRFLAGS8(modrm{8}, tmpb, i8);

SHT[IDX].B.EV.IBOW modrm, i8 
            *16* tmph := modrm{16}
            *16* modrm := modrm{16} OP5[IDX] i8;
SHLSAL.B.EV.IBOW   modrm, i8   SALFLAGS16(modrm{16}, tmph, i8);
SAR.B.EV.IBOW   modrm, i8   SARFLAGS(modrm{16}, tmph, i8);
SHR.B.EV.IBOW   modrm, i8   SHRFLAGS16(modrm{16}, tmph, i8);

SHT[IDX].B.EV.IBOD modrm, i8 
            *32* tmp1 := modrm{32}
            *32* modrm := modrm{32} OP5[IDX] i8;
SHLSAL.B.EV.IBOD   modrm, i8   SALFLAGS32(modrm, tmp1, i8);
SAR.B.EV.IBOD   modrm, i8   SARFLAGS(modrm, tmp1, i8);
SHR.B.EV.IBOD   modrm, i8   SHRFLAGS32(modrm, tmp1, i8);

OP6 := { "<<", ">>" };
SHTD := { "SHLD", "SHRD" };

SHTD[IDX].CLOW modrm, reg16 
            *32* tmp1 := [%cl > 31?%cl:31]
            *32* tmp2 := reg16 << 16
            *32* tmp3 := tmp2 + modrm{16}
            *32* tmp5 := tmp3 OP6[IDX] tmp1
            *16* modrm := tmp5;
SHLD.CLOW   modrm, reg16  SHLDFLAGS32(tmp5, tmp3, tmp1);
SHRD.CLOW   modrm, reg16  SHRDFLAGS32(tmp5, tmp3, tmp1);

SHTD[IDX].CLOD modrm, reg32 
            *32* tmp1 := [%cl > 31?%cl:31]
            *64* tmp2 := reg32 << 32
            *64* tmp3 := tmp2 + modrm
            *64* tmp5 := tmp3 OP6[IDX] tmp1
            *32* modrm := tmp5;
SHLD.CLOD   modrm, reg32  SHLDFLAGS64(tmp5, tmp3, tmp1);
SHRD.CLOD   modrm, reg32  SHRDFLAGS64(tmp5, tmp3, tmp1);

SHTD[IDX].IBOW modrm, reg16, cnt 
            *32* tmp1 := [cnt > 31?cnt:31]
            *32* tmp2 := reg16 << 16
            *32* tmp3 := tmp2 + modrm{16}
            *32* tmp5 := tmp3 OP6[IDX] tmp1
            *16* modrm := tmp5;
SHLD.IBOW   modrm, reg16, cnt   SHLDFLAGS32(tmp5, tmp3, tmp1);
SHRD.IBOW   modrm, reg16, cnt   SHRDFLAGS32(tmp5, tmp3, tmp1);

SHTD[IDX].IBOD modrm, reg32, cnt 
            *32* tmp1 := [cnt > 31?cnt:31]
            *64* tmp2 := reg32 << 32
            *64* tmp3 := tmp2 + modrm{32}
            *64* tmp5 := tmp3 OP6[IDX] tmp1
            *32* modrm := tmp5;
SHLD.IBOD   modrm, reg32, cnt  SHLDFLAGS64(tmp5, tmp3, tmp1);
SHRD.IBOD   modrm, reg32, cnt  SHRDFLAGS64(tmp5, tmp3, tmp1);

STC    *1* %CF := 1;

STD    *1* %DF := 1;

STI    *1* %IF := 1;

# The string instructions
REPS := {"REP", "REPNE"};                   # Repeat prefixes
OREPS := { REPS, ""};                       # Optional repeat prefixes
ALLSZ := {"B", "VOW", "VOD"};               # All size suffixes

# String instructions, not repeated
STRS := { "CMPS", "LODS", "MOVS", "SCAS", "STOS" };

# String instructions, repeated
STRS_R := REPS STRS;

# String instructions, optionally repeated
STRS_OR := OREPS STRS;

STRFL :=       { "CMPS", "SCAS"};                   # Update flags
STRNF :=       { "LODS", "MOVS", "STOS"};           # No update flags
STRSI := OREPS { "CMPS", "LODS", "MOVS" };          # Update esi
STRDI := OREPS { "CMPS", "MOVS", "SCAS", "STOS" };  # Update edi
STRFL_OR := OREPS STRFL;                            # Optionally repeated; flags

CMPS_OR := OREPS CMPS;      # Compare with optional repeat
LODS_OR := OREPS LODS;      # Load with optional repeat
MOVS_OR := OREPS MOVS;      # Move with optional repeat
SCAS_OR := OREPS SCAS;      # Scan with optional repeat
STOS_OR := OREPS STOS;      # Store with optional repeat

# All repeated string instructions
STRS_R[X]ALLSZ[Y]
            *1* %SKIP := (%ecx = 0);

CMPS_OR[X].B
            *8* tmpb := m[%esi]{8} - m[%edi]{8};
LODS_OR[X].B   
            *8* %al := m[%esi]{8};
MOVS_OR[X].B   
            *8* m[%edi] := m[%esi]{8};
SCAS_OR[X].B   
            *8* tmpb := %al - m[%edi]{8};
STOS_OR[X].B   
            *8* m[%edi] := %al;
STRFL_OR[X].B   
            SUBFLAGS8(m[%esi]{8}, m[%edi]{8}, tmpb);
STRSI[IDX].B   
            *32* %esi := %esi + [%DF = 0?1:-1];
STRDI[IDX].B   
            *32* %edi := %edi + [%DF = 0?1:-1];

CMPS_OR[X].VOW   
            *16* tmph := m[%esi]{16} - m[%edi]{16};
LODS_OR[X].VOW   
            *16* %eax := m[%esi]{16};
MOVS_OR[X].VOW   
            *16* m[%edi] := m[%esi]{16};
SCAS_OR[X].VOW   
            *16* tmph := %eax - m[%edi];
STOS_OR[X].VOW   
            *16* m[%edi] := %eax;
STRFL_OR[X].VOW   
            SUBFLAGS16(m[%esi]{16}, m[%edi]{16}, tmph);
STRSI[IDX].VOW   
            *16* %esi := %esi + [%DF = 0?2:-2];
STRDI[IDX].VOW   
            *16* %edi := %edi + [%DF = 0?2:-2];

CMPS_OR[X].VOD   
            *32* tmp1 := m[%esi]{32} - m[%edi]{32};
LODS_OR[X].VOD   
            *32* %eax := m[%esi]{32};
MOVS_OR[X].VOD   
            *32* m[%edi] := m[%esi]{32};
SCAS_OR[X].VOD   
            *32* tmp1 := %eax - m[%edi];
STOS_OR[X].VOD   
            *32* m[%edi] := %eax;
STRFL_OR[X].VOD   
            SUBFLAGS32(m[%esi]{32}, m[%edi]{32}, tmp1);
STRSI[IDX].VOD   
            *32* %esi := %esi + [%DF = 0?4:-4];
STRDI[IDX].VOD   
            *32* %edi := %edi + [%DF = 0?4:-4];

# All repeated instructions decrement %ecx
STRS_R[X]ALLSZ[Y]
            *32* %ecx := %ecx - 1;

# Do the repeat logic
REPIFZ := REP STRFL;
REPIFZ[X]ALLSZ[Y]
            *1* %RPT := %ZF;

REPIFNZ := REPNE STRFL;
REPIFNZ[X]ALLSZ[Y]
            *1* %RPT := ~%ZF;

REPALL := REPS STRNF;
REPALL[X]ALLSZ[Y]
            *1* %RPT := 1;

# End string instructions


TEST.AL.IB   i8 
            *8* tmpb := %al & i8
            LOGICALFLAGS8(tmpb);

TEST.EAX.IVOW   i16 
            *16* tmph := %eax & i16
            LOGICALFLAGS16(tmph);

TEST.EAX.IVOD   i32 
            *32* tmp1 := %eax & i32
            LOGICALFLAGS32(tmp1);

TEST.EB.IB   modrm, i8 
            *8* tmpb := modrm{8} & i8
            LOGICALFLAGS8(tmpb);

TEST.EW.IW   modrm, i16 
            *16* tmph := modrm{16} & i16
            LOGICALFLAGS16(tmph);

TEST.ED.ID   modrm, i32 
            *32* tmp1 := modrm{32} & i32
            LOGICALFLAGS32(tmp1);

TEST.EV.GB   modrm, reg8 
            *8* tmpb := modrm{8} & reg8
            LOGICALFLAGS8(tmpb);

TEST.EB.GB   modrm, reg8 
            *8* tmpb := modrm{8} & reg8
            LOGICALFLAGS8(tmpb);

TEST.EV.GVOW   modrm, reg16 
            *16* tmph := modrm{16} & reg16
            LOGICALFLAGS16(tmph);

TEST.EV.GVOD   modrm, reg32 
            *32* tmp1 := modrm{32} & reg32
            LOGICALFLAGS32(tmp1);

WAIT    _ ;

XADD.EV.GB   modrm, reg8 
            *8* tmp1 := modrm{8}
            *8* tmp2 := reg8
            *8* modrm := tmp1 + reg8
            *8* reg8 := tmp1
            ADDFLAGS8(tmp1, tmp2, modrm);

XADD.EV.GVOW   modrm, reg16 
            *16* tmp1 := modrm{16}
            *16* tmp2 := reg16
            *16* modrm := tmp1 + reg16
            *16* reg16 := tmp1
            ADDFLAGS16(tmp1, tmp2, modrm);

XADD.EV.GVOD   modrm, reg32 
            *32* tmp1 := modrm{32}
            *32* tmp2 := reg32
            *32* modrm := tmp1 + reg32
            *32* reg32 := tmp1
            ADDFLAGS32(tmp1, tmp2, modrm);

XCHG.EAXOD   reg32 
            *32* tmp1 := reg32
            *32* reg32 := %eax
            *32* %eax := tmp1;

XCHG.EAXOW   reg16 
            *16* tmph := reg16
            *16* reg16 := %eax
            *16* %eax := tmph;

XCHG.EB.GB   modrm, reg8 
            *8* tmpb := modrm{8}
            *8* modrm := reg8
            *8* reg8 := tmpb;

XCHG.EV.GVOD   modrm, reg32 
            *32* tmp1 := modrm{16}
            *32* modrm := reg32
            *32* reg32 := tmp1;

XCHG.EV.GVOW   modrm, reg16 
            *16* tmph := modrm{32}
            *16* modrm := reg16
            *16* reg16 := tmph;

# Start of Floating point operators

F2XM1
            # Compute (2^x)-1
            # Note: pwr is the binary "raise to power of" operator
            *f80* %st := (2.0 pow %st) -f 1.0;

FABS    
            *f80* %st := fabs(%st);

OP3 := { "+f", "-f" };
FARIT := { "FADD", "FSUB" };

FARIT[IDX].r32 modrm 
            *f80* %st := %st OP3[IDX] fsize(32,80,modrm);

FARIT[IDX].r64 modrm 
            *f80* %st := %st OP3[IDX] fsize(64,80,modrm);

FARIT[IDX].ST.STi i
            *f80* %st := %st OP3[IDX] i;

FARIT[IDX].STi.ST i 
            *f80* i := i OP3[IDX] %st;

FARITP := { "FADDP", "FSUBP" };

FARITP[IDX].r32 modrm 
            *f80* %st := %st OP3[IDX] fsize(32,80,modrm)
            FPOP;

FARITP[IDX].r64 modrm 
            *f80* %st := %st OP3[IDX] fsize(64,80,modrm)
            FPOP;

FARITP[IDX].ST.STi i 
            *f80* %st := %st OP3[IDX] i
            FPOP;

FARITP[IDX].STi.ST i 
            *f80* i := i OP3[IDX] %st
            FPOP;

FIADD.i16   modrm 
            *f80* %st := %st +f itof(16,80,modrm);

FIADD.i32   modrm 
            *f80* %st := %st +f itof(32,80,modrm);

FCHS    
            *f80* %st := ~f %st;

FCLEX    
            *8* %fsw@[0:7] := 0
            *1* %fsw@[15:15] := 0;

FNCLEX    
            *8* %fsw@[0:7] := 0
            *1* %fsw@[15:15] := 0;

FCOM.r32    modrm 
            *f80* tmpD := %st -f fsize(32,80,modrm)
            SETFFLAGS(%st, fsize(32,80,modrm));

FCOM.r64    modrm 
            *f80* tmpD := %st -f fsize(64,80,modrm)
            SETFFLAGS(%st, fsize(64,80,modrm));

FCOM.ST.STi i 
            *f80* tmpD := %st -f i
            SETFFLAGS(%st, i);

FCOMP.r32   modrm 
            # Note that the FPOP will actually change the register numbers!
            *f80* tmpD1 := %st
            *f80* tmpD2 := fsize(32, 80, modrm)
            *f80* tmpD := %st -f fsize(32,80,modrm)
            FPOP
            SETFFLAGS(tmpD1, tmpD2);

FCOMP.r64   modrm 
            *f80* tmpD1 := %st
            *f80* tmpD2 := fsize(64, 80, modrm)
            *f80* tmpD := %st -f fsize(64,80,modrm)
            FPOP
            SETFFLAGS(tmpD1, tmpD2);

FCOMP.ST.STi   i 
            *f80* tmpD1 := %st
            *f80* tmpD2 := i
            *f80* tmpD := %st -f i
            FPOP
            SETFFLAGS(tmpD1, tmpD2);
FCOMPP    
            *f80* tmpD1 := %st
            *f80* tmpD2 := %st1
            *f80* tmpD := %st -f %st1
            FPOP
            FPOP
            SETFFLAGS(tmpD1, tmpD2);

FCOS    
            *f80* %st := cos(%st);

FPUSH_
            FPUSH;

FDIV.r32   modrm 
            *f80* %st := %st /f fsize(32,80,modrm);

FDIV.r64   modrm 
            *f80* %st := %st /f fsize(64,80,modrm);

FDIV.ST.STi   i 
            *f80* %st := %st /f i;

# At this point, it should be noted that Intel have an unusual way of
# defining what is and isn't an "R" (reverse operands) instruction.
# Beware! Many disassemblers and assemblers get it wrong.
# Of course, gcc uses "AT&T" syntax, so that makes it more confusing again.
# Note that the decoder now gets the names right, as per the Intel manual.
# Note: some older Intel manuals have errors in the FSUB and FSUBR
# instructions.

FDIV.STi.ST   i 
            *f80* i := i /f %st;

FDIVP.STi.ST   i 
            *f80* i := i /f %st
            FPOP;

FIDIV.i32   modrm 
            *f80* %st := %st /f itof(32,80,modrm);

FIDIV.i16   modrm 
            *f80* %st := %st /f itof(16,80,modrm);

FDIVR.r32   modrm 
            *f80* %st := fsize(32,80,modrm) /f %st;

FDIVR.r64   modrm 
            *f80* %st := fsize(64,80,modrm) /f %st;

FDIVR.ST.STi   i 
            *f80* %st := i /f %st;

FDIVR.STi.ST   i 
            *f80* i := %st /f i;

FDIVRP.STi.ST   i 
            *f80* i := %st /f i
            FPOP;

FIDIVR.i32   modrm 
            *f80* %st := itof(32,80,modrm) /f %st;

FIDIVR.i16   modrm 
            *f80* %st := itof(16,80,modrm) /f %st;

FICOM.i16   modrm 
            *f80* tmpD := %st -f itof(16,80,modrm)
            SETFFLAGS(%st, itof(16,80,modrm));

FICOM.i32   modrm 
            *f80* tmpD := %st -f itof(32,80,modrm)
            SETFFLAGS(%st, itof(32,80,modrm));

FICOMP.i16   modrm 
            *f80* tmpD := %st -f itof(16,80,modrm)
            FPOP
            SETFFLAGS(%st, itof(16,80,modrm));

FICOMP.i32   modrm 
            *f80* tmpD := %st -f itof(32,80,modrm)
            FPOP
            SETFFLAGS(%st, itof(32,80,modrm));

FILD.lsI16   modrm 
            FPUSH
            *f80* %st := itof(16,80,modrm);

FILD.lsI32   modrm 
            FPUSH
            *f80* %st := itof(32,80,modrm);

FILD.lsI64   modrm 
            FPUSH
            *f80* %st := itof(64,80,modrm);

FINCSTP    
            FPUSH;

FINIT
            _ ;               # No operation; may find in startup code

FIST.lsI16   modrm 
            *16* modrm := ftoi(80,16,%st);

FIST.lsI32   modrm 
            *32* modrm := ftoi(80,32,%st);

FISTP.lsI16   modrm 
            *16* modrm := ftoi(80,16,%st)
            FPOP;

FISTP.lsI32   modrm 
            *32* modrm := ftoi(80,32,%st)
            FPOP;

FISTP64     modrm 
            *64* modrm := ftoi(80,64,%st)
            FPOP;

FLD.lsR32   modrm 
            FPUSH
            *f80* %st := fsize(32,80,modrm);

FLD.lsR64   modrm 
            FPUSH
            *f80* %st := fsize(64,80,modrm);

FLD80       modrm 
            FPUSH
            *f80* %st := modrm;

# This is a bit tricky. The FPUSH logically comes between the read of STi and
# the write to ST0. In particular, FLD ST0 is supposed to duplicate the TOS.
# This problem only happens with this load instruction, so there is a work
# around in the decoder that gives us a value of i that is one more than in
# the instruction

FLD.STi     i 
            FPUSH
            *f80* %st := i;

FLD1    
            FPUSH
            *f80* %st := 1.0;

FLDL2T    
            FPUSH
            *f80* %st := log2(10.0);

FLDL2E    
            FPUSH
            *f80* %st := log2(2.7182818);

FLDPI    
            FPUSH
            *f80* %st := 3.1415926;

FLDLG2    
            FPUSH
            *f80* %st := log10(2.0);

FLDLN2    
            FPUSH
            *f80* %st := loge(2.0);

FLDZ    
            FPUSH
            *f80* %st := 0.0;

FLDCW   modrm 
            *16* %fcw := modrm;

FMUL.r32   modrm 
            *f80* %st := %st *f fsize(32,80,modrm);

FMUL.r64   modrm 
            *f80* %st := %st *f fsize(64,80,modrm);

FMUL.ST.STi   i 
            *f80* %st := %st *f i;

FMUL.STi.ST   i 
            *f80* i := %st *f i;

FMULP.STi.ST   i 
            *f80* i := %st *f i
            FPOP;

FIMUL.i16   modrm 
            *f80* %st := %st *f itof(16,80,modrm);

FIMUL.i32   modrm 
            *f80* %st := %st *f itof(32,80,modrm);

FNOP    _ ;

FPATAN    
            *f80* %st1 := arctan(%st1 /f %st)
            FPOP;

# FPREM is for backwards compatibility with 80{2}87 FPUs
FPREM
            *f80* tmpD := ftrunc(%st /f %st1)   # Should chop towards 0
            *f80* %st := %st -f (%st1 *f tmpD)
# If st1 was/is negative, we need to change the sign of st?
            *f80* %st := [%st1 < 0 ? ~f %st : %st];
            #*1* %C2 := 0
            #*1* %FZF := bit 2 of tmpD as integer  # %C0 is %FZF
            #*1* %FLF := bit 1 of tmpD as integer  # %C3 is %FLF
            #*1* %C1  := bit 0 of tmpD as integer

# Floating point remainder.
FPREM1
            *f80* tmpD := ftrunc(%st /f %st1)   # Should round to nearest
            *f80* %st := %st -f (%st1 *f tmpD);
            #*1* %C2 := 0
            #*1* %FZF := bit 2 of tmpD as integer  # %C0 is %FZF
            #*1* %FLF := bit 1 of tmpD as integer  # %C3 is %FLF
            #*1* %C1  := bit 0 of tmpD as integer

FPTAN    
            *f80* %st := tan(%st)
            FPUSH
            *f80* %st := 1.0;

FRNDINT    
            *f80* %st := fround(80,80,%st);

FSCALE      # Raise 2 to an integer power and multiply
            # Note that st1 is "chopped" before use
            *f80* %st := %st * (2.0 pow ftrunc(%st1));

FSIN    
            *f80* %st := sin(%st);

FSINCOS    
            *f80* tmp := %st
            *f80* %st := sin(tmp)
            FPUSH
            *f80* %st := cos(tmp);

FSQRT    
            *f80* %st := sqrt(%st);

FST.lsR32   modrm 
            *32* modrm := fsize(80,32,%st);

FST.lsR64   modrm 
            *64* modrm := fsize(80,64,%st);

FST.ST.STi   i 
            *f80* i := %st;

FSTP.lsR32   modrm 
            *32* modrm := fsize(80,32,%st)
            FPOP;

FSTP.lsR64   modrm 
            *64* modrm := fsize(80,64,%st)
            FPOP;

FSTP80   modrm 
            *f80* modrm := %st
            FPOP;

FSTP.ST.STi   i 
            *f80* i := %st
            FPOP;

FSTCW   modrm 
            *16* modrm := %fcw;

FNSTCW   modrm 
            *16* modrm := %fcw;

FSTSW   modrm 
            *16* modrm := %fflags;

FSTSW.AX    
            # *16* %ax := %fflags;
            *8* %ah := %fflags
            *8* %al := 0;     # Just so we know it's changed  

FNSTSW   modrm 
            *16* modrm := %fflags;

FNSTSW.AX    
            # *16* %ax := %fflags;
            *8* %ah := %fflags
            *8* %al := 0;     # Just so we know it's changed  

FSUBR.r32   modrm 
            *f80* %st := fsize(32,80,modrm) -f %st;

FSUBR.r64   modrm 
            *f80* %st := fsize(64,80,modrm) -f %st;

FSUBR.ST.STi   i 
            *f80* %st := i -f %st;

# We used to think this one had to be swapped
FSUBR.STi.ST   i 
            *f80* i := %st -f i;

# We used to think this one had to be swapped
FSUBRP.STi.ST   i 
            *f80* i := %st -f i
            FPOP;

FISUB.i32   modrm 
            *f80* %st := %st -f itof(32,80,modrm);

FISUB.i16   modrm 
            *f80* %st := %st - itof(16,80,modrm);

FISUBR.i32   modrm 
            *f80* %st := itof(32,80,modrm) -f %st;

FISUBR.i16   modrm 
            *f80* %st := itof(16,80,modrm) -f %st;

FTST    
            SETFFLAGS(%st, 0.0);

FUCOM       i 
            *f80* tmpD := %st -f i
            SETFFLAGS(%st, i);

FUCOMI.ST.STi	i 
			*f80* tmpD := %st -f i
			SUBFLAGSFL(%st, i);

FUCOMP      i 
            *f80* tmpD1 := %st
            *f80* tmpD2 := i
            *f80* tmpD := %st -f i
            FPOP
            SETFFLAGS(tmpD1, tmpD2);

FUCOMIP.ST.STi	i 
            *f80* tmpD1 := %st
            *f80* tmpD2 := i
            *f80* tmpD := %st -f i
            FPOP
            SUBFLAGSFL(tmpD1, tmpD2);

FUCOMPP    
            *f80* tmpD1 := %st
            *f80* tmpD2 := %st1
            *f80* tmpD := %st -f %st1
            FPOP
            FPOP
            SETFFLAGS(tmpD1, tmpD2);

FWAIT    _ ;

FXCH        i 
            *f80* tmpD := %st
            *f80* %st := i
            *f80* i := tmpD;

FYL2X    
            *f80* %st1 := %st1 *f log2(%st)
            FPOP;

FYL2XP1    
            *f80* %st1 := %st1 *f log2(%st +f 1.0)
            FPOP;

#####################################################################
# These are the semantics for certain prologues and epilogues that we
# need to see for CSR analysis. We need the semantics for a logue to
# be specified when it uses and/or defines locations that relevant for
# CSR analysis involving the logue. For example, the caller prologue
# "clear_stack" on x86 directly manipulates the stack pointer which is
# something the abstract frame pointer needs to see.
#####################################################################
CLEAR_STACK   n 
            *32* %esp := %esp + n;
