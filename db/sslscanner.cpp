/*
 * 20 Mar 11 - Mike: YY_FATAL_ERROR has (char*) cast inserted (should auto-generate)
 */
#define YY_CHAR char
//#line 1 "//usr/local/lib/flexskel.cc"
/* A lexical scanner generated by flex */
/* scanner skeleton version:
 * $Header$
 */
/* MODIFIED FOR C++ CLASS BY Alain Coetmeur: coetmeur(at)icdc.fr */
/* Note that (at) mean the 'at' symbol that I cannot write */
/* because it is expanded to the class name */
/* made at Informatique-CDC, Research&development department */
/* company from the Caisse Des Depots et Consignations */
/* institutional financial group  */

/* theses symbols are added before this file */
/* #define YY_CHAR 'unsigned char' if 8bit or 'char' if 7bit */
/* #define FLEX_DEBUG if debug mode */
#define FLEX_SCANNER
/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
#ifdef c_plusplus
#ifndef __cplusplus
#define __cplusplus
#endif
#endif
/* Old MSC, before c7 */
#ifdef MSDOS
#ifndef _MSDOS
#define _MSDOS
#endif
#endif
/* turboc */
#ifdef __MSDOS__
#ifndef _MSDOS
#define _MSDOS
#endif
#endif

#ifdef __cplusplus
#include <cstdlib>
#define YY_USE_CONST
#define YY_USE_PROTOS
#ifndef YY_USE_CLASS
#define YY_USE_CLASS
#endif
#ifndef _MSDOS
#include <osfcn.h>
#endif
#else /* ! __cplusplus */
#ifdef __STDC__
#ifdef __GNUC__
#include <stddef.h>
void *malloc(size_t);
void free(void *);
int read();
#else
#include <cstdlib>
#endif /* __GNUC__ */
#define YY_USE_PROTOS
#define YY_USE_CONST
#endif /* __STDC__ */
#endif /* ! __cplusplus */
#ifdef __TURBOC__
#define YY_USE_CONST
#endif
#include <cstdio>
#include "operator.h"
#include "boomerang.h"

/*********************************************/
/* COMPILER DEPENDENT   MACROS               */
/*********************************************/
/* use prototypes in function declarations */
/* the "const" storage-class-modifier is valid */
#ifndef YY_USE_CONST
#define const
#endif
/* use prototypes in function declarations */
#ifndef YY_PROTO
#ifdef YY_USE_PROTOS
#define YY_PROTO(proto) proto
#else
#define YY_PROTO(proto) ()
#endif
#endif

/*********************/
/* parameters        */

/* amount of stuff to slurp up with each read */
#ifndef YY_READ_BUF_SIZE
#define YY_READ_BUF_SIZE 8192
#endif
/* size of default input buffer */
#ifndef YY_BUF_SIZE
#define YY_BUF_SIZE (YY_READ_BUF_SIZE * 2)
#endif

/***********************************/
/* to be redefined for application */

/* returned upon end-of-file */
#define YY_END_TOK 0
/* no semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#define yyterminate() return (YY_NULL)

/* code executed at the end of each rule */
#define YY_BREAK break;

/* #define YY_USER_ACTION */
/* #define YY_USER_INIT */

#ifndef YY_USE_CLASS
/* copy whatever the last rule matched to the standard output */
/* cast to (char *) is because for 8-bit chars, yy___text is (unsigned char *) */
/* this used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite()
 */
#define ECHO (void) fwrite((char *)yy___text, yy___leng, 1, yy___out)

/* gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#ifdef _MSDOS
#define YY_INPUT(buf, result, max_size)                                                                                \
    if ((result = fread(buf, 1, max_size, yy___in)) < 0)                                                               \
        YY_FATAL_ERROR("fread() in flex scanner failed");
#else
#define YY_INPUT(buf, result, max_size)                                                                                \
    if ((result = read(fileno(yy___in), (char *)buf, max_size)) < 0)                                                   \
        YY_FATAL_ERROR("read() in flex scanner failed");

#endif
/* report a fatal error */

/* The funky do-while is used to turn this macro definition into
 * a single C statement (which needs a semi-colon terminator).
 * This avoids problems with code like:
 *
 *      if ( something_happens )
 *              YY_FATAL_ERROR( (char*)"oops, the something happened" );
 *      else
 *              everything_okay();
 *
 * Prior to using the do-while the compiler would get upset at the
 * "else" because it interpreted the "if" statement as being all
 * done when it reached the ';' after the YY_FATAL_ERROR() call.
 */

#define YY_FATAL_ERROR(msg)                                                                                            \
    do {                                                                                                               \
        (void) fputs((char *)msg, yy___stderr);                                                                        \
        (void) putc('\n', yy___stderr);                                                                                \
        exit(1);                                                                                                       \
    } while (0)

/* default yywrap function - always treat EOF as an EOF */
#define yywrap() 1

/* default declaration of generated scanner - a define so the user can
 * easily add parameters
 */
#define YY_DECL int yylex YY_PROTO((void))
#else
/* c++ */
#define ECHO yy___echo()
#define YY_INPUT(buf, result, max_size)                                                                                \
    if (yy___input((char *)buf, result, max_size) < 0)                                                                 \
        YY_FATAL_ERROR("YY_INPUT() in flex scanner failed");

#define YY_FATAL_ERROR(msg) yy___fatal_error((char *)msg)
#define yywrap() yy___wrap()

#endif
/***********************************/
/* not to be changed */
#define YY_NULL 0
#define YY_END_OF_BUFFER_CHAR 0
/* special action meaning "start processing a new file" */
#define YY_NEW_FILE yy___newfile
/* enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN
 */
#define BEGIN yy_start = 1 + 2 *

/* action number for EOF rule of a given start state */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)

/* % section 1 definitions go here */
//#line 1 "db/sslscanner.l"
#define INITIAL 0
/*
 * Copyright (C) 1997, Shane Sendall
 * Copyright (C) 1998-2001, The University of Queensland
 * Copyright (C) 2001, Sun Microsystems, Inc
 *
 * See the file "LICENSE.TERMS" for information on usage and
 * redistribution of this file, and for a DISCLAIMER OF ALL
 * WARRANTIES.
 *
 */
/***************************************************************************/ /**
  * \file          sslscanner.cpp
  * \brief      Defines a scanner to parse the tokens of a Semantic
  *                  Specification Language specification.
  ******************************************************************************/
/*
 * Shane Sendall (original C version) Dec 1997
 * Doug Simon (C++ version) Jan 1998
 * 29 Apr 02 - Mike: Mods for boomerang; removed &~, |~, and ^~ operators
 * 09 May 02 - Mike: ASSIGNSIZE is an num now
 * 05 May 04 - Mike: ASSIGNSIZE replaced by ASSIGNTYPE (text)
 */
#define YY_SSLScanner_FLEX_SCANNER
//#line 35 "db/sslscanner.l"
#include <cassert>
#include <cstring>

#include "sslscanner.h"
//#line 62 "db/sslscanner.l"
//#line 196 "//usr/local/lib/flexskel.cc"

#define yy___stderr YY_SSLScanner_ERRFILE
#define yy___text YY_SSLScanner_TEXT
#define yy___leng YY_SSLScanner_LENG
#define yy___in YY_SSLScanner_IN
#define yy___out YY_SSLScanner_OUT
#define yy___newfile                                                                                                   \
    do {                                                                                                               \
        YY_SSLScanner_INIT_BUFFER(YY_SSLScanner_CURRENT_BUFFER, yy___in);                                              \
        YY_SSLScanner_LOAD_BUFFER_STATE();                                                                             \
    } while (0)
#if YY_SSLScanner_DEBUG != 0
#define yy___flex_debug YY_SSLScanner_DEBUG_FLAG
#endif

#ifdef YY_USE_CLASS

#define yy___echo YY_SSLScanner_ECHO
#define yy___input YY_SSLScanner_INPUT
#define yy___fatal_error YY_SSLScanner_FATAL_ERROR
#define yy___wrap YY_SSLScanner_WRAP

#endif

/* done after the current pattern has been matched and before the
 * corresponding action - sets up yy___text
 */
#define YY_DO_BEFORE_ACTION                                                                                            \
    yy___text = yy_bp;                                                                                                 \
    /* % code to fiddle yy___text and yy___leng for yymore() goes here */                                              \
    yy___leng = yy_cp - yy_bp;                                                                                         \
    yy_hold_char = *yy_cp;                                                                                             \
    *yy_cp = '\0';                                                                                                     \
    yy_c_buf_p = yy_cp;

#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2

/* return all but the first 'n' matched characters back to the input stream */
#define yyless(n)                                                                                                      \
    do {                                                                                                               \
        /* undo effects of setting up yy___text */                                                                     \
        *yy_cp = yy_hold_char;                                                                                         \
        yy_c_buf_p = yy_cp = yy_bp + n;                                                                                \
        YY_DO_BEFORE_ACTION; /* set up yy___text again */                                                              \
    } while (0)

#define unput(c) yyunput(c, yy___text)

struct yy_buffer_state {
    YY_SSLScanner_IFILE *yy_input_file;

    YY_SSLScanner_CHAR *yy_ch_buf;  /* input buffer */
    YY_SSLScanner_CHAR *yy_buf_pos; /* current position in input buffer */

    /* size of input buffer in bytes, not including room for EOB characters */
    int yy_buf_size;

    /* number of characters read into yy_ch_buf, not including EOB characters */
    int yy_n_chars;

    int yy_eof_status; /* whether we've seen an EOF on this buffer */
#define EOF_NOT_SEEN 0
/* "pending" happens when the EOF has been seen but there's still
 * some text process
 */
#define EOF_PENDING 1
#define EOF_DONE 2
};

/* we provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state"
 */

#ifndef YY_USE_CLASS

#if YY_SSLScanner_DEBUG != 0
int YY_SSLScanner_DEBUG_FLAG = YY_SSLScanner_DEBUG_INIT;
#endif
#define YY_CURRENT_BUFFER YY_SSLScanner_CURRENT_BUFFER
static YY_BUFFER_STATE YY_SSLScanner_CURRENT_BUFFER;
/* yy_hold_char holds the character lost when yy___text is formed */
static YY_SSLScanner_CHAR yy_hold_char;

static int yy_n_chars; /* number of characters read into yy_ch_buf */

/* GLOBAL */
YY_SSLScanner_CHAR *yy___text;
int yy___leng;

YY_SSLScanner_IFILE *yy___in = (YY_SSLScanner_IFILE *)0;
YY_SSLScanner_OFILE *yy___out = (YY_SSLScanner_OFILE *)0;

#ifdef __cplusplus
static int yyinput YY_PROTO((void));
#else
static int input YY_PROTO((void));
#endif
/* these variables are all declared out here so that section 3 code can
 * manipulate them
 */
/* points to current character in buffer */
static YY_SSLScanner_CHAR *yy_c_buf_p = (YY_SSLScanner_CHAR *)0;
static int yy_init = 1;  /* whether we need to initialize */
static int yy_start = 0; /* start state number */

/* flag which is used to allow yywrap()'s to do buffer switches
 * instead of setting up a fresh yy___in.  A bit of a hack ...
 */
static int yy_did_buffer_switch_on_eof;

static int yy_get_next_buffer YY_PROTO((void));
static void yyunput YY_PROTO((YY_SSLScanner_CHAR c, YY_SSLScanner_CHAR * buf_ptr));

#else
/* c++ */
#ifndef YY_SSLScanner_ECHO_NOCODE
void YY_SSLScanner_CLASS::yy___echo() { YY_SSLScanner_ECHO_CODE }
#endif
#ifndef YY_SSLScanner_INPUT_NOCODE
int YY_SSLScanner_CLASS::yy___input(char *buffer, int &result, int max_size) { YY_SSLScanner_INPUT_CODE }
#endif
#ifndef YY_SSLScanner_FATAL_ERROR_NOCODE
void YY_SSLScanner_CLASS::yy___fatal_error(char *msg) { YY_SSLScanner_FATAL_ERROR_CODE }
#endif
#ifndef YY_SSLScanner_WRAP_NOCODE
int YY_SSLScanner_CLASS::yy___wrap() { YY_SSLScanner_WRAP_CODE }
#endif
void YY_SSLScanner_CLASS::yy_initialize() {
    yy___in = 0;
    yy___out = 0;
    yy_init = 1;
    yy_start = 0;
    yy___text = 0;
    yy___leng = 0;
    YY_SSLScanner_CURRENT_BUFFER = 0;
    yy_did_buffer_switch_on_eof = 0;
    yy_c_buf_p = 0;
    yy_hold_char = 0;
    yy_n_chars = 0;
#if YY_SSLScanner_DEBUG != 0
    YY_SSLScanner_DEBUG_FLAG = YY_SSLScanner_DEBUG_INIT;
#endif
}

YY_SSLScanner_CLASS::YY_SSLScanner_CLASS(YY_SSLScanner_CONSTRUCTOR_PARAM) YY_SSLScanner_CONSTRUCTOR_INIT {
    yy_initialize();
    YY_SSLScanner_CONSTRUCTOR_CODE;
}
YY_SSLScanner_CLASS::~YY_SSLScanner_CLASS() {
    YY_SSLScanner_DESTRUCTOR_CODE;
    if (YY_SSLScanner_CURRENT_BUFFER)
        YY_SSLScanner_DELETE_BUFFER(YY_SSLScanner_CURRENT_BUFFER);
}

#endif

#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif

#ifndef YY_USER_INIT
#define YY_USER_INIT
#endif

/* % data tables for the DFA go here */
#define YY_END_OF_BUFFER 123
typedef int yy_state_type;
static const short int yy_acclist[480] = {
    0,   123, 120, 122, 118, 120, 122, 121, 122, 71,  120,   122,  109, 120, 122, 120, 122, 16503, 113, 120, 122, 39,
    120, 122, 37,  120, 122, 40,  120, 122, 45,  120, 122,   46,   120, 122, 120, 122, 41,  120,   122, 115, 120, 122,
    115, 120, 122, 115, 120, 122, 70,  120, 122, 112, 120,   122,  21,  120, 122, 19,  120, 122,   22,  120, 122, 72,
    120, 122, 106, 120, 122, 106, 120, 122, 106, 120, 122,   106,  120, 122, 106, 120, 122, 106,   120, 122, 106, 120,
    122, 106, 120, 122, 106, 120, 122, 111, 120, 122, 110,   120,  122, 38,  120, 122, 102, 120,   122, 106, 120, 122,
    106, 120, 122, 106, 120, 122, 106, 120, 122, 106, 120,   122,  106, 120, 122, 106, 120, 122,   106, 120, 122, 106,
    120, 122, 106, 120, 122, 106, 120, 122, 100, 106, 120,   122,  106, 120, 122, 106, 120, 122,   106, 120, 122, 106,
    120, 122, 36,  120, 122, 62,  120, 122, 118, 121, 16503, 8311, 44,  103, 42,  16,  47,  55,    115, 115, 66,  58,
    69,  107, 43,  52,  67,  34,  23,  25,  65,  24,  33,    26,   104, 106, 105, 106, 106, 106,   106, 106, 106, 106,
    106, 106, 63,  106, 106, 106, 106, 106, 106, 106, 106,   106,  106, 106, 106, 106, 106, 106,   106, 106, 106, 106,
    106, 101, 105, 17,  106, 106, 100, 106, 99,  105, 31,    106,  32,  106, 106, 106, 106, 106,   106, 106, 106, 106,
    106, 20,  64,  103, 48,  49,  56,  57,  59,  60,  107,   53,   54,  114, 116, 68,  27,  28,    35,  8,   106, 106,
    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,   18,   106, 106, 9,   106, 106, 106,   106, 106, 106, 106,
    106, 106, 106, 106, 106, 106, 106, 106, 61,  106, 29,    106,  30,  106, 106, 106, 106, 106,   106, 98,  106, 106,
    106, 106, 51,  50,  117, 106, 106, 14,  106, 106, 106,   86,   106, 106, 106, 106, 106, 106,   108, 106, 106, 89,
    104, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,   106,  106, 106, 106, 106, 106, 88,    104, 106, 106, 90,
    104, 98,  106, 106, 106, 106, 106, 106, 106, 3,   106,   87,   106, 106, 106, 106, 106, 73,    104, 106, 106, 106,
    106, 83,  104, 4,   106, 106, 106, 76,  104, 106, 106,   75,   104, 106, 106, 92,  104, 93,    104, 106, 96,  104,
    97,  104, 106, 106, 106, 12,  106, 106, 106, 106, 10,    106,  106, 13,  106, 106, 106, 106,   106, 106, 74,  104,
    106, 106, 11,  106, 94,  104, 81,  104, 106, 106, 106,   80,   104, 106, 106, 1,   106, 5,     106, 91,  104, 106,
    106, 106, 77,  104, 82,  104, 2,   106, 79,  104, 78,    104,  106, 106, 106, 106, 106, 95,    104, 106, 106, 15,
    106, 106, 106, 106, 6,   106, 106, 7,   106, 106, 106,   106,  84,  104, 106, 106, 85,  104};

static const short int yy_accept[337] = {
    0,   1,   1,   1,   2,   4,   7,   9,   12,  15,  18,  21,  24,  27,  30,  33,  36,  38,  41,  44,  47,  50,  53,
    56,  59,  62,  65,  68,  71,  74,  77,  80,  83,  86,  89,  92,  95,  98,  101, 104, 107, 110, 113, 116, 119, 122,
    125, 128, 131, 134, 137, 140, 144, 147, 150, 153, 156, 159, 162, 163, 164, 165, 166, 167, 168, 169, 170, 170, 170,
    171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 180, 180, 180, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189,
    190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 203, 204, 205, 206, 207, 208, 209, 210, 211,
    212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 223, 225, 226, 228, 230, 232, 234, 235, 236, 237, 238, 239, 240,
    241, 242, 243, 244, 245, 246, 247, 248, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 257, 258, 259, 260, 261,
    263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 274, 275, 277, 278, 280, 281, 282, 283, 284, 285, 286,
    287, 288, 289, 290, 291, 292, 293, 294, 296, 298, 300, 301, 302, 303, 304, 305, 307, 308, 309, 310, 311, 312, 313,
    314, 315, 317, 318, 319, 321, 322, 323, 324, 325, 326, 327, 327, 328, 329, 331, 332, 333, 334, 335, 336, 337, 338,
    339, 340, 341, 342, 343, 344, 345, 346, 347, 349, 350, 351, 353, 355, 356, 357, 358, 359, 360, 361, 363, 365, 366,
    367, 368, 369, 371, 372, 373, 374, 375, 377, 379, 380, 381, 383, 384, 385, 387, 388, 389, 391, 393, 394, 396, 398,
    399, 400, 401, 403, 404, 405, 406, 408, 409, 411, 412, 413, 414, 415, 416, 418, 419, 420, 422, 424, 426, 427, 428,
    429, 431, 432, 433, 435, 437, 439, 440, 441, 442, 444, 446, 448, 450, 452, 453, 454, 455, 456, 457, 459, 460, 461,
    463, 464, 465, 466, 468, 469, 471, 472, 473, 474, 476, 477, 478, 480, 480};

static const YY_CHAR yy_ec[128] = {
    0,  1,  1,  1,  1,  1,  1,  1,  1,  2,  3,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
    1,  1,  1,  1,  1,  1,  2,  4,  5,  6,  7,  8,  9,  10, 11, 10, 12, 13, 10, 14, 15, 16, 17, 18, 19, 20,
    20, 20, 20, 20, 20, 20, 21, 22, 23, 24, 25, 10, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 36, 37, 36,
    38, 39, 40, 36, 41, 42, 43, 44, 45, 36, 46, 36, 36, 47, 1,  48, 49, 50, 1,  51, 52, 53, 54, 55, 56, 57,
    58, 59, 58, 58, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 58, 70, 71, 58, 72, 10, 73, 10, 74, 1};

static const YY_CHAR yy_meta[75] = {0,  1,  1,  2,  3,  4,  1,  1,  1,  1,  1,  5,  6,  1,  1,  7,  1,  8,  8,
                                    8,  8,  1,  1,  1,  1,  1,  1,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,
                                    9,  9,  9,  9,  9,  9,  9,  9,  9,  5,  1,  1,  5,  10, 10, 10, 10, 10, 10,
                                    10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 1,  1};

static const short int yy_base[348] = {
    0,   0,   0,   260, 993, 256, 0,   993, 993, 240, 993, 235, 993, 71,  182, 59,  220, 76,  77,  83,  92,  61,
    993, 82,  209, 62,  993, 70,  88,  82,  102, 97,  103, 107, 105, 109, 993, 993, 225, 0,   108, 114, 119, 122,
    125, 142, 136, 148, 111, 128, 152, 201, 167, 180, 154, 181, 993, 144, 223, 0,   214, 993, 993, 0,   993, 993,
    232, 245, 254, 92,  260, 269, 993, 106, 993, 0,   993, 125, 236, 273, 201, 164, 993, 993, 116, 993, 993, 115,
    153, 993, 993, 156, 993, 212, 195, 175, 265, 186, 259, 271, 283, 284, 993, 285, 286, 0,   236, 288, 298, 300,
    303, 309, 311, 312, 314, 318, 317, 325, 326, 327, 328, 332, 330, 335, 993, 337, 340, 383, 993, 344, 352, 357,
    360, 367, 370, 378, 395, 397, 398, 401, 993, 993, 0,   111, 993, 110, 993, 993, 993, 993, 0,   993, 993, 409,
    444, 417, 993, 993, 993, 993, 400, 407, 404, 410, 402, 454, 430, 444, 447, 445, 456, 457, 133, 458, 432, 469,
    435, 472, 473, 474, 476, 478, 479, 484, 488, 489, 495, 491, 496, 497, 536, 502, 503, 504, 511, 516, 528, 523,
    530, 545, 546, 548, 550, 993, 993, 492, 557, 558, 560, 567, 568, 562, 578, 569, 576, 573, 575, 993, 121, 570,
    577, 993, 571, 579, 588, 608, 616, 618, 620, 621, 623, 625, 626, 627, 629, 630, 631, 632, 993, 634, 636, 993,
    639, 641, 642, 645, 648, 653, 682, 649, 650, 688, 690, 693, 660, 993, 695, 697, 698, 699, 993, 700, 701, 703,
    993, 706, 707, 993, 709, 704, 993, 993, 711, 993, 993, 714, 716, 719, 721, 727, 723, 730, 725, 762, 732, 738,
    765, 767, 769, 771, 993, 773, 775, 776, 993, 993, 778, 779, 780, 993, 784, 786, 783, 785, 993, 787, 788, 789,
    993, 993, 790, 993, 993, 791, 797, 829, 802, 808, 993, 817, 837, 834, 839, 840, 841, 843, 845, 846, 848, 850,
    851, 993, 855, 856, 993, 993, 922, 932, 940, 948, 952, 958, 960, 963, 967, 969, 976, 982};

static const short int yy_def[348] = {
    0,   335, 1,   335, 335, 335, 336, 335, 335, 337, 335, 338, 335, 339, 335, 335, 340, 335, 335, 335, 335, 335,
    335, 335, 335, 335, 335, 341, 341, 341, 341, 341, 341, 341, 341, 341, 335, 335, 335, 342, 341, 341, 341, 341,
    341, 341, 341, 341, 341, 341, 341, 341, 341, 341, 341, 341, 335, 335, 335, 336, 337, 335, 335, 343, 335, 335,
    335, 335, 335, 335, 335, 335, 335, 335, 335, 344, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335,
    335, 335, 335, 341, 335, 341, 341, 341, 341, 341, 341, 341, 341, 341, 335, 341, 341, 345, 341, 341, 341, 341,
    341, 341, 341, 341, 341, 341, 341, 341, 341, 341, 341, 341, 341, 341, 335, 341, 341, 341, 335, 341, 341, 341,
    341, 341, 341, 341, 341, 341, 341, 341, 335, 335, 343, 335, 335, 335, 335, 335, 335, 335, 344, 335, 335, 335,
    335, 335, 335, 335, 335, 335, 341, 341, 341, 341, 341, 341, 341, 341, 341, 341, 341, 341, 346, 341, 341, 341,
    341, 341, 341, 341, 341, 341, 341, 341, 341, 341, 341, 341, 341, 341, 341, 341, 341, 341, 341, 341, 341, 341,
    341, 347, 341, 341, 341, 335, 335, 335, 341, 341, 341, 341, 341, 341, 341, 341, 341, 341, 341, 335, 346, 341,
    341, 335, 341, 341, 341, 341, 341, 341, 341, 341, 341, 341, 341, 341, 341, 341, 341, 341, 335, 341, 341, 335,
    347, 341, 341, 341, 341, 341, 341, 341, 341, 341, 341, 341, 341, 335, 341, 341, 341, 341, 335, 341, 341, 341,
    335, 341, 341, 335, 341, 341, 335, 335, 341, 335, 335, 341, 341, 341, 341, 341, 341, 341, 341, 341, 341, 341,
    341, 341, 341, 341, 335, 341, 341, 341, 335, 335, 341, 341, 341, 335, 341, 341, 341, 341, 335, 341, 341, 341,
    335, 335, 341, 335, 335, 341, 341, 341, 341, 341, 335, 341, 341, 341, 341, 341, 341, 341, 341, 341, 341, 341,
    341, 335, 341, 341, 335, 0,   335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335};

static const short int yy_nxt[1068] = {
    0,   4,   5,   6,   7,   8,   9,   10,  11,  12,  8,   8,   13,  14,  15,  16,  17,  18,  19,  20,  19,  21,  22,
    23,  24,  25,  26,  27,  28,  29,  27,  30,  31,  27,  27,  32,  27,  33,  27,  34,  27,  27,  35,  27,  27,  27,
    27,  36,  37,  38,  39,  40,  41,  42,  43,  44,  45,  27,  27,  46,  47,  48,  27,  49,  50,  27,  51,  52,  53,
    54,  27,  27,  55,  56,  57,  64,  70,  70,  71,  70,  76,  90,  81,  65,  72,  82,  87,  88,  66,  66,  66,  66,
    78,  90,  70,  70,  70,  70,  78,  90,  70,  70,  70,  70,  80,  83,  84,  78,  90,  70,  70,  70,  70,  90,  90,
    73,  90,  92,  90,  90,  90,  94,  90,  93,  96,  90,  217, 68,  97,  92,  90,  89,  77,  90,  98,  92,  90,  99,
    217, 90,  95,  100, 101, 104, 92,  103, 146, 90,  79,  92,  92,  85,  92,  90,  92,  92,  92,  147, 124, 90,  148,
    92,  107, 90,  204, 90,  92,  90,  140, 92,  108, 149, 92,  110, 109, 92,  203, 112, 90,  151, 159, 102, 111, 92,
    158, 157, 90,  113, 156, 92,  152, 90,  90,  115, 125, 92,  114, 90,  120, 92,  141, 92,  116, 92,  121, 162, 90,
    122, 117, 118, 119, 123, 90,  155, 92,  126, 138, 61,  127, 127, 127, 127, 92,  90,  131, 58,  132, 92,  92,  164,
    105, 135, 133, 92,  86,  74,  134, 139, 69,  62,  161, 136, 92,  61,  65,  160, 137, 90,  128, 66,  66,  66,  66,
    153, 153, 153, 153, 65,  58,  92,  335, 129, 66,  66,  66,  66,  65,  130, 335, 335, 90,  66,  66,  66,  66,  78,
    90,  70,  70,  70,  70,  80,  90,  92,  78,  335, 70,  70,  70,  70,  154, 154, 154, 154, 90,  90,  90,  90,  165,
    90,  154, 154, 154, 154, 154, 154, 92,  163, 143, 90,  166, 90,  92,  171, 90,  167, 170, 335, 92,  144, 90,  145,
    90,  90,  335, 90,  168, 169, 90,  90,  92,  92,  92,  92,  335, 92,  90,  90,  90,  90,  335, 90,  173, 90,  335,
    92,  90,  92,  90,  335, 92,  90,  174, 175, 335, 90,  92,  335, 92,  92,  176, 92,  335, 90,  92,  92,  179, 178,
    90,  180, 181, 90,  92,  92,  92,  92,  177, 92,  90,  92,  182, 90,  92,  335, 92,  184, 335, 92,  183, 90,  185,
    92,  190, 186, 90,  188, 187, 192, 189, 92,  127, 127, 127, 127, 92,  193, 90,  92,  90,  90,  191, 90,  90,  90,
    92,  90,  335, 92,  90,  194, 335, 90,  195, 197, 335, 92,  153, 153, 153, 153, 92,  209, 335, 196, 205, 205, 205,
    205, 206, 207, 198, 90,  92,  90,  92,  92,  90,  92,  92,  92,  335, 92,  201, 208, 92,  90,  90,  92,  90,  199,
    202, 154, 154, 154, 154, 90,  200, 90,  90,  90,  211, 154, 154, 154, 154, 154, 154, 92,  213, 92,  90,  210, 92,
    221, 90,  90,  212, 90,  214, 90,  90,  92,  92,  335, 92,  90,  335, 215, 216, 90,  90,  92,  90,  92,  92,  92,
    90,  90,  90,  205, 205, 205, 205, 90,  90,  90,  92,  335, 335, 92,  92,  92,  90,  92,  219, 92,  92,  238, 335,
    224, 226, 92,  222, 223, 90,  92,  92,  220, 92,  90,  335, 241, 92,  92,  92,  225, 231, 90,  229, 92,  92,  92,
    232, 227, 234, 235, 90,  90,  92,  90,  228, 90,  335, 92,  230, 233, 237, 335, 90,  90,  92,  90,  335, 90,  335,
    92,  240, 92,  90,  90,  90,  255, 90,  92,  90,  247, 90,  90,  90,  90,  90,  236, 92,  92,  335, 92,  239, 92,
    246, 90,  253, 248, 251, 244, 92,  92,  254, 92,  243, 92,  245, 249, 250, 252, 92,  92,  92,  92,  92,  260, 92,
    335, 92,  92,  92,  92,  92,  90,  256, 90,  258, 90,  264, 257, 90,  92,  90,  267, 90,  335, 90,  270, 271, 90,
    335, 273, 269, 274, 335, 335, 90,  335, 90,  90,  335, 92,  90,  259, 335, 90,  90,  90,  335, 92,  90,  92,  335,
    92,  92,  335, 92,  90,  92,  92,  92,  263, 92,  92,  92,  92,  262, 92,  266, 92,  261, 265, 92,  268, 92,  92,
    278, 279, 92,  90,  275, 92,  92,  92,  276, 90,  92,  90,  284, 272, 90,  277, 90,  92,  90,  90,  90,  90,  90,
    280, 290, 294, 335, 90,  90,  281, 90,  282, 295, 335, 335, 90,  335, 90,  335, 92,  299, 283, 90,  335, 90,  92,
    90,  92,  90,  335, 92,  90,  92,  90,  92,  92,  92,  92,  92,  304, 92,  92,  286, 92,  92,  289, 92,  285, 92,
    291, 287, 92,  292, 92,  293, 300, 92,  288, 92,  301, 92,  302, 92,  90,  92,  298, 90,  92,  90,  92,  90,  296,
    308, 297, 309, 92,  90,  90,  335, 311, 312, 90,  303, 335, 90,  90,  90,  90,  90,  90,  318, 90,  90,  335, 335,
    335, 335, 335, 90,  92,  335, 335, 92,  90,  92,  314, 92,  315, 92,  90,  92,  305, 92,  92,  307, 92,  92,  92,
    90,  306, 92,  92,  92,  92,  92,  92,  92,  92,  92,  320, 90,  310, 313, 317, 92,  90,  319, 316, 90,  92,  90,
    90,  90,  322, 90,  92,  90,  90,  321, 90,  335, 331, 90,  335, 92,  335, 90,  334, 335, 335, 335, 335, 335, 324,
    335, 323, 92,  335, 335, 325, 335, 92,  335, 335, 92,  335, 92,  92,  92,  335, 92,  335, 92,  92,  335, 92,  326,
    92,  92,  330, 335, 328, 92,  92,  335, 335, 335, 327, 332, 335, 335, 335, 329, 335, 335, 335, 335, 335, 335, 335,
    335, 335, 333, 59,  335, 59,  59,  59,  59,  59,  59,  59,  59,  60,  60,  60,  60,  60,  60,  60,  60,  60,  60,
    63,  335, 335, 335, 335, 335, 63,  63,  67,  335, 335, 67,  335, 67,  335, 67,  75,  335, 75,  75,  91,  335, 335,
    91,  91,  91,  106, 106, 142, 142, 142, 150, 150, 150, 150, 172, 172, 218, 335, 335, 335, 335, 218, 218, 242, 335,
    335, 242, 242, 242, 3,   335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335,
    335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335,
    335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335,
    335, 335, 335, 335, 335, 335, 335, 335, 335, 335};

static const short int yy_chk[1068] = {
    0,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
    1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
    1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
    1,   1,   1,   1,   1,   1,   13,  15,  15,  15,  15,  17,  27,  21,  13,  15,  21,  25,  25,  13,  13,  13,  13,
    18,  29,  18,  18,  18,  18,  19,  28,  19,  19,  19,  19,  20,  23,  23,  20,  31,  20,  20,  20,  20,  30,  32,
    15,  34,  27,  33,  40,  35,  29,  48,  28,  31,  41,  218, 13,  31,  29,  42,  25,  17,  43,  31,  28,  44,  31,
    172, 49,  30,  32,  33,  35,  31,  34,  69,  46,  18,  30,  32,  23,  34,  45,  33,  40,  35,  69,  48,  47,  73,
    41,  40,  50,  145, 54,  42,  91,  57,  43,  40,  73,  44,  41,  40,  49,  143, 43,  52,  77,  88,  33,  42,  46,
    87,  84,  95,  44,  81,  45,  77,  53,  55,  45,  49,  47,  44,  97,  46,  50,  57,  54,  45,  91,  46,  95,  94,
    47,  45,  45,  45,  47,  51,  80,  52,  50,  54,  60,  51,  51,  51,  51,  95,  93,  52,  58,  52,  53,  55,  97,
    38,  53,  52,  97,  24,  16,  52,  55,  14,  11,  94,  53,  94,  9,   66,  93,  53,  106, 51,  66,  66,  66,  66,
    78,  78,  78,  78,  67,  5,   93,  3,   51,  67,  67,  67,  67,  68,  51,  0,   0,   98,  68,  68,  68,  68,  70,
    96,  70,  70,  70,  70,  71,  99,  106, 71,  0,   71,  71,  71,  71,  79,  79,  79,  79,  100, 101, 103, 104, 98,
    107, 79,  79,  79,  79,  79,  79,  98,  96,  68,  108, 99,  109, 96,  104, 110, 99,  103, 0,   99,  68,  111, 68,
    112, 113, 0,   114, 100, 101, 116, 115, 100, 101, 103, 104, 0,   107, 117, 118, 119, 120, 0,   122, 107, 121, 0,
    108, 123, 109, 125, 0,   110, 126, 108, 109, 0,   129, 111, 0,   112, 113, 110, 114, 0,   130, 116, 115, 113, 112,
    131, 114, 115, 132, 117, 118, 119, 120, 111, 122, 133, 121, 116, 134, 123, 0,   125, 118, 0,   126, 117, 135, 119,
    129, 123, 119, 127, 121, 120, 129, 122, 130, 127, 127, 127, 127, 131, 130, 136, 132, 137, 138, 126, 160, 139, 164,
    133, 162, 0,   134, 161, 131, 0,   163, 132, 134, 0,   135, 153, 153, 153, 153, 127, 164, 0,   133, 155, 155, 155,
    155, 161, 162, 135, 166, 136, 174, 137, 138, 176, 160, 139, 164, 0,   162, 138, 163, 161, 167, 169, 163, 168, 136,
    139, 154, 154, 154, 154, 165, 137, 170, 171, 173, 166, 154, 154, 154, 154, 154, 154, 166, 168, 174, 175, 165, 176,
    177, 178, 179, 167, 180, 169, 181, 182, 167, 169, 0,   168, 183, 0,   170, 171, 184, 185, 165, 187, 170, 171, 173,
    186, 188, 189, 205, 205, 205, 205, 191, 192, 193, 175, 0,   0,   177, 178, 179, 194, 180, 173, 181, 182, 195, 0,
    180, 182, 183, 178, 179, 197, 184, 185, 175, 187, 196, 0,   198, 186, 188, 189, 181, 187, 190, 185, 191, 192, 193,
    188, 183, 190, 190, 199, 200, 194, 201, 184, 202, 0,   195, 186, 189, 194, 0,   206, 207, 197, 208, 0,   211, 0,
    196, 197, 198, 209, 210, 213, 219, 222, 190, 215, 207, 216, 214, 220, 212, 223, 190, 199, 200, 0,   201, 196, 202,
    206, 224, 215, 209, 213, 201, 206, 207, 216, 208, 200, 211, 202, 210, 212, 214, 209, 210, 213, 219, 222, 225, 215,
    0,   216, 214, 220, 212, 223, 226, 220, 227, 223, 228, 229, 222, 230, 224, 231, 232, 233, 0,   234, 235, 236, 237,
    0,   239, 234, 240, 0,   0,   242, 0,   243, 244, 0,   225, 245, 224, 0,   246, 249, 250, 0,   226, 247, 227, 0,
    228, 229, 0,   230, 254, 231, 232, 233, 228, 234, 235, 236, 237, 227, 239, 231, 240, 226, 230, 242, 233, 243, 244,
    246, 247, 245, 248, 243, 246, 249, 250, 244, 251, 247, 252, 254, 237, 253, 245, 256, 254, 257, 258, 259, 261, 262,
    248, 263, 269, 0,   265, 266, 251, 268, 252, 272, 0,   0,   275, 0,   276, 0,   248, 277, 253, 278, 0,   280, 251,
    282, 252, 279, 0,   253, 281, 256, 284, 257, 258, 259, 261, 262, 285, 263, 269, 257, 265, 266, 262, 268, 256, 272,
    265, 258, 275, 266, 276, 268, 279, 277, 259, 278, 280, 280, 281, 282, 283, 279, 276, 286, 281, 287, 284, 288, 275,
    289, 275, 291, 285, 292, 293, 0,   296, 297, 298, 283, 0,   302, 300, 303, 301, 305, 306, 307, 310, 313, 0,   0,
    0,   0,   0,   314, 283, 0,   0,   286, 316, 287, 300, 288, 301, 289, 317, 291, 286, 292, 293, 288, 296, 297, 298,
    319, 287, 302, 300, 303, 301, 305, 306, 307, 310, 313, 314, 315, 292, 298, 306, 314, 321, 313, 305, 320, 316, 322,
    323, 324, 316, 325, 317, 326, 327, 315, 328, 0,   329, 330, 0,   319, 0,   332, 333, 0,   0,   0,   0,   0,   319,
    0,   317, 315, 0,   0,   320, 0,   321, 0,   0,   320, 0,   322, 323, 324, 0,   325, 0,   326, 327, 0,   328, 322,
    329, 330, 328, 0,   324, 332, 333, 0,   0,   0,   323, 330, 0,   0,   0,   326, 0,   0,   0,   0,   0,   0,   0,
    0,   0,   332, 336, 0,   336, 336, 336, 336, 336, 336, 336, 336, 337, 337, 337, 337, 337, 337, 337, 337, 337, 337,
    338, 0,   0,   0,   0,   0,   338, 338, 339, 0,   0,   339, 0,   339, 0,   339, 340, 0,   340, 340, 341, 0,   0,
    341, 341, 341, 342, 342, 343, 343, 343, 344, 344, 344, 344, 345, 345, 346, 0,   0,   0,   0,   346, 346, 347, 0,
    0,   347, 347, 347, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335,
    335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335,
    335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335,
    335, 335, 335, 335, 335, 335, 335, 335, 335, 335};

static yy_state_type yy_last_accepting_state;
static YY_CHAR *yy_last_accepting_cpos;

#if YY_SSLScanner_DEBUG != 0
static const short int yy_rule_linenum[122] = {
    0,   64,  65,  66,  67,  68,  69,  70,  74,  75,  79,  80,  84,  85,  86,  87,  89,  94,  95,  99,  100,
    101, 102, 103, 104, 105, 106, 107, 108, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 127, 128, 129,
    130, 131, 132, 133, 134, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 156,
    159, 162, 165, 168, 171, 174, 178, 181, 184, 187, 190, 193, 194, 195, 196, 197, 198, 199, 200, 205, 210,
    215, 216, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 235, 239, 244, 245, 247, 248, 249, 253,
    258, 263, 267, 268, 272, 273, 274, 275, 276, 277, 281, 286, 291, 303, 304, 305, 306};

#endif
static yy_state_type yy_state_buf[YY_BUF_SIZE + 2], *yy_state_ptr;
static YY_CHAR *yy_full_match;
static int yy_lp;
static int yy_looking_for_trail_begin = 0;
static int yy_full_lp;
static int *yy_full_state;
#define YY_TRAILING_MASK 0x2000
#define YY_TRAILING_HEAD_MASK 0x4000
#define REJECT                                                                                                         \
    {                                                                                                                  \
        *yy_cp = yy_hold_char;            /* undo effects of setting up yytext */                                      \
        yy_cp = yy_full_match;            /* restore poss. backed-over text */                                         \
        yy_lp = yy_full_lp;               /* restore orig. accepting pos. */                                           \
        yy_state_ptr = yy_full_state;     /* restore orig. state */                                                    \
        yy_current_state = *yy_state_ptr; /* restore curr. state */                                                    \
        ++yy_lp;                                                                                                       \
        goto find_rule;                                                                                                \
    }
#define yymore() yymore_used_but_not_detected
#define YY_MORE_ADJ 0
//#line 376 "//usr/local/lib/flexskel.cc"
#ifndef YY_USE_CLASS
static yy_state_type yy_get_previous_state YY_PROTO((void));
static yy_state_type yy_try_NUL_trans YY_PROTO((yy_state_type current_state));
#else
#define yy_get_previous_state() ((yy_state_type)(yy_get_previous_state_()))
#define yy_try_NUL_trans(c) ((yy_state_type)(yy_try_NUL_trans_(c)))
#endif

#ifndef YY_USE_CLASS
#ifdef YY_SSLScanner_LEX_DEFINED
YY_SSLScanner_LEX_RETURN YY_SSLScanner_LEX(YY_SSLScanner_LEX_PARAM) YY_SSLScanner_LEX_PARAM_DEF
#else
YY_DECL
#endif
#else
YY_SSLScanner_LEX_RETURN YY_SSLScanner_CLASS::YY_SSLScanner_LEX(YY_SSLScanner_LEX_PARAM)

#endif
{
    yy_state_type yy_current_state;
    YY_SSLScanner_CHAR *yy_cp, *yy_bp;
    int yy_act;

    /* % user's declarations go here */

    /* % end of prolog */
    //#line 401 "//usr/local/lib/flexskel.cc"

    if (yy_init) {

        { YY_USER_INIT; }
        if (!yy_start)
            yy_start = 1; /* first start state */

        if (!yy___in)
            yy___in = YY_SSLScanner_IFILE_DEFAULT;

        if (!yy___out)
            yy___out = YY_SSLScanner_OFILE_DEFAULT;

        if (YY_SSLScanner_CURRENT_BUFFER)
            YY_SSLScanner_INIT_BUFFER(YY_SSLScanner_CURRENT_BUFFER, yy___in);
        else
            YY_SSLScanner_CURRENT_BUFFER = YY_SSLScanner_CREATE_BUFFER(yy___in, YY_BUF_SIZE);

        YY_SSLScanner_LOAD_BUFFER_STATE();
        yy_init = 0;
    }

    while (1) /* loops until end-of-file is reached */
    {
        /* % yymore()-related code goes here */
        //#line 429 "//usr/local/lib/flexskel.cc"
        yy_cp = yy_c_buf_p;

        /* support of yy___text */
        *yy_cp = yy_hold_char;

        /* yy_bp points to the position in yy_ch_buf of the start of the
         * current run.
         */
        yy_bp = yy_cp;

        /* % code to set up and find next match goes here */
        yy_current_state = yy_start;
        yy_state_ptr = yy_state_buf;
        *yy_state_ptr++ = yy_current_state;
    yy_match:
        do {
            YY_CHAR yy_c = yy_ec[(unsigned char)*yy_cp];
            while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state) {
                yy_current_state = yy_def[yy_current_state];
                if (yy_current_state >= 336)
                    yy_c = yy_meta[(unsigned char)yy_c];
            }
            yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
            *yy_state_ptr++ = yy_current_state;
            ++yy_cp;
        } while (yy_current_state != 335);
    //#line 440 "//usr/local/lib/flexskel.cc"

    yy_find_action:
        /* % code to find the action number goes here */
        yy_current_state = *--yy_state_ptr;
        yy_lp = yy_accept[yy_current_state];
    find_rule:   /* we branch to this label when backtracking */
        for (;;) /* until we find what rule we matched */
        {
            if (yy_lp && yy_lp < yy_accept[yy_current_state + 1]) {
                yy_act = yy_acclist[yy_lp];
                if (yy_act & YY_TRAILING_HEAD_MASK || yy_looking_for_trail_begin) {
                    if (yy_act == yy_looking_for_trail_begin) {
                        yy_looking_for_trail_begin = 0;
                        yy_act &= ~YY_TRAILING_HEAD_MASK;
                        break;
                    }
                } else if (yy_act & YY_TRAILING_MASK) {
                    yy_looking_for_trail_begin = yy_act & ~YY_TRAILING_MASK;
                    yy_looking_for_trail_begin |= YY_TRAILING_HEAD_MASK;
                } else {
                    yy_full_match = yy_cp;
                    yy_full_state = yy_state_ptr;
                    yy_full_lp = yy_lp;
                    break;
                }
                ++yy_lp;
                goto find_rule;
            }
            --yy_cp;
            yy_current_state = *--yy_state_ptr;
            yy_lp = yy_accept[yy_current_state];
        }
        //#line 443 "//usr/local/lib/flexskel.cc"

        YY_DO_BEFORE_ACTION;
        YY_USER_ACTION;

    do_action: /* this label is used only to access EOF actions */
#if YY_SSLScanner_DEBUG != 0
        if (yy___flex_debug) {
            if (yy_act == 0)
#ifndef YY_SSLScanner_IOSTREAM
                fprintf(yy___stderr, "--scanner backtracking\n");
#else
                yy___stderr << "--scanner backtracking" << endl;
#endif
            else if (yy_act < YY_END_OF_BUFFER - 1)
#ifndef YY_SSLScanner_IOSTREAM
                fprintf(yy___stderr, "--accepting rule at line %d (\"%s\")\n", yy_rule_linenum[yy_act], yy___text);
#else
                yy___stderr << "--accepting rule at line " << (int)yy_rule_linenum[yy_act] << " (\""
                            << (char *)yy___text << "\")" << endl;
#endif
            else if (yy_act == YY_END_OF_BUFFER - 1)
#ifndef YY_SSLScanner_IOSTREAM
                fprintf(yy___stderr, "--accepting default rule (\"%s\")\n", yy___text);
#else
                yy___stderr << "--accepting default rule"
                            << " (\"" << (char *)yy___text << "\")" << endl;
#endif
            else if (yy_act == YY_END_OF_BUFFER)
#ifndef YY_SSLScanner_IOSTREAM
                fprintf(yy___stderr, "--(end of buffer or a NUL)\n");
#else
                yy___stderr << "--(end of buffer or a NUL)" << endl;
#endif
            else
#ifndef YY_SSLScanner_IOSTREAM
                fprintf(yy___stderr, "--EOF\n");
#else
                yy___stderr << "--EOF" << endl;
#endif
        }
#endif
        switch (yy_act) {
        /* % actions go here */
        case 1:
        //#line 65 "db/sslscanner.l"
        case 2:
            //#line 65 "db/sslscanner.l"
            { return SSLParser::TOK_INTEGER; }
            YY_BREAK
        case 3:
#line 67 "db/sslscanner.l"
        case 4:
#line 67 "db/sslscanner.l"
        {
            return SSLParser::TOK_FLOAT;
        }
            YY_BREAK
        case 5:
#line 68 "db/sslscanner.l"
        {
            return SSLParser::OPERAND;
        }
            YY_BREAK
        case 6:
#line 70 "db/sslscanner.l"
        case 7:
#line 70 "db/sslscanner.l"
        {
            yylval.str = strdup(yytext);
            return SSLParser::ENDIANNESS;
        }
            YY_BREAK
        case 8:
#line 75 "db/sslscanner.l"
        case 9:
#line 75 "db/sslscanner.l"
        {
            yylval.str = strdup(yytext);
            return SSLParser::BIG;
        }
            YY_BREAK
        case 10:
#line 80 "db/sslscanner.l"
        case 11:
#line 80 "db/sslscanner.l"
        {
            yylval.str = strdup(yytext);
            return SSLParser::LITTLE;
        }
            YY_BREAK
        case 12:
#line 84 "db/sslscanner.l"
        {
            return SSLParser::COVERS;
        }
            YY_BREAK
        case 13:
#line 85 "db/sslscanner.l"
        {
            return SSLParser::SHARES;
        }
            YY_BREAK
        case 14:
#line 86 "db/sslscanner.l"
        {
            return SSLParser::FAST;
        }
            YY_BREAK
        case 15:
#line 87 "db/sslscanner.l"
        {
            return SSLParser::FETCHEXEC;
        }
            YY_BREAK
        case 16:
#line 89 "db/sslscanner.l"
        {
            yylval.str = strdup(yytext);
            return SSLParser::ASSIGNTYPE;
        }
            YY_BREAK
        case 17:
#line 95 "db/sslscanner.l"
        case 18:
#line 95 "db/sslscanner.l"
        {
            yylval.str = strdup(yytext);
            return SSLParser::LOG_OP;
        }
            YY_BREAK
        case 19:
#line 100 "db/sslscanner.l"
        case 20:
#line 101 "db/sslscanner.l"
        case 21:
#line 102 "db/sslscanner.l"
        case 22:
#line 103 "db/sslscanner.l"
        case 23:
#line 104 "db/sslscanner.l"
        case 24:
#line 105 "db/sslscanner.l"
        case 25:
#line 106 "db/sslscanner.l"
        case 26:
#line 107 "db/sslscanner.l"
        case 27:
#line 108 "db/sslscanner.l"
        case 28:
#line 108 "db/sslscanner.l"
        {
            yylval.str = strdup(yytext);
            return SSLParser::COND_OP;
        }
            YY_BREAK
        case 29:
#line 114 "db/sslscanner.l"
        case 30:
#line 115 "db/sslscanner.l"
        case 31:
#line 116 "db/sslscanner.l"
        case 32:
#line 117 "db/sslscanner.l"
        case 33:
#line 118 "db/sslscanner.l"
        case 34:
#line 119 "db/sslscanner.l"
        case 35:
#line 120 "db/sslscanner.l"
        case 36:
#line 121 "db/sslscanner.l"
        case 37:
#line 122 "db/sslscanner.l"
        case 38:
#line 122 "db/sslscanner.l"
        {
            yylval.str = strdup(yytext);
            return SSLParser::BIT_OP;
        }
            YY_BREAK
        case 39:
#line 128 "db/sslscanner.l"
        case 40:
#line 129 "db/sslscanner.l"
        case 41:
#line 130 "db/sslscanner.l"
        case 42:
#line 131 "db/sslscanner.l"
        case 43:
#line 132 "db/sslscanner.l"
        case 44:
#line 133 "db/sslscanner.l"
        case 45:
#line 134 "db/sslscanner.l"
        case 46:
#line 134 "db/sslscanner.l"
        {
            yylval.str = strdup(yytext);
            return SSLParser::ARITH_OP;
        }
            YY_BREAK
        case 47:
#line 139 "db/sslscanner.l"
        case 48:
#line 140 "db/sslscanner.l"
        case 49:
#line 141 "db/sslscanner.l"
        case 50:
#line 142 "db/sslscanner.l"
        case 51:
#line 143 "db/sslscanner.l"
        case 52:
#line 144 "db/sslscanner.l"
        case 53:
#line 145 "db/sslscanner.l"
        case 54:
#line 146 "db/sslscanner.l"
        case 55:
#line 147 "db/sslscanner.l"
        case 56:
#line 148 "db/sslscanner.l"
        case 57:
#line 149 "db/sslscanner.l"
        case 58:
#line 150 "db/sslscanner.l"
        case 59:
#line 151 "db/sslscanner.l"
        case 60:
#line 152 "db/sslscanner.l"
        case 61:
#line 152 "db/sslscanner.l"
        {
            yylval.str = strdup(yytext);
            return SSLParser::FARITH_OP;
        }
            YY_BREAK
        case 62:
#line 156 "db/sslscanner.l"
        {
            return SSLParser::NOT;
        }
            YY_BREAK
        case 63:
#line 159 "db/sslscanner.l"
        {
            return SSLParser::LNOT;
        }
            YY_BREAK
        case 64:
#line 162 "db/sslscanner.l"
        {
            return SSLParser::FNEG;
        }
            YY_BREAK
        case 65:
#line 165 "db/sslscanner.l"
        {
            return SSLParser::THEN;
        }
            YY_BREAK
        case 66:
#line 168 "db/sslscanner.l"
        {
            return SSLParser::INDEX;
        }
            YY_BREAK
        case 67:
#line 171 "db/sslscanner.l"
        {
            return SSLParser::EQUATE;
        }
            YY_BREAK
        case 68:
#line 174 "db/sslscanner.l"
        {
            yylval.str = strdup(yytext);
            return SSLParser::ASSIGN;
        }
            YY_BREAK
        case 69:
#line 178 "db/sslscanner.l"
        {
            return SSLParser::TO;
        }
            YY_BREAK
        case 70:
#line 181 "db/sslscanner.l"
        {
            return SSLParser::COLON;
        }
            YY_BREAK
        case 71:
#line 184 "db/sslscanner.l"
        {
            return SSLParser::S_E;
        }
            YY_BREAK
        case 72:
#line 187 "db/sslscanner.l"
        {
            return SSLParser::AT;
        }
            YY_BREAK
        case 73:
#line 190 "db/sslscanner.l"
        {
            return SSLParser::ADDR;
        }
            YY_BREAK
        case 74:
#line 194 "db/sslscanner.l"
        case 75:
#line 195 "db/sslscanner.l"
        case 76:
#line 196 "db/sslscanner.l"
        case 77:
#line 197 "db/sslscanner.l"
        case 78:
#line 198 "db/sslscanner.l"
        case 79:
#line 199 "db/sslscanner.l"
        case 80:
#line 200 "db/sslscanner.l"
        case 81:
#line 200 "db/sslscanner.l"
        {
            yylval.str = strdup(yytext);
            yylval.str[strlen(yylval.str) - 1] = '\0';
            return SSLParser::CONV_FUNC;
        }
            YY_BREAK
        case 82:
#line 205 "db/sslscanner.l"
        {
            yylval.str = strdup(yytext);
            yylval.str[strlen(yylval.str) - 1] = '\0';
            return SSLParser::TRUNC_FUNC;
        }
            YY_BREAK
        case 83:
#line 210 "db/sslscanner.l"
        {
            yylval.str = strdup(yytext);
            yylval.str[strlen(yylval.str) - 1] = '\0';
            return SSLParser::FABS_FUNC;
        }
            YY_BREAK
        case 84:
#line 216 "db/sslscanner.l"
        case 85:
#line 216 "db/sslscanner.l"
        {
            return SSLParser::FLAGMACRO;
        }
            YY_BREAK
        case 86:
#line 219 "db/sslscanner.l"
        {
            return SSLParser::FPOP;
        }
            YY_BREAK
        case 87:
#line 220 "db/sslscanner.l"
        {
            return SSLParser::FPUSH;
        }
            YY_BREAK
        case 88:
#line 222 "db/sslscanner.l"
        case 89:
#line 223 "db/sslscanner.l"
        case 90:
#line 224 "db/sslscanner.l"
        case 91:
#line 225 "db/sslscanner.l"
        case 92:
#line 226 "db/sslscanner.l"
        case 93:
#line 227 "db/sslscanner.l"
        case 94:
#line 228 "db/sslscanner.l"
        case 95:
#line 229 "db/sslscanner.l"
        case 96:
#line 229 "db/sslscanner.l"
        {
            yylval.str = strdup(yytext);
            yylval.str[strlen(yylval.str) - 1] = '\0';
            return SSLParser::TRANSCEND;
        }
            YY_BREAK
        case 97:
#line 235 "db/sslscanner.l"
        {
            return SSLParser::SUCCESSOR;
        }
            YY_BREAK
        case 98:
#line 239 "db/sslscanner.l"
        {
            yylval.str = strdup(yytext);
            return SSLParser::TEMP;
        }
            YY_BREAK
        case 99:
#line 244 "db/sslscanner.l"
        {
            return SSLParser::REG_IDX;
        }
            YY_BREAK
        case 100:
#line 245 "db/sslscanner.l"
        {
            yylval.str = strdup(yytext);
            return SSLParser::REG_NUM;
        }
            YY_BREAK
        case 101:
#line 247 "db/sslscanner.l"
        {
            return SSLParser::MEM_IDX;
        }
            YY_BREAK
        case 102:
#line 248 "db/sslscanner.l"
        {
            return yytext[0];
        }
            YY_BREAK
        case 103:
#line 249 "db/sslscanner.l"
        {
            yylval.str = strdup(yytext);
            return SSLParser::REG_ID;
        }
            YY_BREAK
        case 104:
#line 253 "db/sslscanner.l"
        {
            yylval.str = strdup(yytext);
            yylval.str[strlen(yylval.str) - 1] = '\0';
            return SSLParser::NAME_CALL;
        }
            YY_BREAK
        case 105:
#line 258 "db/sslscanner.l"
        {
            yylval.str = strdup(yytext);
            yylval.str[strlen(yylval.str) - 1] = '\0';
            return SSLParser::NAME_LOOKUP;
        }
            YY_BREAK
        case 106:
#line 263 "db/sslscanner.l"
        {
            yylval.str = strdup(yytext);
            return SSLParser::NAME;
        }
            YY_BREAK
        case 107:
#line 268 "db/sslscanner.l"
        case 108:
#line 268 "db/sslscanner.l"
        {
            yylval.str = strdup(yytext);
            return SSLParser::DECOR;
        }
            YY_BREAK
        case 109:
#line 272 "db/sslscanner.l"
        {
            return yytext[0];
        }
            YY_BREAK
        case 110:
#line 273 "db/sslscanner.l"
        {
            return yytext[0];
        }
            YY_BREAK
        case 111:
#line 274 "db/sslscanner.l"
        {
            return yytext[0];
        }
            YY_BREAK
        case 112:
#line 275 "db/sslscanner.l"
        {
            return yytext[0];
        }
            YY_BREAK
        case 113:
#line 276 "db/sslscanner.l"
        {
            return yytext[0];
        }
            YY_BREAK
        case 114:
#line 277 "db/sslscanner.l"
        {
            yylval.dbl = atof(yytext);
            return SSLParser::FLOATNUM;
        }
            YY_BREAK
        case 115:
#line 281 "db/sslscanner.l"
        {
            yylval.num = strtol(yytext, 0, 10);
            return SSLParser::NUM;
        }
            YY_BREAK
        case 116:
#line 286 "db/sslscanner.l"
        {
            yylval.num = strtol(yytext, 0, 16);
            return SSLParser::NUM;
        }
            YY_BREAK
        case 117:
#line 291 "db/sslscanner.l"
        {
            // a power of two
            int sign = (yytext[0] == '-' ? -1 : 1);
            char *start = yytext + (sign == -1 ? 4 : 3);

            // David - changed to << for more efficient and
            // not depend on the <cmath> anymore.
            yylval.num = sign * (1 << (strtol(start, 0, 10)));
            // yylval.num = (int)pow(2,strtol(start,0,10)) * sign;
            return SSLParser::NUM;
        }
            YY_BREAK
        case 118:
#line 303 "db/sslscanner.l"
            ;
            YY_BREAK
        case 119:
#line 304 "db/sslscanner.l"
            ; /* comment */
            YY_BREAK
        case 120:
#line 305 "db/sslscanner.l"
            ;
            YY_BREAK
        case 121:
#line 306 "db/sslscanner.l"
        { // funky print-next-line-for-debug token
            if (yyleng > MAX_LINE) {
                LOG_STREAM() << theLine + 1 << ": line too long.\n";
                exit(1);
            }
            // saves the next line
            strcpy(lineBuf, yytext + 1);
            theLine++;
            // reparse from char 1
            // give back all but the \n to rescan
            yyless(1);

            // echo the line if line tracing is turned on
            if (traceLines)
                LOG_STREAM() << lineBuf << '\n';

            // Quell a warning
            yy_last_accepting_state = 0;
            yy_last_accepting_cpos = 0;
        }
            YY_BREAK
        case 122:
#line 327 "db/sslscanner.l"
            ECHO;
            YY_BREAK
        case YY_STATE_EOF(INITIAL):
            yyterminate();
        //#line 493 "//usr/local/lib/flexskel.cc"

        case YY_END_OF_BUFFER: {
            /* amount of text matched not including the EOB char */
            int yy_amount_of_matched_text = yy_cp - yy___text - 1;

            /* undo the effects of YY_DO_BEFORE_ACTION */
            *yy_cp = yy_hold_char;

            /* note that here we test for yy_c_buf_p "<=" to the position
             * of the first EOB in the buffer, since yy_c_buf_p will
             * already have been incremented past the NUL character
             * (since all states make transitions on EOB to the end-
             * of-buffer state).  Contrast this with the test in yyinput().
             */
            if (yy_c_buf_p <= &YY_SSLScanner_CURRENT_BUFFER->yy_ch_buf[yy_n_chars])
            /* this was really a NUL */
            {
                yy_state_type yy_next_state;

                yy_c_buf_p = yy___text + yy_amount_of_matched_text;

                yy_current_state = yy_get_previous_state();

                /* okay, we're now positioned to make the
                 * NUL transition.  We couldn't have
                 * yy_get_previous_state() go ahead and do it
                 * for us because it doesn't know how to deal
                 * with the possibility of jamming (and we
                 * don't want to build jamming into it because
                 * then it will run more slowly)
                 */

                yy_next_state = yy_try_NUL_trans(yy_current_state);

                yy_bp = yy___text + YY_MORE_ADJ;

                if (yy_next_state) {
                    /* consume the NUL */
                    yy_cp = ++yy_c_buf_p;
                    yy_current_state = yy_next_state;
                    goto yy_match;
                } else {
                    /* % code to do backtracking for compressed tables and set up yy_cp goes here */
                    //#line 541 "//usr/local/lib/flexskel.cc"
                    goto yy_find_action;
                }
            } else
                switch (yy_get_next_buffer()) {
                case EOB_ACT_END_OF_FILE: {
                    yy_did_buffer_switch_on_eof = 0;

                    if (yywrap()) {
                        /* note: because we've taken care in
                         * yy_get_next_buffer() to have set up yy___text,
                         * we can now set up yy_c_buf_p so that if some
                         * total hoser (like flex itself) wants
                         * to call the scanner after we return the
                         * YY_NULL, it'll still work - another YY_NULL
                         * will get returned.
                         */
                        yy_c_buf_p = yy___text + YY_MORE_ADJ;

                        yy_act = YY_STATE_EOF((yy_start - 1) / 2);
                        goto do_action;
                    } else {
                        if (!yy_did_buffer_switch_on_eof)
                            YY_NEW_FILE;
                    }
                } break;

                case EOB_ACT_CONTINUE_SCAN:
                    yy_c_buf_p = yy___text + yy_amount_of_matched_text;

                    yy_current_state = yy_get_previous_state();

                    yy_cp = yy_c_buf_p;
                    yy_bp = yy___text + YY_MORE_ADJ;
                    goto yy_match;

                case EOB_ACT_LAST_MATCH:
                    yy_c_buf_p = &YY_SSLScanner_CURRENT_BUFFER->yy_ch_buf[yy_n_chars];

                    yy_current_state = yy_get_previous_state();

                    yy_cp = yy_c_buf_p;
                    yy_bp = yy___text + YY_MORE_ADJ;
                    goto yy_find_action;
                }
            break;
        }

        default:
#if YY_SSLScanner_DEBUG != 0
#ifndef YY_SSLScanner_IOSTREAM
            fprintf(yy___stderr, "action # %d\n", yy_act);
#else
            yy___stderr << "action # " << (int)yy_act << endl;
#endif
#endif
            YY_FATAL_ERROR("fatal flex scanner internal error--no action found");
        }
    }
    yyterminate(); /* avoid the no return value error message on MS-C7/dos */
}

/* yy_get_next_buffer - try to read in a new buffer
 *
 * synopsis
 *     int yy_get_next_buffer();
 *
 * returns a code representing an action
 *     EOB_ACT_LAST_MATCH -
 *     EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *     EOB_ACT_END_OF_FILE - end of file
 */
#ifndef YY_USE_CLASS
static int yy_get_next_buffer()
#else
int YY_SSLScanner_CLASS::yy_get_next_buffer()
#endif
{
    YY_SSLScanner_CHAR *dest = YY_SSLScanner_CURRENT_BUFFER->yy_ch_buf;
    YY_SSLScanner_CHAR *source = yy___text - 1; /* copy prev. char, too */
    int number_to_move, i;
    int ret_val;

    if (yy_c_buf_p > &YY_SSLScanner_CURRENT_BUFFER->yy_ch_buf[yy_n_chars + 1])
        YY_FATAL_ERROR("fatal flex scanner internal error--end of buffer missed");

    /* try to read more data */

    /* first move last chars to start of buffer */
    number_to_move = yy_c_buf_p - yy___text;

    for (i = 0; i < number_to_move; ++i)
        *(dest++) = *(source++);

    if (YY_SSLScanner_CURRENT_BUFFER->yy_eof_status != EOF_NOT_SEEN)
        /* don't do the read, it's not guaranteed to return an EOF,
         * just force an EOF
         */
        yy_n_chars = 0;

    else {
        int num_to_read = YY_SSLScanner_CURRENT_BUFFER->yy_buf_size - number_to_move - 1;

        if (num_to_read > YY_READ_BUF_SIZE)
            num_to_read = YY_READ_BUF_SIZE;

        else if (num_to_read <= 0)
            YY_FATAL_ERROR("fatal error - scanner input buffer overflow");

        /* read in more data */
        YY_INPUT((&YY_SSLScanner_CURRENT_BUFFER->yy_ch_buf[number_to_move]), yy_n_chars, num_to_read);
    }

    if (yy_n_chars == 0) {
        if (number_to_move - YY_MORE_ADJ == 1) {
            ret_val = EOB_ACT_END_OF_FILE;
            YY_SSLScanner_CURRENT_BUFFER->yy_eof_status = EOF_DONE;
        } else {
            ret_val = EOB_ACT_LAST_MATCH;
            YY_SSLScanner_CURRENT_BUFFER->yy_eof_status = EOF_PENDING;
        }
    } else
        ret_val = EOB_ACT_CONTINUE_SCAN;

    yy_n_chars += number_to_move;
    YY_SSLScanner_CURRENT_BUFFER->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
    YY_SSLScanner_CURRENT_BUFFER->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;

    /* yy___text begins at the second character in yy_ch_buf; the first
     * character is the one which preceded it before reading in the latest
     * buffer; it needs to be kept around in case it's a newline, so
     * yy_get_previous_state() will have with '^' rules active
     */

    yy___text = &YY_SSLScanner_CURRENT_BUFFER->yy_ch_buf[1];

    return (ret_val);
}

/* yy_get_previous_state - get the state just before the EOB char was reached
 *
 * synopsis
 *     yy_state_type yy_get_previous_state();
 */

#ifndef YY_USE_CLASS
static yy_state_type yy_get_previous_state()
#else
long YY_SSLScanner_CLASS::yy_get_previous_state_()
#endif
{
    yy_state_type yy_current_state;
    YY_SSLScanner_CHAR *yy_cp;

    /* % code to get the start state into yy_current_state goes here */
    yy_current_state = yy_start;
    yy_state_ptr = yy_state_buf;
    *yy_state_ptr++ = yy_current_state;
    //#line 717 "//usr/local/lib/flexskel.cc"

    for (yy_cp = yy___text + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp) {
        /* % code to find the next state goes here */
        YY_CHAR yy_c = (*yy_cp ? yy_ec[(unsigned char)*yy_cp] : 1);
        while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state) {
            yy_current_state = yy_def[yy_current_state];
            if (yy_current_state >= 336)
                yy_c = yy_meta[(unsigned char)yy_c];
        }
        yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
        *yy_state_ptr++ = yy_current_state;
        //#line 721 "//usr/local/lib/flexskel.cc"
    }

#ifndef YY_USE_CLASS
    return (yy_current_state);
#else
    return (long)(yy_current_state);
#endif
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *     next_state = yy_try_NUL_trans( current_state );
 */

#ifndef YY_USE_CLASS
#ifdef YY_USE_PROTOS
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state)
#else
static yy_state_type yy_try_NUL_trans(yy_current_state) register yy_state_type yy_current_state;
#endif
#else
long YY_SSLScanner_CLASS::yy_try_NUL_trans_(long yy_current_state_)
#endif
{
#ifndef YY_USE_CLASS
#else
    yy_state_type yy_current_state = (yy_state_type)yy_current_state_;
#endif
    int yy_is_jam;
    /* % code to find the next state, and perhaps do backtracking, goes here */

    YY_CHAR yy_c = 1;
    while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state) {
        yy_current_state = yy_def[yy_current_state];
        if (yy_current_state >= 336)
            yy_c = yy_meta[(unsigned char)yy_c];
    }
    yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
    *yy_state_ptr++ = yy_current_state;
    yy_is_jam = (yy_current_state == 335);
//#line 755 "//usr/local/lib/flexskel.cc"

#ifndef YY_USE_CLASS
    return (yy_is_jam ? 0 : yy_current_state);
#else
    return (long)(yy_is_jam ? 0 : yy_current_state);
#endif
}

#ifndef YY_USE_CLASS
#ifdef YY_USE_PROTOS
static void yyunput(YY_SSLScanner_CHAR c, YY_SSLScanner_CHAR *yy_bp)
#else
static void yyunput(c, yy_bp) YY_SSLScanner_CHAR c;
YY_SSLScanner_CHAR *yy_bp;
#endif
#else
void YY_SSLScanner_CLASS::yyunput(YY_SSLScanner_CHAR c, YY_SSLScanner_CHAR *yy_bp)
#endif
{
    YY_SSLScanner_CHAR *yy_cp = yy_c_buf_p;

    /* undo effects of setting up yy___text */
    *yy_cp = yy_hold_char;

    if (yy_cp < YY_SSLScanner_CURRENT_BUFFER->yy_ch_buf + 2) { /* need to shift things up to make room */
        int number_to_move = yy_n_chars + 2;          /* +2 for EOB chars */
        YY_SSLScanner_CHAR *dest =
            &YY_SSLScanner_CURRENT_BUFFER->yy_ch_buf[YY_SSLScanner_CURRENT_BUFFER->yy_buf_size + 2];
        YY_SSLScanner_CHAR *source = &YY_SSLScanner_CURRENT_BUFFER->yy_ch_buf[number_to_move];

        while (source > YY_SSLScanner_CURRENT_BUFFER->yy_ch_buf)
            *--dest = *--source;

        yy_cp += dest - source;
        yy_bp += dest - source;
        yy_n_chars = YY_SSLScanner_CURRENT_BUFFER->yy_buf_size;

        if (yy_cp < YY_SSLScanner_CURRENT_BUFFER->yy_ch_buf + 2)
            YY_FATAL_ERROR("flex scanner push-back overflow");
    }

    if (yy_cp > yy_bp && yy_cp[-1] == '\n')
        yy_cp[-2] = '\n';

    *--yy_cp = c;

    /* note: the formal parameter *must* be called "yy_bp" for this
     *       macro to now work correctly
     */
    YY_DO_BEFORE_ACTION; /* set up yy___text again */
}

#ifndef YY_USE_CLASS
#ifdef __cplusplus
static int yyinput()
#else
static int input()
#endif
#else
int YY_SSLScanner_CLASS::input()
#endif
{
    int c;
    YY_SSLScanner_CHAR *yy_cp = yy_c_buf_p;

    *yy_cp = yy_hold_char;

    if (*yy_c_buf_p == YY_END_OF_BUFFER_CHAR) {
        /* yy_c_buf_p now points to the character we want to return.
         * If this occurs *before* the EOB characters, then it's a
         * valid NUL; if not, then we've hit the end of the buffer.
         */
        if (yy_c_buf_p < &YY_SSLScanner_CURRENT_BUFFER->yy_ch_buf[yy_n_chars])
            /* this was really a NUL */
            *yy_c_buf_p = '\0';

        else { /* need more input */
            yy___text = yy_c_buf_p;
            ++yy_c_buf_p;

            switch (yy_get_next_buffer()) {
            case EOB_ACT_END_OF_FILE: {
                if (yywrap()) {
                    yy_c_buf_p = yy___text + YY_MORE_ADJ;
                    return (EOF);
                }

                YY_NEW_FILE;
#ifndef YY_USE_CLASS
#ifdef __cplusplus
                return (yyinput());
#else
                return (input());
#endif
#else
                return (input());
#endif
            } break;

            case EOB_ACT_CONTINUE_SCAN:
                yy_c_buf_p = yy___text + YY_MORE_ADJ;
                break;

            case EOB_ACT_LAST_MATCH:
#ifndef YY_USE_CLASS
#ifdef __cplusplus
                YY_FATAL_ERROR("unexpected last match in yyinput()");
#else
                YY_FATAL_ERROR("unexpected last match in input()");
#endif
#else
                YY_FATAL_ERROR("unexpected last match in YY_SSLScanner_CLASS::input()");
#endif
            }
        }
    }

    c = *yy_c_buf_p;
    yy_hold_char = *++yy_c_buf_p;

    return (c);
}

#ifndef YY_USE_CLASS
#ifdef YY_USE_PROTOS
void YY_SSLScanner_RESTART(YY_SSLScanner_IFILE *input_file)
#else
void YY_SSLScanner_RESTART(input_file) YY_SSLScanner_IFILE *input_file;
#endif
#else
void YY_SSLScanner_CLASS::YY_SSLScanner_RESTART(YY_SSLScanner_IFILE *input_file)
#endif
{
    YY_SSLScanner_INIT_BUFFER(YY_SSLScanner_CURRENT_BUFFER, input_file);
    YY_SSLScanner_LOAD_BUFFER_STATE();
}

#ifndef YY_USE_CLASS
#ifdef YY_USE_PROTOS
void YY_SSLScanner_SWITCH_TO_BUFFER(YY_BUFFER_STATE new_buffer)
#else
void YY_SSLScanner_SWITCH_TO_BUFFER(new_buffer) YY_BUFFER_STATE new_buffer;
#endif
#else
void YY_SSLScanner_CLASS::YY_SSLScanner_SWITCH_TO_BUFFER(YY_BUFFER_STATE new_buffer)
#endif
{
    if (YY_SSLScanner_CURRENT_BUFFER == new_buffer)
        return;

    if (YY_SSLScanner_CURRENT_BUFFER) {
        /* flush out information for old buffer */
        *yy_c_buf_p = yy_hold_char;
        YY_SSLScanner_CURRENT_BUFFER->yy_buf_pos = yy_c_buf_p;
        YY_SSLScanner_CURRENT_BUFFER->yy_n_chars = yy_n_chars;
    }

    YY_SSLScanner_CURRENT_BUFFER = new_buffer;
    YY_SSLScanner_LOAD_BUFFER_STATE();

    /* we don't actually know whether we did this switch during
     * EOF (yywrap()) processing, but the only time this flag
     * is looked at is after yywrap() is called, so it's safe
     * to go ahead and always set it.
     */
    yy_did_buffer_switch_on_eof = 1;
}

#ifndef YY_USE_CLASS
#ifdef YY_USE_PROTOS
void YY_SSLScanner_LOAD_BUFFER_STATE(void)
#else
void YY_SSLScanner_LOAD_BUFFER_STATE()
#endif
#else
void YY_SSLScanner_CLASS::YY_SSLScanner_LOAD_BUFFER_STATE()
#endif
{
    yy_n_chars = YY_SSLScanner_CURRENT_BUFFER->yy_n_chars;
    yy___text = yy_c_buf_p = YY_SSLScanner_CURRENT_BUFFER->yy_buf_pos;
    yy___in = YY_SSLScanner_CURRENT_BUFFER->yy_input_file;
    yy_hold_char = *yy_c_buf_p;
}

#ifndef YY_USE_CLASS
#ifdef YY_USE_PROTOS
YY_BUFFER_STATE YY_SSLScanner_CREATE_BUFFER(YY_SSLScanner_IFILE *file, int size)
#else
YY_BUFFER_STATE YY_SSLScanner_CREATE_BUFFER(file, size) YY_SSLScanner_IFILE *file;
int size;
#endif
#else
YY_BUFFER_STATE YY_SSLScanner_CLASS::YY_SSLScanner_CREATE_BUFFER(YY_SSLScanner_IFILE *file, int size)
#endif
{
    YY_BUFFER_STATE b;

    b = (YY_BUFFER_STATE)malloc(sizeof(struct yy_buffer_state));

    if (!b)
        YY_FATAL_ERROR("out of dynamic memory in YY_SSLScanner_CREATE_BUFFER()");

    b->yy_buf_size = size;

    /* yy_ch_buf has to be 2 characters longer than the size given because
     * we need to put in 2 end-of-buffer characters.
     */
    b->yy_ch_buf = (YY_SSLScanner_CHAR *)malloc((unsigned)(b->yy_buf_size + 2));

    if (!b->yy_ch_buf)
        YY_FATAL_ERROR("out of dynamic memory in YY_SSLScanner_CREATE_BUFFER()");

    YY_SSLScanner_INIT_BUFFER(b, file);

    return (b);
}

#ifndef YY_USE_CLASS
#ifdef YY_USE_PROTOS
void YY_SSLScanner_DELETE_BUFFER(YY_BUFFER_STATE b)
#else
void YY_SSLScanner_DELETE_BUFFER(b) YY_BUFFER_STATE b;
#endif
#else
void YY_SSLScanner_CLASS::YY_SSLScanner_DELETE_BUFFER(YY_BUFFER_STATE b)
#endif
{
    if (b == YY_SSLScanner_CURRENT_BUFFER)
        YY_SSLScanner_CURRENT_BUFFER = (YY_BUFFER_STATE)0;

    free((char *)b->yy_ch_buf);
    free((char *)b);
}

#ifndef YY_USE_CLASS
#ifdef YY_USE_PROTOS
void YY_SSLScanner_INIT_BUFFER(YY_BUFFER_STATE b, YY_SSLScanner_IFILE *file)
#else
void YY_SSLScanner_INIT_BUFFER(b, file) YY_BUFFER_STATE b;
YY_SSLScanner_IFILE *file;
#endif
#else
void YY_SSLScanner_CLASS::YY_SSLScanner_INIT_BUFFER(YY_BUFFER_STATE b, YY_SSLScanner_IFILE *file)
#endif
{
    b->yy_input_file = file;

    /* we put in the '\n' and start reading from [1] so that an
     * initial match-at-newline will be true.
     */

    b->yy_ch_buf[0] = '\n';
    b->yy_n_chars = 1;

    /* we always need two end-of-buffer characters.  The first causes
     * a transition to the end-of-buffer state.  The second causes
     * a jam in that state.
     */
    b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
    b->yy_ch_buf[2] = YY_END_OF_BUFFER_CHAR;

    b->yy_buf_pos = &b->yy_ch_buf[1];

    b->yy_eof_status = EOF_NOT_SEEN;
}
//#line 327 "db/sslscanner.l"
