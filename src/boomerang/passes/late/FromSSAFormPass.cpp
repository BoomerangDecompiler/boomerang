#pragma region License
/*
 * This file is part of the Boomerang Decompiler.
 *
 * See the file "LICENSE.TERMS" for information on usage and
 * redistribution of this file, and for a DISCLAIMER OF ALL
 * WARRANTIES.
 */
#pragma endregion License
#include "FromSSAFormPass.h"

#include "boomerang/core/Project.h"
#include "boomerang/core/Settings.h"
#include "boomerang/db/Prog.h"
#include "boomerang/db/proc/UserProc.h"
#include "boomerang/decomp/InterferenceFinder.h"
#include "boomerang/passes/PassManager.h"
#include "boomerang/ssl/exp/Location.h"
#include "boomerang/ssl/exp/RefExp.h"
#include "boomerang/ssl/statements/PhiAssign.h"
#include "boomerang/ssl/type/VoidType.h"
#include "boomerang/util/ConnectionGraph.h"
#include "boomerang/util/log/Log.h"
#include "boomerang/visitor/expmodifier/ExpCastInserter.h"
#include "boomerang/visitor/expmodifier/ExpSSAXformer.h"
#include "boomerang/visitor/expvisitor/ExpRegMapper.h"
#include "boomerang/visitor/stmtexpvisitor/StmtRegMapper.h"
#include "boomerang/visitor/stmtmodifier/StmtSSAXFormer.h"
#include "boomerang/visitor/stmtvisitor/StmtCastInserter.h"


FromSSAFormPass::FromSSAFormPass()
    : IPass("FromSSAForm", PassID::FromSSAForm)
{
}


bool FromSSAFormPass::execute(UserProc *proc)
{
    proc->getProg()->getProject()->alertDecompiling(proc);

    StatementList stmts;
    proc->getStatements(stmts);

    for (SharedStmt s : stmts) {
        // Map registers to initial local variables
        mapRegistersToLocals(s);

        // Insert casts where needed, as types are about to become inaccessible
        insertCastsForStmt(s);
    }

    // First split the live ranges where needed by reason of type incompatibility, i.e. when the
    // type of a subscripted variable is different to its previous type. Start at the top, because
    // we don't want to rename parameters (e.g. argc)
    typedef std::pair<SharedType, SharedExp> FirstTypeEnt;
    typedef std::map<SharedExp, FirstTypeEnt, lessExpStar> FirstTypesMap;

    FirstTypesMap firstTypes;

    ConnectionGraph ig; // The interference graph; these can't have the same local variable
    ConnectionGraph pu; // The Phi Unites: these need the same local variable or copies
    const bool assumeABICompliance = proc->getProg()->getProject()->getSettings()->assumeABI;

    for (SharedStmt s : stmts) {
        LocationSet defs;
        s->getDefinitions(defs, assumeABICompliance);

        for (SharedExp defdByS : defs) {
            SharedType ty = s->getTypeForExp(defdByS);

            if (ty == nullptr) { // Can happen e.g. when getting the type for %flags
                ty = VoidType::get();
            }

            if (proc->getProg()->getProject()->getSettings()->debugLiveness) {
                LOG_MSG("Got type %1 for %2 from %3", ty->getCtype(), defdByS, s);
            }

            FirstTypesMap::iterator ff = firstTypes.find(defdByS);
            SharedExp ref              = RefExp::get(defdByS, s);

            if (ff == firstTypes.end()) {
                // There is no first type yet. Record it.
                firstTypes[defdByS] = { ty, ref };
            }
            else if (ff->second.first && !ty->isCompatibleWith(*ff->second.first)) {
                if (proc->getProg()->getProject()->getSettings()->debugLiveness) {
                    LOG_WARN("Def of %1 at '%2' is not compatible with first type %3.", defdByS,
                             s->toString(), ff->second.first);
                }

                // There already is a type for defdByS, and it is different to the type for this
                // definition. Record an "interference" so it will get a new variable
                if (!ty->isVoid()) { // just ignore void interferences ??!!
                    ig.add(ref, ff->second.second);
                }
            }
        }
    }
    assert(ig.allRefsHaveDefs());

    // Find the interferences generated by more than one version of a variable being live at the
    // same program point
    InterferenceFinder(proc->getCFG()).findInterferences(ig);
    assert(ig.allRefsHaveDefs());

    // Find the set of locations that are "united" by phi-functions
    // FIXME: are these going to be trivially predictable?
    findPhiUnites(proc, pu);

    if (proc->getProg()->getProject()->getSettings()->debugLiveness) {
        LOG_MSG("## ig interference graph:");

        for (const auto &[from, to] : ig) {
            LOG_MSG("   ig %1 -> %2", from, to);
        }

        LOG_MSG("## pu phi unites graph:");

        for (const auto &[from, to] : pu) {
            LOG_MSG("   pu %1 -> %2", from, to);
        }
    }

    // Choose one of each interfering location to give a new name to
    assert(ig.allRefsHaveDefs());

    for (const auto &[first, second] : ig) {
        auto ref1     = first->access<RefExp>();
        auto ref2     = second->access<RefExp>(); // r1 -> r2 and vice versa
        QString name1 = proc->lookupSymFromRefAny(ref1);
        QString name2 = proc->lookupSymFromRefAny(ref2);

        if (!name1.isEmpty() && !name2.isEmpty() && (name1 != name2)) {
            continue; // Already different names, probably because of the redundant mapping
        }

        std::shared_ptr<RefExp> rename;

        if (ref1->isImplicitDef()) {
            // If r1 is an implicit definition, don't rename it (it is probably a parameter, and
            // should retain its current name)
            rename = ref2;
        }
        else if (ref2->isImplicitDef()) {
            rename = ref1; // Ditto for r2
        }

        if (rename == nullptr) {
            if (ref2->getDef()->isPhi()) { // Prefer the destinations of phis
                rename = ref2;
            }
            else {
                rename = ref1;
            }
        }

        SharedType ty   = rename->getDef()->getTypeForExp(rename->getSubExp1());
        SharedExp local = proc->createLocal(ty, rename);

        if (proc->getProg()->getProject()->getSettings()->debugLiveness) {
            LOG_MSG("Renaming %1 to %2", rename, local);
        }

        proc->mapSymbolTo(rename, local);
    }

    // Implement part of the Phi Unites list, where renamings or parameters have broken them, by
    // renaming. The rest of them will be done as phis are removed The idea is that where l1 and l2
    // have to unite, and exactly one of them already has a local/name, you can implement the
    // unification by giving the unnamed one the same name as the named one, as long as they don't
    // interfere
    for (const auto &[first, second] : pu) {
        auto ref1     = first->access<RefExp>();
        auto ref2     = second->access<RefExp>();
        QString name1 = proc->lookupSymFromRef(ref1);
        QString name2 = proc->lookupSymFromRef(ref2);

        if (!name1.isEmpty() && !name2.isEmpty() && !ig.isConnected(ref1, *ref2)) {
            // There is a case where this is unhelpful, and it happen in test/pentium/fromssa2. We
            // have renamed the destination of the phi to ebx_1, and that leaves the two phi
            // operands as ebx. However, we attempt to unite them here, which will cause one of the
            // operands to become ebx_1, so the neat oprimisation of replacing the phi with one copy
            // doesn't work. The result is an extra copy. So check of r1 is a phi and r2 one of its
            // operands, and all other operands for the phi have the same name. If so, don't rename.
            SharedStmt def1 = ref1->getDef();

            if (def1->isPhi()) {
                bool allSame     = true;
                bool r2IsOperand = false;
                QString firstName;
                std::shared_ptr<PhiAssign> pa = def1->as<PhiAssign>();

                for (const std::shared_ptr<RefExp> &refExp : *pa) {
                    auto re(RefExp::get(refExp->getSubExp1(), refExp->getDef()));

                    if (*re == *ref2) {
                        r2IsOperand = true;
                    }

                    if (firstName.isEmpty()) {
                        firstName = proc->lookupSymFromRefAny(re);
                    }
                    else {
                        QString tmp = proc->lookupSymFromRefAny(re);

                        if (tmp.isEmpty() || (firstName != tmp)) {
                            allSame = false;
                            break;
                        }
                    }
                }

                if (allSame && r2IsOperand) {
                    continue; // This situation has happened, don't map now
                }
            }

            proc->mapSymbolTo(ref2, Location::local(name1, proc));
            continue;
        }
    }

    /*   *   *   *   *   *   *   *   *   *   *   *   *   *   *\
     *                                                       *
     *     IR gets changed with hard locals and params here  *
     *                                                       *
    \*   *   *   *   *   *   *   *   *   *   *   *   *   *   */

    // First rename the variables (including phi's, but don't remove).
    // NOTE: it is not possible to postpone renaming these locals till the back end, since the same
    // base location may require different names at different locations, e.g. r28{0} is local0,
    // r28{16} is local1
    // Update symbols and parameters, particularly for the stack pointer inside
    // memofs.
    // NOTE: the ordering of the below operations is critical! Re-ordering may well prevent
    // e.g. parameters from renaming successfully.
    assert(proc->allPhisHaveDefs());
    nameParameterPhis(proc);
    PassManager::get()->executePass(PassID::LocalAndParamMap, proc);
    mapParameters(proc);
    removeSubscriptsFromSymbols(proc);
    removeSubscriptsFromParameters(proc);

    for (SharedStmt s : stmts) {
        // The last part of the fromSSA logic:
        // replace subscripted locations with suitable local variables
        ExpSSAXformer esx(proc);
        StmtSSAXformer ssx(&esx, proc);

        s->accept(&ssx);
    }

    // Now remove the phis
    for (SharedStmt s : stmts) {
        if (!s->isPhi()) {
            continue;
        }

        // Check if the base variables are all the same
        std::shared_ptr<PhiAssign> phi = s->as<PhiAssign>();

        if (phi->begin() == phi->end()) {
            // no params to this phi, just remove it
            LOG_VERBOSE("Phi with no params, removing: %1", s);

            proc->removeStatement(s);
            continue;
        }

        LocationSet refs;
        phi->addUsedLocs(refs);
        bool phiParamsSame = true;
        SharedExp first    = nullptr;

        if (phi->getNumDefs() > 1) {
            for (const std::shared_ptr<RefExp> &pi : *phi) {
                if (pi->getSubExp1() == nullptr) {
                    continue;
                }

                if (first == nullptr) {
                    first = pi->getSubExp1();
                    continue;
                }

                if (!(*(pi->getSubExp1()) == *first)) {
                    phiParamsSame = false;
                    break;
                }
            }
        }

        if (phiParamsSame && first) {
            // Is the left of the phi assignment the same base variable as all the operands?
            if (*phi->getLeft() == *first) {
                if (proc->getProg()->getProject()->getSettings()->debugLiveness ||
                    proc->getProg()->getProject()->getSettings()->debugUnused) {
                    LOG_MSG("Removing phi: left and all refs same or 0: %1", s);
                }

                // Just removing the refs will work, or removing the whole phi
                // NOTE: Removing the phi here may cause other statments to be not used.
                proc->removeStatement(s);
            }
            else {
                // Need to replace the phi by an expression,
                // e.g. local0 = phi(r24{3}, r24{5}) becomes
                //        local0 = r24
                proc->replacePhiByAssign(phi, first->clone());
            }
        }
        else {
            // Need new local(s) for phi operands that have different names from the lhs

            // This way is costly in copies, but has no problems with extending live ranges
            // Exp* tempLoc = newLocal(pa->getType());
            SharedExp tempLoc = proc->getSymbolExp(RefExp::get(phi->getLeft(), phi),
                                                   phi->getType());

            if (proc->getProg()->getProject()->getSettings()->debugLiveness) {
                LOG_MSG("Phi statement %1 requires local, using %2", s, tempLoc);
            }

            // For each definition ref'd in the phi
            for (const std::shared_ptr<RefExp> &pi : *phi) {
                if (pi->getSubExp1() == nullptr) {
                    continue;
                }

                proc->insertAssignAfter(pi->getDef(), tempLoc, pi->getSubExp1());
            }

            // Replace the RHS of the phi with tempLoc
            proc->replacePhiByAssign(phi, tempLoc);
        }
    }

    return true;
}


void FromSSAFormPass::nameParameterPhis(UserProc *proc)
{
    StatementList stmts;
    proc->getStatements(stmts);

    for (SharedStmt insn : stmts) {
        if (!insn->isPhi()) {
            continue; // Might be able to optimise this a bit
        }

        std::shared_ptr<PhiAssign> pi = insn->as<PhiAssign>();
        // See if the destination has a symbol already
        SharedExp lhs = pi->getLeft();
        auto lhsRef   = RefExp::get(lhs, pi);

        if (proc->findFirstSymbol(lhsRef) != nullptr) {
            continue; // Already mapped to something
        }

        bool multiple = false; // True if find more than one unique parameter
        QString firstName;     // The name for the first parameter found
        SharedType ty = pi->getType();

        for (const std::shared_ptr<RefExp> &v : *pi) {
            if (v->getDef()->isImplicit()) {
                QString name = proc->lookupSym(RefExp::get(v->getSubExp1(), v->getDef()), ty);

                if (!name.isEmpty()) {
                    if (!firstName.isEmpty() && (firstName != name)) {
                        multiple = true;
                        break;
                    }

                    firstName = name; // Remember this candidate
                }
            }
        }

        if (multiple || firstName.isEmpty()) {
            continue;
        }

        proc->mapSymbolTo(lhsRef, Location::param(firstName, proc));
    }
}


void FromSSAFormPass::mapParameters(UserProc *proc)
{
    // Replace the parameters with their mappings
    StatementList::iterator pp;

    for (pp = proc->getParameters().begin(); pp != proc->getParameters().end(); ++pp) {
        SharedExp lhs      = (*pp)->as<Assignment>()->getLeft();
        QString mappedName = proc->lookupParam(lhs);

        if (mappedName.isEmpty()) {
            LOG_WARN("No symbol mapping for parameter %1", lhs);
            bool allZero;
            SharedExp clean = lhs->clone()->removeSubscripts(allZero);

            if (allZero) {
                (*pp)->as<Assignment>()->setLeft(clean);
            }

            // Else leave them alone
        }
        else {
            (*pp)->as<Assignment>()->setLeft(Location::param(mappedName, proc));
        }
    }
}


void FromSSAFormPass::removeSubscriptsFromSymbols(UserProc *proc)
{
    // Basically, use the symbol map to map the symbols in the symbol map!
    // However, do not remove subscripts from the outer level; they are still needed for comments in
    // the output and also for when removing subscripts from parameters (still need the {0}) Since
    // this will potentially change the ordering of entries, need to copy the map
    UserProc::SymbolMap sm2 = proc->getSymbolMap(); // Object copy

    proc->getSymbolMap().clear();
    ExpSSAXformer esx(proc);

    for (const auto &[first, second] : sm2) {
        SharedExp from = std::const_pointer_cast<Exp>(first);

        if (from->isSubscript()) {
            // As noted above, don't touch the outer level of subscripts
            SharedExp &sub = from->refSubExp1();
            sub            = sub->acceptModifier(&esx);
        }
        else {
            from = from->acceptModifier(&esx);
        }

        proc->mapSymbolTo(from, second);
    }
}


void FromSSAFormPass::removeSubscriptsFromParameters(UserProc *proc)
{
    ExpSSAXformer esx(proc);

    for (SharedStmt param : proc->getParameters()) {
        SharedExp left = param->as<Assignment>()->getLeft();
        left           = left->acceptModifier(&esx);
        param->as<Assignment>()->setLeft(left);
    }
}


void FromSSAFormPass::findPhiUnites(UserProc *proc, ConnectionGraph &pu)
{
    StatementList stmts;
    proc->getStatements(stmts);

    for (SharedStmt stmt : stmts) {
        if (!stmt->isPhi()) {
            continue;
        }

        std::shared_ptr<PhiAssign> pa = stmt->as<PhiAssign>();
        SharedExp lhs = pa->getLeft();
        auto reLhs    = RefExp::get(lhs, pa);

        for (const std::shared_ptr<RefExp> &v : *pa) {
            assert(v->getSubExp1());
            auto re = RefExp::get(v->getSubExp1(), v->getDef());
            pu.connect(reLhs, re);
        }
    }
}


void FromSSAFormPass::insertCastsForStmt(const SharedStmt &stmt)
{
    // First we postvisit expressions using a StmtModifier and an ExpCastInserter
    ExpCastInserter eci;
    StmtModifier sm(&eci, true); // True to ignore collectors
    stmt->accept(&sm);

    // Now handle the LHS of assigns that happen to be m[...], using a StmtCastInserter
    StmtCastInserter sci;
    stmt->accept(&sci);
}


void FromSSAFormPass::mapRegistersToLocals(const SharedStmt &stmt)
{
    ExpRegMapper erm(stmt->getProc());
    StmtRegMapper srm(&erm);

    stmt->accept(&srm);
}
