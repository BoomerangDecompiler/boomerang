#define YY_CHAR    char

/* A lexical scanner generated by flex */

/* scanner skeleton version:
 * $Header$
 */
/* MODIFIED FOR C++ CLASS BY Alain Coetmeur: coetmeur(at)icdc.fr */
/* Note that (at) mean the 'at' symbol that I cannot write */
/* because it is expanded to the class name */
/* made at Informatique-CDC, Research&development department */
/* company from the Caisse Des Depots et Consignations */
/* institutional financial group  */

/* theses symbols are added before this file */
/* #define YY_CHAR 'unsigned char' if 8bit or 'char' if 7bit */
/* #define FLEX_DEBUG if debug mode */

/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
#ifdef c_plusplus
#ifndef __cplusplus
#define __cplusplus
#endif
#endif

#include <cstdlib>
#define YY_USE_CONST
#define YY_USE_PROTOS
#ifndef YY_USE_CLASS
#define YY_USE_CLASS
#endif

#include <cstdio>
#include <cstring>

/*********************************************/
/* COMPILER DEPENDENT   MACROS               */
/*********************************************/
/* use prototypes in function declarations */
/* the "const" storage-class-modifier is valid */
#ifndef YY_USE_CONST
#define const
#endif
/* use prototypes in function declarations */
#ifndef YY_PROTO
#ifdef YY_USE_PROTOS
#define YY_PROTO(proto)    proto
#else
#define YY_PROTO(proto)    ()
#endif
#endif

/*********************/
/* parameters        */

/* amount of stuff to slurp up with each read */
#ifndef YY_READ_BUF_SIZE
#define YY_READ_BUF_SIZE    8192
#endif
/* size of default input buffer */
#ifndef YY_BUF_SIZE
#define YY_BUF_SIZE    (YY_READ_BUF_SIZE * 2)
#endif

/***********************************/
/* to be redefined for application */

/* returned upon end-of-file */

/* no semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#define yyterminate()    return (YY_NULL)

/* code executed at the end of each rule */
#define YY_BREAK    break;

/* #define YY_USER_ACTION */
/* #define YY_USER_INIT */

/* c++ */
#define ECHO    yy___echo()
#define YY_INPUT(buf, result, max_size)                     \
    if (yy___input((char *)buf, result, max_size) < 0) { \
        YY_FATAL_ERROR("YY_INPUT() in flex scanner failed"); }

#define YY_FATAL_ERROR(msg)    yy___fatal_error(msg)
#define yywrap()               yy___wrap()

/***********************************/
/* not to be changed */
#define YY_NULL                  0
#define YY_END_OF_BUFFER_CHAR    0

/* enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN
 */
/* action number for EOF rule of a given start state */
#define YY_STATE_EOF(state)    (YY_END_OF_BUFFER + state + 1)
/* % section 1 definitions go here */
#define INITIAL    0

/**
 * \file ansi-c.l Scanner for ANSI C.
 */

/* ALlow ? and @ in identifiers, so we can use mangled names */
#include "ansi-c-scanner.h"

#define yy___text          YY_AnsiCScanner_TEXT
#define yy___leng          YY_AnsiCScanner_LENG
#define yy___in            YY_AnsiCScanner_IN
#define yy___out           YY_AnsiCScanner_OUT
#define yy___newfile                                                          \
    do {                                                                      \
        YY_AnsiCScanner_INIT_BUFFER(YY_AnsiCScanner_CURRENT_BUFFER, yy___in); \
        YY_AnsiCScanner_LOAD_BUFFER_STATE();                                  \
    } while (0)
#if YY_AnsiCScanner_DEBUG != 0
#define yy___flex_debug    YY_AnsiCScanner_DEBUG_FLAG
#endif

#ifdef YY_USE_CLASS

#define yy___echo           YY_AnsiCScanner_ECHO
#define yy___input          YY_AnsiCScanner_INPUT
#define yy___fatal_error    YY_AnsiCScanner_FATAL_ERROR
#define yy___wrap           YY_AnsiCScanner_WRAP

#endif

#define EOB_ACT_CONTINUE_SCAN    0
#define EOB_ACT_END_OF_FILE      1
#define EOB_ACT_LAST_MATCH       2

struct yy_buffer_state
{
    YY_AnsiCScanner_IFILE *yy_input_file;
    YY_AnsiCScanner_CHAR  *yy_ch_buf;  /* input buffer */
    YY_AnsiCScanner_CHAR  *yy_buf_pos; /* current position in input buffer */

    /* size of input buffer in bytes, not including room for EOB characters */
    int                   yy_buf_size;

    /* number of characters read into yy_ch_buf, not including EOB characters */
    int                   yy_n_chars;

    int                   yy_eof_status; /* whether we've seen an EOF on this buffer */
#define EOF_NOT_SEEN    0

/* "pending" happens when the EOF has been seen but there's still
 * some text process
 */
#define EOF_PENDING     1
#define EOF_DONE        2
};

/* we provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state"
 */

#ifndef YY_USE_CLASS
#else
/* c++ */
#ifndef YY_AnsiCScanner_ECHO_NOCODE
void YY_AnsiCScanner_CLASS::yy___echo()
{
    YY_AnsiCScanner_ECHO_CODE
}


#endif
#ifndef YY_AnsiCScanner_INPUT_NOCODE
int YY_AnsiCScanner_CLASS::yy___input(char *buffer, int& result, int max_size)
{
    if (in.eof()) {
        result = 0;
    }
    else {
        in.read(buffer, max_size);
        result = in.gcount();
    }

    return result;
}


#endif
#ifndef YY_AnsiCScanner_FATAL_ERROR_NOCODE
void YY_AnsiCScanner_CLASS::yy___fatal_error(const char *msg)
{
    YY_AnsiCScanner_FATAL_ERROR_CODE
}


#endif
#ifndef YY_AnsiCScanner_WRAP_NOCODE
int YY_AnsiCScanner_CLASS::yy___wrap()
{
    YY_AnsiCScanner_WRAP_CODE
}


#endif
void YY_AnsiCScanner_CLASS::yy_initialize()
{
    yy___in   = nullptr;
    yy___out  = nullptr;
    yy_init   = 1;
    yy_start  = 0;
    yy___text = nullptr;
    yy___leng = 0;
    YY_AnsiCScanner_CURRENT_BUFFER = nullptr;
    yy_did_buffer_switch_on_eof    = 0;
    yy_c_buf_p   = nullptr;
    yy_hold_char = 0;
    yy_n_chars   = 0;
#if YY_AnsiCScanner_DEBUG != 0
    YY_AnsiCScanner_DEBUG_FLAG = YY_AnsiCScanner_DEBUG_INIT;
#endif
}


YY_AnsiCScanner_CLASS::YY_AnsiCScanner_CLASS(YY_AnsiCScanner_CONSTRUCTOR_PARAM) YY_AnsiCScanner_CONSTRUCTOR_INIT {
    yy_initialize();
    YY_AnsiCScanner_CONSTRUCTOR_CODE;
}
YY_AnsiCScanner_CLASS::~YY_AnsiCScanner_CLASS()
{
    YY_AnsiCScanner_DESTRUCTOR_CODE;

    if (YY_AnsiCScanner_CURRENT_BUFFER) {
        YY_AnsiCScanner_DELETE_BUFFER(YY_AnsiCScanner_CURRENT_BUFFER);
    }
}


#endif

#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif

#ifndef YY_USER_INIT
#define YY_USER_INIT
#endif

/* % data tables for the DFA go here */
#define YY_END_OF_BUFFER    112
typedef int yy_state_type;
static const short int yy_accept[346] =
{
    0,                   0,  0, 112, 110, 109, 109, 97, 110, 103, 96, 110, 91, 92, 101, 100, 88, 99, 95, 102, 57, 57, 89, 85, 104,
    90,                105, 54,  54,  54,  54,  54, 93,  94, 106, 54,  54, 54, 54,  54,  54, 54, 54, 54,  54, 54, 54, 54, 54,  54,
    54,                 54, 86, 107,  87,  98, 110, 84,   0,  62,  0,  70, 79, 71,   0,   0, 68, 76, 66,  77, 67, 78,  0, 60,   7,
    8,                  69, 61,  56,   0,  57,   0, 57,  75,  81, 83,  82, 74, 54,  54,   0,  0, 54, 72,  54, 54, 54, 54, 54,  54,
    54,                 16, 54,  54,  54,  54,  54, 54,  24,  54, 54,  52, 51, 54,  54,  54, 54, 54, 54,  54, 54, 54, 73, 80,   0,
    0,                   0,  0,  58,  63,   0,  60, 60,   0,  61, 56,   0, 59, 55,  65,  64, 54, 54, 54,  54, 54, 54, 54, 54,  54,
    54,                 54, 54,  54,  54,  54,  54, 54,  54,  54, 54,  22, 54, 25,  54,  54, 54, 54, 54,  54, 54, 54, 54, 54,  54,
    54,                 54, 54,  54,   0,   0,   3,  0,   0,   0, 60,   0, 60,  0,  61,  59, 55, 54, 54,  54, 54, 54, 54, 54,  54,
    54,                 54, 54,   9,  54,  11,  12, 54,  54,  54, 54,  18, 19, 54,  54,  23, 26, 54, 54,  54, 54, 54, 54, 54,  54,
    54,                 54, 54,  48,  54,  54,   0,  0,   0,   0,  0,   0, 60, 53,  54,  54, 54, 54, 54,  54, 54, 54, 54, 54,  10,
    13,                 54, 54,  54,  54,  21,  54, 54,  29,  54, 54,  54, 54, 54,  54,  46, 54, 54, 50,   0,  0,  0,  0,  6,  39,
    54,                 54, 54,  54,  54,  54,  54, 54,  54,  54, 54,  17, 20, 54,  28,  30, 31, 42, 43,  44, 54, 54, 54,  0,   5,
    4,                   0, 34,  54,  54,  54,  54, 54,  54,  54, 54,  54, 15, 54,  45,  54, 54,  2,  0,  37, 54, 54, 35, 54,  41,
    54,                 54, 14,  27,  47,  49,   1, 54,  54,  36, 54,  54, 54, 32,  38,  54, 54, 54, 33,  40, 0
};

static const YY_CHAR yy_ec[128] =
{
    0,                  1,  1,  1,  1,  1,  1,  1,  1,  2,  3,  2,  2,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
    1,                  1,  1,  1,  1,  1,  2,  4,  5,  6,  1,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 19, 19,
    19,                19, 19, 19, 19, 19, 20, 21, 22, 23, 24, 25, 26, 27, 27, 27, 27, 28, 29, 30, 30, 30, 30, 30, 31, 30,
    30,                30, 32, 30, 33, 30, 30, 34, 30, 30, 35, 30, 30, 36, 37, 38, 39, 40,  1, 41, 42, 43, 44, 45, 46, 47,
    48,                49, 30, 50, 51, 52, 53, 54, 55, 30, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 1
};

static const YY_CHAR yy_meta[69] =
{
    0, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 1, 1, 1,
    1, 1, 4, 4, 3, 3, 3, 4, 4, 4, 4, 4, 4, 1, 1, 1, 1, 4, 3, 3, 3, 3, 3,
    3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 1, 1, 1, 1
};

static const short int yy_base[350] =
{
    0,                                   0, 470, 475, 477, 477, 477, 451,  64, 450,  62, 435, 477, 477, 448,  58, 477,  59,  57,  67,  86,  79,
    477,                               477,  55, 447,  63,   0, 417,   0,  83, 435, 477, 477, 444, 426, 406, 408,  52,  35,  65,  40, 409,  50,
    408,                               425,  63,  74, 397, 406, 404, 409, 477,  49, 477, 477,  95, 477, 104, 477, 453, 477, 477, 477, 110, 125,
    477,                               477, 477, 477, 477, 477, 439, 124, 477, 477, 477, 131, 155, 148, 134,   0, 176, 431, 477, 477, 477, 430,
    0,                                 411, 120, 414, 422, 477, 162, 391, 403, 390, 405, 392, 398, 384, 385, 382, 382, 385, 382, 379,   0, 378,
    382,                               477, 477, 132, 380,  65,  70, 384, 377, 107, 129, 382, 477, 477, 385, 376, 105, 379, 477, 477, 183, 477,
    210,                               218, 477, 157, 194, 228, 191, 477, 477, 365, 397, 128, 372, 370, 382, 182, 374, 372, 366, 378, 373, 361,
    186,                               375, 373, 369, 361, 367, 370,   0, 356,   0, 362, 359, 348, 350, 352, 359, 345, 343, 343, 355, 345, 349,
    353,                               355, 344, 348, 349, 348, 348, 337, 230, 234, 249, 477, 251, 253, 477, 242, 379, 360, 342, 329, 342, 340,
    326,                               338, 329, 331, 321,   0, 328,   0,   0, 319, 327, 316, 323,   0,   0, 317, 314,   0,   0, 314, 314, 311,
    323,                               313, 317, 322, 321, 319, 309, 314,   0, 302, 314, 309, 308, 311, 304, 309, 259, 269, 477, 320, 309, 293,
    296,                               304, 305, 304, 290, 288, 296,   0,   0, 290, 291, 296, 287,   0, 281, 285,   0, 293, 290, 292, 276, 285,
    287,                                 0, 278, 277,   0, 266, 272, 271, 257, 477,   0, 263, 259, 260, 268, 269, 268, 263, 264, 249, 246, 245,
    0,                                   0, 257,   0,   0,   0,   0,   0,   0, 251, 251, 244, 249, 477, 477, 248,   0, 239, 235, 235, 235, 232,
    235,                               234, 208, 215,   0, 202,   0, 210, 206, 477, 189,   0, 181, 186,   0, 175,   0, 173, 177,   0,   0,   0,
    0,                                 477, 164, 158,   0, 148, 154, 126,   0,   0, 131, 109, 126,   0, 477, 477, 320, 324, 326, 130
};

static const short int yy_def[350] =
{
    0,                                 345,   1, 345, 345, 345, 345, 345, 346, 345, 345, 347, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345,
    345,                               345, 345, 345, 345, 348, 348, 348, 348, 348, 345, 345, 345, 348, 348, 348, 348, 348, 348, 348, 348, 348,
    348,                               348, 348, 348, 348, 348, 348, 348, 345, 345, 345, 345, 345, 345, 346, 345, 346, 345, 345, 345, 347, 347,
    345,                               345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 349, 345, 345, 345, 345, 345, 345,
    348,                               348, 346, 347, 348, 345, 348, 348, 348, 348, 348, 348, 348, 348, 348, 348, 348, 348, 348, 348, 348, 348,
    348,                               345, 345, 348, 348, 348, 348, 348, 348, 348, 348, 348, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345,
    345,                               345, 345, 345, 345, 345, 349, 345, 345, 348, 348, 348, 348, 348, 348, 348, 348, 348, 348, 348, 348, 348,
    348,                               348, 348, 348, 348, 348, 348, 348, 348, 348, 348, 348, 348, 348, 348, 348, 348, 348, 348, 348, 348, 348,
    348,                               348, 348, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 348, 348, 348, 348, 348, 348,
    348,                               348, 348, 348, 348, 348, 348, 348, 348, 348, 348, 348, 348, 348, 348, 348, 348, 348, 348, 348, 348, 348,
    348,                               348, 348, 348, 348, 348, 348, 348, 348, 348, 348, 345, 345, 345, 345, 345, 345, 345, 345, 348, 348, 348,
    348,                               348, 348, 348, 348, 348, 348, 348, 348, 348, 348, 348, 348, 348, 348, 348, 348, 348, 348, 348, 348, 348,
    348,                               348, 348, 348, 348, 345, 345, 345, 345, 345, 348, 348, 348, 348, 348, 348, 348, 348, 348, 348, 348, 348,
    348,                               348, 348, 348, 348, 348, 348, 348, 348, 348, 348, 348, 345, 345, 345, 345, 348, 348, 348, 348, 348, 348,
    348,                               348, 348, 348, 348, 348, 348, 348, 348, 345, 345, 348, 348, 348, 348, 348, 348, 348, 348, 348, 348, 348,
    348,                               345, 348, 348, 348, 348, 348, 348, 348, 348, 348, 348, 348, 348, 345,   0, 345, 345, 345, 345
};

static const short int yy_nxt[546] =
{
    0,                                   4,   5,   6,   7,   8,   4,   9,  10,  11,  12,  13,  14,  15,  16,  17,  18,  19,  20,  21,  22,  23,  24,
    25,                                 26,  27,  28,  29,  29,  29,  29,  30,  31,  29,  29,  29,  32,   4,  33,  34,  35,  36,  37,  38,  39,  40,
    41,                                 42,  29,  43,  29,  44,  45,  29,  29,  29,  46,  47,  48,  49,  50,  51,  29,  29,  29,  52,  53,  54,  55,
    59,                                 62,  67, 122,  72,  69,  73,  73,  83,  84,  74, 100,  68,  70,  71,  75,  63,  86,  87,  90, 101,  76, 105,
    91,                                 97, 106,  77, 108,  82,  82, 112,  98,  60,  77, 109,  78,  78,  99,  79, 113,  59,  80, 170, 168,  80,  79,
    123,                               102,  80, 103, 128,  80,  81, 114, 115,  79,  59, 171, 104, 345, 169,  80,  79, 116, 138,  64, 117, 344,  80,
    80,                                124, 125,  60,  73,  73, 126,  80, 127,  65,  81, 132, 132, 181, 130, 131, 343, 131, 174,  60, 182, 133, 134,
    136,                               134, 136, 175,  80, 137, 137,  80, 130, 131,  77, 194,  78,  78, 131, 133, 134, 176, 165, 177, 342, 134,  79,
    341,                                80, 135, 195, 135, 135, 166, 135,  77,  80,  82,  82, 184, 340, 184, 339,  79, 185, 185, 338,  79, 143, 135,
    80,                                135, 337,  80, 144, 137, 137, 135, 145, 135, 146, 336, 147, 148,  79, 191, 149, 335, 191, 334,  80, 132, 132,
    333,                               188, 332, 188, 331,  80, 189, 189, 186, 187, 199, 187, 191, 207, 208, 200, 137, 137, 185, 185, 191, 330, 185,
    185,                               329, 186, 187, 190, 328, 190, 327, 187, 236, 131, 236, 131, 326, 237, 237, 189, 189, 189, 189, 191, 190, 325,
    191,                               237, 237, 190, 131, 324, 134, 323, 134, 131, 322, 237, 237, 321, 320, 319, 318, 191, 317, 316, 315, 314, 187,
    134,                               187, 191, 313, 312, 134, 311, 310, 309, 308, 307, 306, 305, 304, 303, 302, 187, 301, 300, 299, 298, 187,  58,
    58,                                 58,  58,  64, 297,  64,  64,  88,  88, 296, 295, 294, 293, 292, 291, 290, 289, 288, 287, 286, 285, 284, 283,
    282,                               281, 280, 279, 278, 277, 276, 275, 274, 273, 272, 271, 270, 269, 268, 267, 266, 265, 264, 263, 262, 261, 260,
    259,                               258, 257, 256, 255, 254, 253, 252, 251, 250, 249, 248, 247, 246, 245, 244, 243, 242, 241, 240, 239, 238, 235,
    234,                               233, 232, 231, 230, 229, 228, 227, 226, 225, 224, 223, 222, 221, 220, 219, 218, 217, 216, 215, 214, 213, 212,
    211,                               210, 209, 206, 205, 204, 203, 202, 201, 198, 197, 196, 193, 192, 183, 180, 179, 178, 173, 172, 167, 164, 163,
    162,                               161, 160, 159, 158, 157, 156, 155, 154, 153, 152, 151, 150, 142,  65, 141, 140, 139, 129, 345, 121, 120, 119,
    118,                               111, 110, 107,  96,  95,  94,  93,  92,  89,  85,  66,  65,  61,  57, 345,  56,   3, 345, 345, 345, 345, 345,
    345,                               345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345,
    345,                               345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345,
    345,                               345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345
};

static const short int yy_chk[546] =
{
    0,                                   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
    1,                                   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
    1,                                   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
    8,                                  10,  15,  53,  18,  17,  18,  18,  24,  24,  19,  39,  15,  17,  17,  19,  10,  26,  26,  30,  39,  19,  41,
    30,                                 38,  41,  21,  43,  21,  21,  46,  38,   8,  20,  43,  20,  20,  38,  21,  46,  58,  21, 116, 115,  21,  20,
    53,                                 40,  20,  40,  64,  20,  20,  47,  47,  21,  90, 116,  40,  65, 115,  21,  20,  47, 349,  65,  47, 342,  20,
    21,                                 56,  56,  58,  73,  73,  56,  20,  56,  64,  20,  77,  77, 126,  73,  73, 341,  73, 119,  90, 126,  77,  77,
    79,                                 77,  79, 119,  80,  79,  79,  80,  73,  73,  78, 143,  78,  78,  73,  77,  77, 120, 113, 120, 340,  77,  78,
    337,                                80,  78, 143, 135,  78, 113, 135,  82,  80,  82,  82, 130, 336, 130, 335,  78, 130, 130, 333,  82,  94,  78,
    82,                                135, 332,  82,  94, 136, 136,  78,  94, 135,  94, 326,  94,  94,  82, 138,  94, 325, 138, 323,  82, 132, 132,
    321,                               133, 320, 133, 318,  82, 133, 133, 132, 132, 147, 132, 138, 154, 154, 147, 137, 137, 184, 184, 138, 316, 185,
    185,                               315, 132, 132, 137, 313, 137, 311, 132, 186, 185, 186, 185, 310, 186, 186, 188, 188, 189, 189, 191, 137, 309,
    191,                               236, 236, 137, 185, 308, 189, 307, 189, 185, 306, 237, 237, 305, 304, 303, 301, 191, 298, 297, 296, 295, 237,
    189,                               237, 191, 288, 285, 189, 284, 283, 282, 281, 280, 279, 278, 277, 276, 275, 237, 272, 271, 270, 269, 237, 346,
    346,                               346, 346, 347, 267, 347, 347, 348, 348, 266, 264, 263, 262, 261, 260, 259, 257, 256, 254, 253, 252, 251, 248,
    247,                               246, 245, 244, 243, 242, 241, 240, 239, 235, 234, 233, 232, 231, 230, 229, 227, 226, 225, 224, 223, 222, 221,
    220,                               219, 218, 217, 214, 213, 210, 209, 208, 207, 204, 202, 201, 200, 199, 198, 197, 196, 195, 194, 193, 192, 183,
    182,                               181, 180, 179, 178, 177, 176, 175, 174, 173, 172, 171, 170, 169, 168, 167, 166, 165, 164, 162, 160, 159, 158,
    157,                               156, 155, 153, 152, 151, 150, 149, 148, 146, 145, 144, 142, 141, 127, 125, 124, 121, 118, 117, 114, 110, 109,
    107,                               106, 105, 104, 103, 102, 101, 100,  99,  98,  97,  96,  95,  92,  91,  89,  87,  83,  72,  60,  51,  50,  49,
    48,                                 45,  44,  42,  37,  36,  35,  34,  31,  28,  25,  14,  11,   9,   7,   3,   2, 345, 345, 345, 345, 345, 345,
    345,                               345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345,
    345,                               345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345,
    345,                               345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345, 345
};

static yy_state_type yy_last_accepting_state;
static YY_CHAR       *yy_last_accepting_cpos;

#if YY_AnsiCScanner_DEBUG != 0
static const short int yy_rule_linenum[111] =
{
    0,                                  58,  59,  60,  61,  62,  63,  65,  66,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  78,  79,  80,  81,
    82,                                 83,  84,  85,  86,  87,  88,  89,  90,  91,  92,  93,  94,  95,  96,  97,  98,  99, 100, 101, 102, 103, 104,
    105,                               106, 107, 108, 109, 110, 111, 112, 114, 116, 117, 118, 119, 121, 122, 123, 125, 127, 128, 129, 130, 131, 132,
    133,                               134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155,
    156,                               157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175
};

#endif
#define YY_MORE_ADJ    0

#define yy_get_previous_state()    ((yy_state_type)(yy_get_previous_state_()))
#define yy_try_NUL_trans(c)        ((yy_state_type)(yy_try_NUL_trans_(c)))

YY_AnsiCScanner_LEX_RETURN YY_AnsiCScanner_CLASS::YY_AnsiCScanner_LEX(yy_AnsiCParser_stype& yylval)
{
    yy_state_type        yy_current_state;
    YY_AnsiCScanner_CHAR *yy_cp, *yy_bp;
    int yy_act;

    /* % user's declarations go here */

    /* % end of prolog */
    if (yy_init) {
        {
            YY_USER_INIT;
        }

        if (!yy_start) {
            yy_start = 1; /* first start state */
        }

        if (!yy___in) {
            yy___in = YY_AnsiCScanner_IFILE_DEFAULT;
        }

        if (!yy___out) {
            yy___out = YY_AnsiCScanner_OFILE_DEFAULT;
        }

        if (YY_AnsiCScanner_CURRENT_BUFFER) {
            YY_AnsiCScanner_INIT_BUFFER(YY_AnsiCScanner_CURRENT_BUFFER, yy___in);
        }
        else {
            YY_AnsiCScanner_CURRENT_BUFFER = YY_AnsiCScanner_CREATE_BUFFER(yy___in, YY_BUF_SIZE);
        }

        YY_AnsiCScanner_LOAD_BUFFER_STATE();
        yy_init = 0;
    }

    while (1) { /* loops until end-of-file is reached */
        /* % yymore()-related code goes here */

        yy_cp = yy_c_buf_p;

        /* support of yy___text */
        *yy_cp = yy_hold_char;

        /* yy_bp points to the position in yy_ch_buf of the start of the
         * current run.
         */
        yy_bp = yy_cp;

        /* % code to set up and find next match goes here */
        yy_current_state = yy_start;

        if (yy_bp[-1] == '\n') {
            ++yy_current_state;
        }

yy_match:

        do {
            YY_CHAR yy_c = yy_ec[(unsigned char)*yy_cp];

            if (yy_accept[yy_current_state]) {
                yy_last_accepting_state = yy_current_state;
                yy_last_accepting_cpos  = yy_cp;
            }

            while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state) {
                yy_current_state = yy_def[yy_current_state];

                if (yy_current_state >= 346) {
                    yy_c = yy_meta[(unsigned char)yy_c];
                }
            }

            yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
            ++yy_cp;
        } while (yy_current_state != 345);

        yy_cp            = yy_last_accepting_cpos;
        yy_current_state = yy_last_accepting_state;

yy_find_action:
        /* % code to find the action number goes here */
        yy_act = yy_accept[yy_current_state];

        yy___text = yy_bp;
        /* % code to fiddle yy___text and yy___leng for yymore() goes here */
        yy___leng    = yy_cp - yy_bp;
        yy_hold_char = *yy_cp;
        *yy_cp       = '\0';
        yy_c_buf_p   = yy_cp;

        YY_USER_ACTION;

do_action:     /* this label is used only to access EOF actions */
#if YY_AnsiCScanner_DEBUG != 0
        if (yy___flex_debug) {
            if (yy_act == 0) {
                yy___stderr << "--scanner backtracking" << endl;
            }
            else if (yy_act < YY_END_OF_BUFFER - 1) {
                yy___stderr << "--accepting rule at line " << (int)yy_rule_linenum[yy_act] << " (\""
                            << (char *)yy___text << "\")" << endl;
            }
            else if (yy_act == YY_END_OF_BUFFER - 1) {
                yy___stderr << "--accepting default rule"
                            << " (\"" << (char *)yy___text << "\")" << endl;
            }
            else if (yy_act == YY_END_OF_BUFFER) {
                yy___stderr << "--(end of buffer or a NUL)" << endl;
            }
            else {
                yy___stderr << "--EOF" << endl;
            }
        }
#endif

        switch (yy_act)
        {
        /* % actions go here */
        case 0: /* must backtrack */
            /* undo the effects of YY_DO_BEFORE_ACTION */
            *yy_cp           = yy_hold_char;
            yy_cp            = yy_last_accepting_cpos;
            yy_current_state = yy_last_accepting_state;
            goto yy_find_action;

        case 1:
            {
                count();
                return AnsiCParser::PREINCLUDE;
            }

            YY_BREAK
        case 2:
            {
                count();
                return AnsiCParser::PREDEFINE;
            }

            YY_BREAK
        case 3:
            {
                count();
                return AnsiCParser::PREIF;
            }

            YY_BREAK
        case 4:
            {
                count();
                return AnsiCParser::PREIFDEF;
            }

            YY_BREAK
        case 5:
            {
                count();
                return AnsiCParser::PREENDIF;
            }

            YY_BREAK
        case 6:
            {
                count();
                return AnsiCParser::PRELINE;
            }

            YY_BREAK
        case 7:
            {
                comment();
            }

            YY_BREAK
        case 8:
            {
                commentEOL();
            }

            YY_BREAK
        case 9:
            {
                count();
                return AnsiCParser::AUTO;
            }

            YY_BREAK
        case 10:
            {
                count();
                return AnsiCParser::BREAK;
            }

            YY_BREAK
        case 11:
            {
                count();
                return AnsiCParser::CASE;
            }

            YY_BREAK
        case 12:
            {
                count();
                return AnsiCParser::CHAR;
            }

            YY_BREAK
        case 13:
            {
                count();
                return AnsiCParser::CONST;
            }

            YY_BREAK
        case 14:
            {
                count();
                return AnsiCParser::CONTINUE;
            }

            YY_BREAK
        case 15:
            {
                count();
                return AnsiCParser::DEFAULT;
            }

            YY_BREAK
        case 16:
            {
                count();
                return AnsiCParser::DO;
            }

            YY_BREAK
        case 17:
            {
                count();
                return AnsiCParser::DOUBLE;
            }

            YY_BREAK
        case 18:
            {
                count();
                return AnsiCParser::ELSE;
            }

            YY_BREAK
        case 19:
            {
                count();
                return AnsiCParser::ENUM;
            }

            YY_BREAK
        case 20:
            {
                count();
                return AnsiCParser::EXTERN;
            }

            YY_BREAK
        case 21:
            {
                count();
                return AnsiCParser::FLOAT;
            }

            YY_BREAK
        case 22:
            {
                count();
                return AnsiCParser::FOR;
            }

            YY_BREAK
        case 23:
            {
                count();
                return AnsiCParser::GOTO;
            }

            YY_BREAK
        case 24:
            {
                count();
                return AnsiCParser::IF;
            }

            YY_BREAK
        case 25:
            {
                count();
                return AnsiCParser::INT;
            }

            YY_BREAK
        case 26:
            {
                count();
                return AnsiCParser::LONG;
            }

            YY_BREAK
        case 27:
            {
                count();
                return AnsiCParser::REGISTER;
            }

            YY_BREAK
        case 28:
            {
                count();
                return AnsiCParser::RETURN;
            }

            YY_BREAK
        case 29:
            {
                count();
                return AnsiCParser::SHORT;
            }

            YY_BREAK
        case 30:
            {
                count();
                return AnsiCParser::SIGNED;
            }

            YY_BREAK
        case 31:
            {
                count();
                return AnsiCParser::SIZEOF;
            }

            YY_BREAK
        case 32:
            {
                count();
                return AnsiCParser::NODECODE;
            }

            YY_BREAK
        case 33:
            {
                count();
                return AnsiCParser::INCOMPLETE;
            }

            YY_BREAK
        case 34:
            {
                count();
                return AnsiCParser::CDECL;
            }

            YY_BREAK
        case 35:
            {
                count();
                return AnsiCParser::PASCAL;
            }

            YY_BREAK
        case 36:
            {
                count();
                return AnsiCParser::PASCAL;
            }

            YY_BREAK
        case 37:
            {
                count();
                return AnsiCParser::CUSTOM;
            }

            YY_BREAK
        case 38:
            {
                count();
                return AnsiCParser::THISCALL;
            }

            YY_BREAK
        case 39:
            {
                count();
                return AnsiCParser::PREFER;
            }

            YY_BREAK
        case 40:
            {
                count();
                return AnsiCParser::WITHSTACK;
            }

            YY_BREAK
        case 41:
            {
                count();
                return AnsiCParser::SYMBOLREF;
            }

            YY_BREAK
        case 42:
            {
                count();
                return AnsiCParser::STATIC;
            }

            YY_BREAK
        case 43:
            {
                count();
                return AnsiCParser::STRUCT;
            }

            YY_BREAK
        case 44:
            {
                count();
                return AnsiCParser::SWITCH;
            }

            YY_BREAK
        case 45:
            {
                count();
                return AnsiCParser::TYPEDEF;
            }

            YY_BREAK
        case 46:
            {
                count();
                return AnsiCParser::UNION;
            }

            YY_BREAK
        case 47:
            {
                count();
                return AnsiCParser::UNSIGNED;
            }

            YY_BREAK
        case 48:
            {
                count();
                return AnsiCParser::VOID;
            }

            YY_BREAK
        case 49:
            {
                count();
                return AnsiCParser::VOLATILE;
            }

            YY_BREAK
        case 50:
            {
                count();
                return AnsiCParser::WHILE;
            }

            YY_BREAK
        case 51:
            {
                count();
                return AnsiCParser::REGOF;
            }

            YY_BREAK
        case 52:
            {
                count();
                return AnsiCParser::MEMOF;
            }

            YY_BREAK
        case 53:
            {
                count();
                return AnsiCParser::MAXBOUND;
            }

            YY_BREAK
        case 54:
            {
                count();
                yylval.str = yytext;
                return check_type();
            }

            YY_BREAK
        case 55:
            {
                count();
                sscanf(yytext, "0x%x", (uint32_t *)&yylval.ival);
                return AnsiCParser::CONSTANT;
            }

            YY_BREAK
        case 56:
            {
                count();
                return AnsiCParser::CONSTANT;
            }

            YY_BREAK
        case 57:
            {
                count();
                sscanf(yytext, "%d", &yylval.ival);
                return AnsiCParser::CONSTANT;
            }

            YY_BREAK
        case 58:
            {
                count();
                return AnsiCParser::CONSTANT;
            }

            YY_BREAK
        case 59:
            {
                count();
                return AnsiCParser::CONSTANT;
            }

            YY_BREAK
        case 60:
            {
                count();
                return AnsiCParser::CONSTANT;
            }

            YY_BREAK
        case 61:
            {
                count();
                return AnsiCParser::CONSTANT;
            }

            YY_BREAK
        case 62:
            {
                count();
                yylval.str = yytext;
                return AnsiCParser::STRING_LITERAL;
            }

            YY_BREAK
        case 63:
            {
                count();
                return AnsiCParser::ELLIPSIS;
            }

            YY_BREAK
        case 64:
            {
                count();
                return AnsiCParser::RIGHT_ASSIGN;
            }

            YY_BREAK
        case 65:
            {
                count();
                return AnsiCParser::LEFT_ASSIGN;
            }

            YY_BREAK
        case 66:
            {
                count();
                return AnsiCParser::ADD_ASSIGN;
            }

            YY_BREAK
        case 67:
            {
                count();
                return AnsiCParser::SUB_ASSIGN;
            }

            YY_BREAK
        case 68:
            {
                count();
                return AnsiCParser::MUL_ASSIGN;
            }

            YY_BREAK
        case 69:
            {
                count();
                return AnsiCParser::DIV_ASSIGN;
            }

            YY_BREAK
        case 70:
            {
                count();
                return AnsiCParser::MOD_ASSIGN;
            }

            YY_BREAK
        case 71:
            {
                count();
                return AnsiCParser::AND_ASSIGN;
            }

            YY_BREAK
        case 72:
            {
                count();
                return AnsiCParser::XOR_ASSIGN;
            }

            YY_BREAK
        case 73:
            {
                count();
                return AnsiCParser::OR_ASSIGN;
            }

            YY_BREAK
        case 74:
            {
                count();
                return AnsiCParser::RIGHT_OP;
            }

            YY_BREAK
        case 75:
            {
                count();
                return AnsiCParser::LEFT_OP;
            }

            YY_BREAK
        case 76:
            {
                count();
                return AnsiCParser::INC_OP;
            }

            YY_BREAK
        case 77:
            {
                count();
                return AnsiCParser::DEC_OP;
            }

            YY_BREAK
        case 78:
            {
                count();
                return AnsiCParser::PTR_OP;
            }

            YY_BREAK
        case 79:
            {
                count();
                return AnsiCParser::AND_OP;
            }

            YY_BREAK
        case 80:
            {
                count();
                return AnsiCParser::OR_OP;
            }

            YY_BREAK
        case 81:
            {
                count();
                return AnsiCParser::LE_OP;
            }

            YY_BREAK
        case 82:
            {
                count();
                return AnsiCParser::GE_OP;
            }

            YY_BREAK
        case 83:
            {
                count();
                return AnsiCParser::EQ_OP;
            }

            YY_BREAK
        case 84:
            {
                count();
                return AnsiCParser::NE_OP;
            }

            YY_BREAK
        case 85:
            {
                count();
                return ';';
            }

            YY_BREAK
        case 86:
            {
                count();
                return '{';
            }

            YY_BREAK
        case 87:
            {
                count();
                return '}';
            }

            YY_BREAK
        case 88:
            {
                count();
                return ',';
            }

            YY_BREAK
        case 89:
            {
                count();
                return ':';
            }

            YY_BREAK
        case 90:
            {
                count();
                return '=';
            }

            YY_BREAK
        case 91:
            {
                count();
                return '(';
            }

            YY_BREAK
        case 92:
            {
                count();
                return ')';
            }

            YY_BREAK
        case 93:
            {
                count();
                return '[';
            }

            YY_BREAK
        case 94:
            {
                count();
                return ']';
            }

            YY_BREAK
        case 95:
            {
                count();
                return '.';
            }

            YY_BREAK
        case 96:
            {
                count();
                return '&';
            }

            YY_BREAK
        case 97:
            {
                count();
                return '!';
            }

            YY_BREAK
        case 98:
            {
                count();
                return '~';
            }

            YY_BREAK
        case 99:
            {
                count();
                return '-';
            }

            YY_BREAK
        case 100:
            {
                count();
                return '+';
            }

            YY_BREAK
        case 101:
            {
                count();
                return '*';
            }

            YY_BREAK
        case 102:
            {
                count();
                return '/';
            }

            YY_BREAK
        case 103:
            {
                count();
                return '%';
            }

            YY_BREAK
        case 104:
            {
                count();
                return '<';
            }

            YY_BREAK
        case 105:
            {
                count();
                return '>';
            }

            YY_BREAK
        case 106:
            {
                count();
                return '^';
            }

            YY_BREAK
        case 107:
            {
                count();
                return '|';
            }

            YY_BREAK
        case 108:
            {
                count();
                return '?';
            }

            YY_BREAK
        case 109:
            {
                count();
            }

            YY_BREAK
        case 110:
            {       /* ignore bad characters */
            }

            YY_BREAK
        case 111:

            ECHO;

            YY_BREAK
        case YY_STATE_EOF(INITIAL):
            yyterminate();

        case YY_END_OF_BUFFER:
            {
                /* amount of text matched not including the EOB char */
                int yy_amount_of_matched_text = yy_cp - yy___text - 1;

                /* undo the effects of YY_DO_BEFORE_ACTION */
                *yy_cp = yy_hold_char;

                /* note that here we test for yy_c_buf_p "<=" to the position
                 * of the first EOB in the buffer, since yy_c_buf_p will
                 * already have been incremented past the NUL character
                 * (since all states make transitions on EOB to the end-
                 * of-buffer state).  Contrast this with the test in yyinput().
                 */
                if (yy_c_buf_p <= &YY_AnsiCScanner_CURRENT_BUFFER->yy_ch_buf[yy_n_chars]) {
                    /* this was really a NUL */
                    yy_state_type yy_next_state;

                    yy_c_buf_p = yy___text + yy_amount_of_matched_text;

                    yy_current_state = yy_get_previous_state();

                    /* okay, we're now positioned to make the
                     * NUL transition.  We couldn't have
                     * yy_get_previous_state() go ahead and do it
                     * for us because it doesn't know how to deal
                     * with the possibility of jamming (and we
                     * don't want to build jamming into it because
                     * then it will run more slowly)
                     */

                    yy_next_state = yy_try_NUL_trans(yy_current_state);

                    yy_bp = yy___text + YY_MORE_ADJ;

                    if (yy_next_state) {
                        /* consume the NUL */
                        yy_cp            = ++yy_c_buf_p;
                        yy_current_state = yy_next_state;
                        goto yy_match;
                    }
                    else {
                        /* % code to do backtracking for compressed tables and set up yy_cp goes here */
                        yy_cp            = yy_last_accepting_cpos;
                        yy_current_state = yy_last_accepting_state;

                        goto yy_find_action;
                    }
                }
                else {
                    switch (yy_get_next_buffer())
                    {
                    case EOB_ACT_END_OF_FILE:
                        {
                            yy_did_buffer_switch_on_eof = 0;

                            if (yywrap()) {
                                /* note: because we've taken care in
                                 * yy_get_next_buffer() to have set up yy___text,
                                 * we can now set up yy_c_buf_p so that if some
                                 * total hoser (like flex itself) wants
                                 * to call the scanner after we return the
                                 * YY_NULL, it'll still work - another YY_NULL
                                 * will get returned.
                                 */
                                yy_c_buf_p = yy___text + YY_MORE_ADJ;

                                yy_act = YY_STATE_EOF((yy_start - 1) / 2);
                                goto do_action;
                            }
                            else {
                                if (!yy_did_buffer_switch_on_eof) {
                                    yy___newfile;
                                }
                            }
                        }
                        break;

                    case EOB_ACT_CONTINUE_SCAN:
                        yy_c_buf_p = yy___text + yy_amount_of_matched_text;

                        yy_current_state = yy_get_previous_state();

                        yy_cp = yy_c_buf_p;
                        yy_bp = yy___text + YY_MORE_ADJ;
                        goto yy_match;

                    case EOB_ACT_LAST_MATCH:
                        yy_c_buf_p = &YY_AnsiCScanner_CURRENT_BUFFER->yy_ch_buf[yy_n_chars];

                        yy_current_state = yy_get_previous_state();

                        yy_cp = yy_c_buf_p;
                        yy_bp = yy___text + YY_MORE_ADJ;
                        goto yy_find_action;
                    }
                }

                break;
            }

        default:
#if YY_AnsiCScanner_DEBUG != 0
            yy___stderr << "action # " << (int)yy_act << endl;
#endif
            YY_FATAL_ERROR("fatal flex scanner internal error--no action found");
        }
    }

    yyterminate(); /* avoid the no return value error message on MS-C7/dos */
}


/* yy_get_next_buffer - try to read in a new buffer
 *
 * synopsis
 *     int yy_get_next_buffer();
 *
 * returns a code representing an action
 *     EOB_ACT_LAST_MATCH -
 *     EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *     EOB_ACT_END_OF_FILE - end of file
 */
int YY_AnsiCScanner_CLASS::yy_get_next_buffer()
{
    YY_AnsiCScanner_CHAR *dest = YY_AnsiCScanner_CURRENT_BUFFER->yy_ch_buf;
    YY_AnsiCScanner_CHAR *source = yy___text - 1; /* copy prev. char, too */
    int number_to_move, i;
    int ret_val;

    if (yy_c_buf_p > &YY_AnsiCScanner_CURRENT_BUFFER->yy_ch_buf[yy_n_chars + 1]) {
        YY_FATAL_ERROR("fatal flex scanner internal error--end of buffer missed");
    }

    /* try to read more data */

    /* first move last chars to start of buffer */
    number_to_move = yy_c_buf_p - yy___text;

    for (i = 0; i < number_to_move; ++i) {
        *(dest++) = *(source++);
    }

    if (YY_AnsiCScanner_CURRENT_BUFFER->yy_eof_status != EOF_NOT_SEEN) {
        /* don't do the read, it's not guaranteed to return an EOF,
         * just force an EOF
         */
        yy_n_chars = 0;
    }

    else {
        int num_to_read = YY_AnsiCScanner_CURRENT_BUFFER->yy_buf_size - number_to_move - 1;

        if (num_to_read > YY_READ_BUF_SIZE) {
            num_to_read = YY_READ_BUF_SIZE;
        }

        else if (num_to_read <= 0) {
            YY_FATAL_ERROR("fatal error - scanner input buffer overflow");
        }

        /* read in more data */
        YY_INPUT((&YY_AnsiCScanner_CURRENT_BUFFER->yy_ch_buf[number_to_move]), yy_n_chars, num_to_read);
    }

    if (yy_n_chars == 0) {
        if (number_to_move - YY_MORE_ADJ == 1) {
            ret_val = EOB_ACT_END_OF_FILE;
            YY_AnsiCScanner_CURRENT_BUFFER->yy_eof_status = EOF_DONE;
        }
        else {
            ret_val = EOB_ACT_LAST_MATCH;
            YY_AnsiCScanner_CURRENT_BUFFER->yy_eof_status = EOF_PENDING;
        }
    }
    else {
        ret_val = EOB_ACT_CONTINUE_SCAN;
    }

    yy_n_chars += number_to_move;
    YY_AnsiCScanner_CURRENT_BUFFER->yy_ch_buf[yy_n_chars]     = YY_END_OF_BUFFER_CHAR;
    YY_AnsiCScanner_CURRENT_BUFFER->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;

    /* yy___text begins at the second character in yy_ch_buf; the first
     * character is the one which preceded it before reading in the latest
     * buffer; it needs to be kept around in case it's a newline, so
     * yy_get_previous_state() will have with '^' rules active
     */

    yy___text = &YY_AnsiCScanner_CURRENT_BUFFER->yy_ch_buf[1];

    return(ret_val);
}


/* yy_get_previous_state - get the state just before the EOB char was reached
 *
 * synopsis
 *     yy_state_type yy_get_previous_state();
 */
long YY_AnsiCScanner_CLASS::yy_get_previous_state_()
{
    yy_state_type        yy_current_state;
    YY_AnsiCScanner_CHAR *yy_cp;

    /* % code to get the start state into yy_current_state goes here */
    YY_CHAR *yy_bp = yy___text;

    yy_current_state = yy_start;

    if (yy_bp[-1] == '\n') {
        ++yy_current_state;
    }

    for (yy_cp = yy___text + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp) {
        /* % code to find the next state goes here */
        YY_CHAR yy_c = (*yy_cp ? yy_ec[(unsigned char)*yy_cp] : 1);

        if (yy_accept[yy_current_state]) {
            yy_last_accepting_state = yy_current_state;
            yy_last_accepting_cpos  = yy_cp;
        }

        while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state) {
            yy_current_state = yy_def[yy_current_state];

            if (yy_current_state >= 346) {
                yy_c = yy_meta[(unsigned char)yy_c];
            }
        }

        yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
    }

    return (long)(yy_current_state);
}


/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *     next_state = yy_try_NUL_trans( current_state );
 */
long YY_AnsiCScanner_CLASS::yy_try_NUL_trans_(long yy_current_state_)
{
    yy_state_type yy_current_state = (yy_state_type)yy_current_state_;
    int           yy_is_jam;
    /* % code to find the next state, and perhaps do backtracking, goes here */
    YY_CHAR *yy_cp = yy_c_buf_p;

    YY_CHAR yy_c = 1;

    if (yy_accept[yy_current_state]) {
        yy_last_accepting_state = yy_current_state;
        yy_last_accepting_cpos  = yy_cp;
    }

    while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state) {
        yy_current_state = yy_def[yy_current_state];

        if (yy_current_state >= 346) {
            yy_c = yy_meta[(unsigned char)yy_c];
        }
    }

    yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
    yy_is_jam        = (yy_current_state == 345);
    return (long)(yy_is_jam ? 0 : yy_current_state);
}


void YY_AnsiCScanner_CLASS::yyunput(YY_AnsiCScanner_CHAR c, YY_AnsiCScanner_CHAR *yy_bp)
{
    YY_AnsiCScanner_CHAR *yy_cp = yy_c_buf_p;

    /* undo effects of setting up yy___text */
    *yy_cp = yy_hold_char;

    if (yy_cp < YY_AnsiCScanner_CURRENT_BUFFER->yy_ch_buf + 2) { /* need to shift things up to make room */
        int number_to_move         = yy_n_chars + 2;             /* +2 for EOB chars */
        YY_AnsiCScanner_CHAR *dest =
            &YY_AnsiCScanner_CURRENT_BUFFER->yy_ch_buf[YY_AnsiCScanner_CURRENT_BUFFER->yy_buf_size + 2];
        YY_AnsiCScanner_CHAR *source = &YY_AnsiCScanner_CURRENT_BUFFER->yy_ch_buf[number_to_move];

        while (source > YY_AnsiCScanner_CURRENT_BUFFER->yy_ch_buf) {
            *--dest = *--source;
        }

        yy_cp     += dest - source;
        yy_bp     += dest - source;
        yy_n_chars = YY_AnsiCScanner_CURRENT_BUFFER->yy_buf_size;

        if (yy_cp < YY_AnsiCScanner_CURRENT_BUFFER->yy_ch_buf + 2) {
            YY_FATAL_ERROR("flex scanner push-back overflow");
        }
    }

    if ((yy_cp > yy_bp) && (yy_cp[-1] == '\n')) {
        yy_cp[-2] = '\n';
    }

    *--yy_cp = c;

    /* note: the formal parameter *must* be called "yy_bp" for this
     *       macro to now work correctly
     */
    yy___text = yy_bp;
    /* % code to fiddle yy___text and yy___leng for yymore() goes here */
    yy___leng    = yy_cp - yy_bp;
    yy_hold_char = *yy_cp;
    *yy_cp       = '\0';
    yy_c_buf_p   = yy_cp;
}


int YY_AnsiCScanner_CLASS::input()
{
    int c;
    YY_AnsiCScanner_CHAR *yy_cp = yy_c_buf_p;

    *yy_cp = yy_hold_char;

    if (*yy_c_buf_p == YY_END_OF_BUFFER_CHAR) {
        /* yy_c_buf_p now points to the character we want to return.
         * If this occurs *before* the EOB characters, then it's a
         * valid NUL; if not, then we've hit the end of the buffer.
         */
        if (yy_c_buf_p < &YY_AnsiCScanner_CURRENT_BUFFER->yy_ch_buf[yy_n_chars]) {
            /* this was really a NUL */
            *yy_c_buf_p = '\0';
        }

        else { /* need more input */
            yy___text = yy_c_buf_p;
            ++yy_c_buf_p;

            switch (yy_get_next_buffer())
            {
            case EOB_ACT_END_OF_FILE:
                {
                    if (yywrap()) {
                        yy_c_buf_p = yy___text + YY_MORE_ADJ;
                        return(EOF);
                    }

                    yy___newfile;
                    return(input());
                }

            case EOB_ACT_CONTINUE_SCAN:
                yy_c_buf_p = yy___text + YY_MORE_ADJ;
                break;

            case EOB_ACT_LAST_MATCH:
                YY_FATAL_ERROR("unexpected last match in YY_AnsiCScanner_CLASS::input()");
            }
        }
    }

    c            = *yy_c_buf_p;
    yy_hold_char = *++yy_c_buf_p;

    return(c);
}


void YY_AnsiCScanner_CLASS::YY_AnsiCScanner_RESTART(YY_AnsiCScanner_IFILE *input_file)
{
    YY_AnsiCScanner_INIT_BUFFER(YY_AnsiCScanner_CURRENT_BUFFER, input_file);
    YY_AnsiCScanner_LOAD_BUFFER_STATE();
}


void YY_AnsiCScanner_CLASS::YY_AnsiCScanner_SWITCH_TO_BUFFER(YY_BUFFER_STATE new_buffer)
{
    if (YY_AnsiCScanner_CURRENT_BUFFER == new_buffer) {
        return;
    }

    if (YY_AnsiCScanner_CURRENT_BUFFER) {
        /* flush out information for old buffer */
        *yy_c_buf_p = yy_hold_char;
        YY_AnsiCScanner_CURRENT_BUFFER->yy_buf_pos = yy_c_buf_p;
        YY_AnsiCScanner_CURRENT_BUFFER->yy_n_chars = yy_n_chars;
    }

    YY_AnsiCScanner_CURRENT_BUFFER = new_buffer;
    YY_AnsiCScanner_LOAD_BUFFER_STATE();

    /* we don't actually know whether we did this switch during
     * EOF (yywrap()) processing, but the only time this flag
     * is looked at is after yywrap() is called, so it's safe
     * to go ahead and always set it.
     */
    yy_did_buffer_switch_on_eof = 1;
}


void YY_AnsiCScanner_CLASS::YY_AnsiCScanner_LOAD_BUFFER_STATE()
{
    yy_n_chars   = YY_AnsiCScanner_CURRENT_BUFFER->yy_n_chars;
    yy___text    = yy_c_buf_p = YY_AnsiCScanner_CURRENT_BUFFER->yy_buf_pos;
    yy___in      = YY_AnsiCScanner_CURRENT_BUFFER->yy_input_file;
    yy_hold_char = *yy_c_buf_p;
}


YY_BUFFER_STATE YY_AnsiCScanner_CLASS::YY_AnsiCScanner_CREATE_BUFFER(YY_AnsiCScanner_IFILE *file, int size)
{
    YY_BUFFER_STATE b;

    b = (YY_BUFFER_STATE)malloc(sizeof(struct yy_buffer_state));

    if (!b) {
        YY_FATAL_ERROR("out of dynamic memory in YY_AnsiCScanner_CREATE_BUFFER()");
    }

    b->yy_buf_size = size;

    /* yy_ch_buf has to be 2 characters longer than the size given because
     * we need to put in 2 end-of-buffer characters.
     */
    b->yy_ch_buf = (YY_AnsiCScanner_CHAR *)malloc((unsigned)(b->yy_buf_size + 2));

    if (!b->yy_ch_buf) {
        YY_FATAL_ERROR("out of dynamic memory in YY_AnsiCScanner_CREATE_BUFFER()");
    }

    YY_AnsiCScanner_INIT_BUFFER(b, file);

    return(b);
}


void YY_AnsiCScanner_CLASS::YY_AnsiCScanner_DELETE_BUFFER(YY_BUFFER_STATE b)
{
    if (b == YY_AnsiCScanner_CURRENT_BUFFER) {
        YY_AnsiCScanner_CURRENT_BUFFER = (YY_BUFFER_STATE)nullptr;
    }

    free((char *)b->yy_ch_buf);
    free((char *)b);
}


void YY_AnsiCScanner_CLASS::YY_AnsiCScanner_INIT_BUFFER(YY_BUFFER_STATE b, YY_AnsiCScanner_IFILE *file)
{
    b->yy_input_file = file;

    /* we put in the '\n' and start reading from [1] so that an
     * initial match-at-newline will be true.
     */

    b->yy_ch_buf[0] = '\n';
    b->yy_n_chars   = 1;

    /* we always need two end-of-buffer characters.  The first causes
     * a transition to the end-of-buffer state.  The second causes
     * a jam in that state.
     */
    b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
    b->yy_ch_buf[2] = YY_END_OF_BUFFER_CHAR;

    b->yy_buf_pos = &b->yy_ch_buf[1];

    b->yy_eof_status = EOF_NOT_SEEN;
}


void AnsiCScanner::comment()
{
    char c, c1;

loop:

    while ((c = input()) != '*' && c != 0) {
        /*putchar(c)*/
    }

    if (((c1 = input()) != '/') && (c != 0)) {
        goto loop;
    }

    if (c != 0) {
        /*putchar(c1)*/
    }
}


void AnsiCScanner::commentEOL()
{
    char c;

    while ((c = input()) != '\n') {
    }
}


void AnsiCScanner::count()
{
    int i;

    for (i = 0; yytext[i] != '\0'; i++) {
        if (yytext[i] == '\n') {
            column = 0;
        }
        else if (yytext[i] == '\t') {
            column += 8 - (column % 8);
        }
        else {
            column++;
        }
    }

    strcat(lineBuf, yytext);

    if (strchr(lineBuf, '\n')) {
        char buf[MAX_LINE];
        strcpy(buf, lineBuf);
        strcpy(lineBuf, strchr(buf, '\n') + 1);
        theLine++;
    }
}


int AnsiCScanner::check_type()
{
    /*
     * pseudo code --- this is what it should check
     *
     *    if (yytext == type_name)
     *        return AnsiCParser::TYPE_NAME;
     *
     *    return AnsiCParser::IDENTIFIER;
     */

    /*
     *    it actually will only return IDENTIFIER
     */
    return AnsiCParser::IDENTIFIER;
}
