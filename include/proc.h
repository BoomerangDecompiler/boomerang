/*
 * Copyright (C) 1998-2001, The University of Queensland
 * Copyright (C) 2000-2001, Sun Microsystems, Inc
 * Copyright (C) 2002, Trent Waddington
 *
 * See the file "LICENSE.TERMS" for information on usage and
 * redistribution of this file, and for a DISCLAIMER OF ALL
 * WARRANTIES.
 *
 */

/*==============================================================================
 * FILE:       proc.h
 * OVERVIEW:   Interface for the procedure classes, which are used to
 *             store information about variables in the procedure such
 *             as parameters and locals.
 *============================================================================*/

/* $Revision$
 * 20 Sep 01 - Brian: Added getSymbolicLocals() to return the list of symbolic
 *              locals for a procedure.
*/

#ifndef _PROC_H_
#define _PROC_H_

#include <list>
#include <vector>
#include <map>
#include <set>
#include <string>
#include "coverage.h"           // For Coverage class
#include "exp.h"                // For lessExpStar
#include "cfg.h"                // For cfg->simplify()

class Prog;
class UserProc;
class Cfg;
class BasicBlock;
typedef BasicBlock* PBB;
class Exp;
class TypedExp;
class lessTI;
class Type;
class RTL;
class HLLCode;
class HLCall;
class Parameter;
class Argument;
class Signature;

/*==============================================================================
 * Procedure class.
 *============================================================================*/
class Proc {
public:

    /*
     * Constructor with name, native address and optional bLib.
     */
    Proc(Prog *prog, ADDRESS uNative, Signature *sig);

    virtual ~Proc();

    /*
     * Gets name of this procedure.
     */
    const char* getName();

    /*
     * Gets sets the name of this procedure.
     */
    void setName(const char *nam);

    /*
     * Get the native address.
     */
    ADDRESS getNativeAddress();

    /*
     * Set the native address
     */
    void setNativeAddress(ADDRESS a);

    /*
     * Get the program this procedure belongs to.
     */
    Prog *getProg();

    /*
     * Get/Set the first procedure that calls this procedure (or null for main/start).
     */
    Proc *getFirstCaller();
    void setFirstCaller(Proc *p) { if (m_firstCaller == NULL) m_firstCaller = p; }

    /*
     * Returns a pointer to the Signature
     */
    Signature *getSignature();

    /*
     * Prints this procedure to an output stream.
     */
    virtual std::ostream& put(std::ostream& os) = 0;

    /*
     * Return the coverage of this procedure in bytes.
     */
//    virtual unsigned getCoverage() = 0;

    /*
     * Modify actuals so that it is now the list of locations that must
     * be passed to this procedure. The modification will be to either add
     * dummp locations to actuals, delete from actuals, or leave it
     * unchanged.
     * Add "dummy" params: this will be required when there are
     *   less live outs at a call site than the number of parameters
     *   expected by the procedure called. This will be a result of
     *   one of two things:
     *   i) a value returned by a preceeding call is used as a
     *      parameter and as such is not detected as defined by the
     *      procedure. E.g.:
     *
     *         foo(bar(x));
     *
     *      Here, the result of bar(x) is used as the first and only
     *      parameter to foo. On some architectures (such as SPARC),
     *      the location used as the first parameter (e.g. %o0) is
     *      also the location in which a value is returned. So, the
     *      call to bar defines this location implicitly as shown in
     *      the following SPARC assembly that may be generated by from
     *      the above code:
     *
     *          mov   x, %o0
     *          call  bar
     *          nop
     *          call  foo
     *
     *     As can be seen, there is no definition of %o0 after the
     *     call to bar and before the call to foo. Adding the integer
     *     return location is therefore a good guess for the dummy
     *     location to add (but may occasionally be wrong).
     *
     *  ii) uninitialised variables are used as parameters to a call
     *
     *  Note that both of these situations can only occur on
     *  architectures such as SPARC that use registers for parameter
     *  passing. Stack parameters must always be pushed so that the
     *  callee doesn't access the caller's non-parameter portion of
     *  stack.
     *
     * This used to be a virtual function, implemented differenty for
     * LibProcs and for UserProcs. But in fact, both need the exact same
     * treatment; the only difference is how the local member "parameters"
     * is set (from common.hs in the case of LibProc objects, or from analysis
     * in the case of UserProcs).
     */
    void matchParams(std::list<Exp*>& actuals, UserProc& caller);

    /*
     * Get a list of types to cast a given list of actual parameters to
     */
    std::list<Type>* Proc::getParamTypeList(const std::list<Exp*>& actuals);

    /*
     * Set the number of bytes popped off the caller stack by this procedure
     */
    void setBytesPopped(int n);
    int getBytesPopped() { return bytesPopped; }

    /*
     * Return true if this is a library proc
     */
    virtual bool isLib() {return false;}

    /*
     * Return true if the aggregate pointer is used.
     * It is assumed that this is false for library procs
     */
    virtual bool isAggregateUsed() {return false;}

    /*
     * OutPut operator for a Proc object.
     */
    friend std::ostream& operator<<(std::ostream& os, Proc& proc);
    
    /*
     * Stores a list of reg to the procedure used for 
     * type propagation
     */
    std::list<int> regParams;

    // serialize this procedure
    virtual bool serialize(std::ostream &ouf, int &len) = 0;

    // deserialize a procedure
    static Proc *deserialize(Prog *prog, std::istream &inf);
    virtual bool deserialize_fid(std::istream &inf, int fid);

    //virtual void getInternalStatements(StatementList &internal) = 0;

    Exp *getProven(Exp *left);

    /*
     * Get the callers
     */
    std::set<CallStatement*>& getCallers() { return callerSet; }

    /*
     * Add to the set of callers
     */
    void addCaller(CallStatement* caller) { callerSet.insert(caller); }

    void removeReturn(Exp *e);
    void removeParameter(Exp *e);
    void addParameter(Exp *e);

protected:

    /*
     * Program containing this procedure.
     */
    Prog *prog;

    /*
     * Procedure's address.
     */
    ADDRESS address;

    /*
     * The formal signature of this procedure. This information is determined
     * either by the common.hs file (for a library function) or by analysis.
     */
    Signature *signature;

    /*
     * The first procedure to call this procedure
     */
    Proc *m_firstCaller;
    ADDRESS m_firstCallerAddr;  // can only be used once.

    /*
     * Number of bytes this procedure will cause any call to it to pop off
     * the stack (of the caller).
     */
    int bytesPopped;

    // all the expressions that have been proven about this proc
    std::set<Exp*, lessExpStar> proven;

    /*
     * Set of callers (CallStatements that call this procedure).
     */
    std::set<CallStatement*> callerSet;
}; 

/*==============================================================================
 * LibProc class.
 *============================================================================*/
class LibProc : public Proc {
public:
    
    LibProc(Prog *prog, std::string& name, ADDRESS address);
    virtual ~LibProc();

    /*
     * Return the coverage of this procedure in bytes.
     */
    unsigned getCoverage() { return 0; }

#if 0
    /*
     * See comment for Proc::matchParams.
     */
    void matchParams(std::list<Exp*>& actuals, UserProc& caller,
        const Parameters* outgoing, const Exp** intRetLoc) const;
#endif

    /*
     * Return true, since is a library proc
     */
    bool isLib() {return true;}

    /*
     * Return true if the aggregate pointer is used.
     * It is assumed that this is false for library procs
     */
    virtual bool isAggregateUsed() {return false;}

    /*
     * Prints this procedure to an output stream.
     */
    std::ostream& put(std::ostream& os);

    // serialize this procedure
    virtual bool serialize(std::ostream &ouf, int &len);
    // deserialize the subclass specific portion of this procedure
    virtual bool deserialize_fid(std::istream &inf, int fid);

    void getInternalStatements(StatementList &internal);
};

/*==============================================================================
 * UserProc class.
 *============================================================================*/
class UserProc : public Proc {

    /*
     * The control flow graph.
     */
    Cfg* cfg;

    /*
     * True if this procedure has been decoded.
     */
    bool decoded;

    /*
     * Indicate that the procedure has had its variables converted to
     * symbolic form, e.g. r[8]->v2. This is only done once, by a call to
     * propagateSymbolics(). We need to know that this has happened if we
     * later determine a different return location, and it happens not to
     * have been converted to symbolic as yet 
     */
    bool isSymbolic;

    /*
     * Used to generate unique IDs for the parameters and locals to
     * calls that are recovered and given a symbolic name.
     */
    unsigned uniqueID;

    /*
     * Indicate that the aggregate location pointer "hidden" parameter is used,
     * and is thus explicit in this translation. Needed only by architectures
     * like Sparc where a special parent stack location is used to pass the
     * address of aggregates. Set with the setParams() member function
     */
    bool aggregateUsed;

    /*
     * This map records the allocation of local variables and their types.
     */
    std::map<std::string, Type*> locals;

    /*
     * A map between machine dependent locations and their corresponding
     * symbolic, machine independent representations.
     */
    std::map<Exp*,Exp*,lessExpStar> symbolMap;

    /*
     * The return location as written to the .c file. Not valid unless the file
     * has been written (fileWritten true)
     */
    Exp* fileRetLocn;

    /*
     * Set of callees (Procedures that this procedure calls). Used for
     * call graph, among other things
     */
    std::set<Proc*> calleeSet;
    std::set<ADDRESS> calleeAddrSet;  // used in serialization
 
     /*
     * Set if visited on the way down the call tree during decompile()
     * Used for recursion detection
     */
    bool decompileSeen;

    /*
     * Set if decompilation essentially completed (there may be extra return
     * locations set later)
     */
    bool decompiled;

    /*
     * Set if involved in recursion (a cycle in the call graph)
     */
    bool isRecursive;

    /*
     * Set of locations defined in this proc. Some or all or none of these
     * may be return locations (will be if used before definition after the
     * call)
     * Note: there is a different set in each call, because the locations
     * may be different from the caller's perspective (e.g. stack locations)
     */
    LocationSet definesSet;

    /*
     * Set of locations returned by this proc (see above). As calls are found
     * with use-before-def of locations in definesSet, they are transferred
     * to this set.
     */
    LocationSet returnsSet;

public:

    UserProc(Prog *prog, std::string& name, ADDRESS address);
    virtual ~UserProc();

    /*
     * Records that this procedure has been decoded.
     */
    void setDecoded();

    /*
     * Removes the decoded bit and throws away all the current information 
     * about this procedure.
     */
    void unDecode();

    /*
     * Returns a pointer to the CFG.
     */
    Cfg* getCFG();

    /*
     * Deletes the whole CFG and all the RTLs, RTs, and Exp*s associated with
     * it. Also nulls the internal cfg pointer (to prevent strange errors)
     */
    void deleteCFG();

    /*
     * Returns whether or not this procedure can be decoded (i.e. has
     * it already been decoded).
     */
    bool isDecoded();

    /*
     * Return the number of bytes allocated for locals on the stack.
     */
    int getLocalsSize();

    /*
     * Get the type of the given var
     */
//    Type getVarType(int idx);

    /*
     * Set the size of the given var
     */
//    void setVarSize(int idx, int size);

    // serialize this procedure
    virtual bool serialize(std::ostream &ouf, int &len);
    // deserialize the subclass specific portion of this procedure
    virtual bool deserialize_fid(std::istream &inf, int fid);

    // code generation
    void generateCode(HLLCode *hll);

    // print this proc, mainly for debugging
    void print(std::ostream &out, bool withDF = false);

    // simplify the statements in this proc
    void simplify() { cfg->simplify(); }

    // decompile this proc
    std::set<UserProc*>* decompile();

    // All the decompile stuff except propagation, DFA repair, and null/unused
    // statement removal
    void    complete(); 

    // Initialise the statements, e.g. proc, bb pointers
    void initStatements();
    void numberStatements(int& stmtNum);
    void numberPhiStatements(int& stmtNum);
    bool nameStackLocations();
    bool nameRegisters();
    void removeRedundantPhis();
    void trimReturns();
    void addNewParameters();
    void trimParameters();
    void replaceExpressionsWithGlobals();
    void replaceExpressionsWithSymbols();
    void replaceExpressionsWithParameters(int depth);   // must be in SSA form
    void replaceExpressionsWithLocals();
    bool removeNullStatements();
    bool removeDeadStatements();
    typedef std::map<Statement*, int> RefCounter;
    void countRefs(RefCounter& refCounts);
    void removeUnusedStatements(RefCounter& refCounts, int depth);
    bool propagateAndRemoveStatements();
    void propagateStatements(int memDepth);
    int  findMaxDepth();                    // Find max memory nesting depth
    // Recalculate dataflow
    void repairDataflow(int memDepth, StatementSet& rs);

    void toSSAform(int memDepth, StatementSet& rs);
    void fromSSAform();
    void insertAssignAfter(Statement* s, int tempNum, Exp* right);

    // Insert actual arguments to match formals
    void insertArguments(StatementSet& rs);

    // prove any arbitary property of this procedure
    bool prove(Exp *query);
    // helper function, should be private
    bool prover(Exp *query, PhiExp *lastPhi = NULL);    

    // promote the signature if possible
    void promoteSignature();

    // get all the statements
    void getStatements(StatementList &stmts);

    // remove a statement
    void removeStatement(Statement *stmt);

    // inline constants / decode function pointer constants
    void processConstants();

    // get internal statements
    // Note: assignment causes shallow copy of list
    //virtual void getInternalStatements(StatementList &sl) {sl = internal;}
    // Calculate uses info
    void computeUses();

#if 0
    // get the set of locations "defined" in this procedure
    void getDefinitions(LocationSet &defs) {defs = definesSet;}

    // get the set of locations "returned" by this procedure
    void getReturnSet(LocationSet &ret) {ret = returnsSet;}

#endif

    void getDefinitions(LocationSet &defs);

private:
    /*
     * Find a pointer to the Exp* representing the given var
     * Used by the above 2
     */
    Exp** findVarEntry(int idx);

    /*
     * A special pass to check the sizes of memory that is about to be converted
     * into a var, ensuring that the largest size used in the proc is used for
     * all references (and it's declared that size)
     */
    void    checkMemSizes();

    /*
     * Implement the above for one given Exp*
     */
    void    checkMemSize(Exp* e);

public:

    /*
     * Sets the parameters that have been recovered for this procedure through
     * analysis.
     */
    void setParams(std::list<TypedExp*>& params, bool aggUsed = false);

    /*
     * Given a machine dependent location, return a generated symbolic
     * representation for it.
     */
    void toSymbolic(TypedExp* loc, TypedExp* result, bool local = true);

    /*
     * Return the next available local variable; make it the given type
     * Note: was returning TypedExp*
     */
    Exp* newLocal(Type* ty);

    /*
     * Add new locals, local<next available> to local<n-1>
     */
    void addLocals(int n);

    /*
     * Print the locals declaration in C style.
     */
    void printLocalsAsC(std::ostream& os);

    /*
     * Return the index of the first symbolic local for the procedure.
     */
    int getFirstLocalIndex();

    /*
     * Return the index of the last symbolic local for the procedure.
     */
    int getLastLocalIndex();
    
    /*
     * Return the list of symbolic locals for the procedure.
     */
    std::vector<TypedExp*>& getSymbolicLocals();
    
    /*
     * Replace each instance of a location in this procedure with its symbolic
     * representation if it has one.
     */
    void propagateSymbolics();

    /*
     * Get the BB that is the entry point (not always the first BB)
     */
    PBB getEntryBB();

    /*
     * Prints this procedure to an output stream.
     */
    std::ostream& put(std::ostream& os);

    /*
     * Set the entry BB for this procedure (constructor has the entry address)
     */
    void setEntryBB();

    /*
     * Get the callees
     */
    std::set<Proc*>& getCallees();

    /*
     * Add to the set of callees
     */
    void setCallee(Proc* callee); 

    /*
     * return true if this procedure contains the given address
     */
    bool containsAddr(ADDRESS uAddr);

    /*
     * Return true if this proc uses the special aggregate pointer as the
     * first parameter
     */
    virtual bool isAggregateUsed() {return aggregateUsed;}



};      /* UserProc */
#endif
